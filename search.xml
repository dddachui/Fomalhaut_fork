<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>将kickstart封装到iso镜像</title>
      <link href="/posts/83891c9e.html"/>
      <url>/posts/83891c9e.html</url>
      
        <content type="html"><![CDATA[<h1>获得一份镜像数据</h1><ul><li>挂载系统镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount centos.iso /mnt</span><br></pre></td></tr></table></figure><ul><li>拷贝到系统某个目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /iso</span><br><span class="line">cp -rp /mnt/*   /iso/</span><br></pre></td></tr></table></figure><h1>修改kickstart脚本</h1><ul><li>在/iso目录下创建一个文件夹来存放脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir kickstart</span><br></pre></td></tr></table></figure><ul><li>将ks脚本拷贝过来</li></ul><ol><li>可以用自己写的</li><li>可以拿已经安装的/root下的cfg文件</li></ol><h1>修改引导</h1><ul><li>修改isolinux/isolinux.cfg文件</li><li>添加引导</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cdrom</span></span><br><span class="line">label linux</span><br><span class="line">  menu label ^Install ikun system Standard(CDROM)</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img vga=0x314 lang=zh_CN ks=cdrom:/kickstart/test.cfg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">usb</span></span><br><span class="line">label linux</span><br><span class="line">  menu label ^Install ikun system Standard(USB)</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img vga=0x314 lang=zh_CN ks=hd:LABEL=Centos:/kickstart/test.cfg</span><br></pre></td></tr></table></figure><h1>封装镜像</h1><ul><li>封装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genisoimage -v -cache-inodes -joliet-long -R -J -T -V Centos  -o /opt/Centos-sp1.iso -c isolinux/boot.cat -b isolinux/isolinux.bin -no-emul-boot -boot-load-size 4 -boot-info-table -eltorito-alt-boot -b images/efiboot.img -no-emul-boot  /iso/  </span><br></pre></td></tr></table></figure><ul><li>校验</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implantisomd5   /opt/Centos-sp1.iso</span><br></pre></td></tr></table></figure><h1>测试</h1><p>虚拟机安装一下， 会发现自动加载了之前的配置，这样以后不同场景可以自己裁剪镜像来定制化</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kickstart脚本</title>
      <link href="/posts/6534009d.html"/>
      <url>/posts/6534009d.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>好用的软件</title>
      <link href="/posts/3df4b4e4.html"/>
      <url>/posts/3df4b4e4.html</url>
      
        <content type="html"><![CDATA[<h1>nice软件(持续更新)</h1><ul><li><a href="https://github.com/kingToolbox/WindTerm">windterm</a></li><li><a href="https://github.com/yang991178/fluent-reader">https://github.com/yang991178/fluent-reader</a></li><li><a href="https://github.com/rustdesk/rustdesk">rustdesk</a></li><li><a href="https://github.com/massCodeIO/massCode">massCode</a></li><li><a href="https://obsidian.md/">obsidian</a></li><li><a href="https://github.com/lyswhut/lx-music-desktop">lx-music-desktop</a></li><li><a href="https://github.com/charmbracelet/glow">glow</a></li><li><a href="https://input.kfsafe.cn/">卡饭</a></li><li><a href="https://github.com/alist-org/alist">alist</a></li><li><a href="https://github.com/purocean/yn">yank note</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客图片使用记录</title>
      <link href="/posts/6b240272.html"/>
      <url>/posts/6b240272.html</url>
      
        <content type="html"><![CDATA[<h1>使用记录</h1><h2 id="背景图">背景图</h2><ul><li>9</li><li>19</li><li>29</li><li>39</li></ul><h2 id="文章图">文章图</h2><ul><li>学习目标 1</li><li>好用的软件 2</li><li>crontab 3</li><li>博客图片使用记录 4</li><li>局域网ip冲突解决方法 5</li><li>linux的驱动问题 6</li><li>系统资源异常处理思路 7</li><li>用户被锁定 8</li><li>在Centos中检查RPM包的依赖性 10</li><li>git拉取总是需要密码 11</li><li>inode节点爆满处理 12</li><li>Linux好用命令之at 13</li><li>Linux好用命令之bizp2 14</li><li>Linux好用命令之dd 15</li><li>Linux好用命令之df 16</li><li>Linux好用命令之dnf 17</li><li>Linux好用命令之dos2unix 18</li><li>Linux好用命令之ethtool 20</li><li>Linux好用命令之free 21</li><li>Linux好用命令之gdb 22</li><li>Linux好用命令之git 23</li><li>Linux好用命令之gzip 24</li><li>Linux好用命令之iostat 25</li><li>Linux好用命令之lscpu 26</li><li>Linux好用命令之lsof 27</li><li>Linux好用命令之lspci 28</li><li>Linux好用命令之md5sum 30</li><li>Linux好用命令之netstat 31</li><li>Linux好用命令之nmcli 32</li><li>Linux好用命令之pidstat 33</li><li>Linux好用命令之ps 34</li><li>Linux好用命令之rpm 35</li><li>Linux好用命令之rsync 36</li><li>Linux好用命令之screen 37</li><li>Linux好用命令之strace 38</li><li>Linux好用命令之systemctl 40</li><li>Linux好用命令之tar 41</li><li>Linux好用命令之top 42</li><li>Linux好用命令之ulimit 43</li><li>Linux好用命令之xz 44</li><li>Linux好用命令之yum 45</li><li>Linux好用命令之zip 46</li><li>博客搭建 47</li><li>源码安装软件 48</li><li>centos7安装nvida显卡驱动 49</li><li>code-server搭建 50</li><li>mdadm制作raid测试 51</li><li>pxe+ks安装centos 52</li><li>配置网络-network 53</li><li>配置网络-nmcli 54</li><li>配置bond-network 55</li><li>cpuinfo 56</li><li>limits.conf配置 57</li><li>repo文件解释 58</li><li>查看centos系统引导方式 59</li><li>磁盘测速 60</li><li>多线程压缩与解压 61</li><li>防火墙firewalld 62</li><li>防止误删的操作 63</li><li>计算机容量换算 64</li><li>镜像站合集 65</li><li>配置yum源 66</li><li>增加swap分区 67</li><li>bash和csh的区别 68</li><li>CVE漏洞 69</li><li>dnf插件 70</li><li>fcitx码表 71</li><li>fio测速 72</li><li>linux环境变量 73</li><li>linux机器信息采集 74</li><li>lvm操作 75</li><li>RH442系统调优笔记 76</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023目标</title>
      <link href="/posts/7169e9ad.html"/>
      <url>/posts/7169e9ad.html</url>
      
        <content type="html"><![CDATA[<h1>学习Flag</h1><ol><li>考完驾照！</li><li>学习rpm打包方法</li><li>学习ks文件使用，包括文件编写、pxe自动安装、封装镜像</li><li>rub原理学习(修复legacy、uefi引导、基本操作)</li><li>linux双网卡使用NetworkManager服务访问资源问题解决</li><li>高并发文档精简</li></ol><h1>人生目标</h1><ol><li>找个对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pxe+ks安装centos</title>
      <link href="/posts/97d0e5b8.html"/>
      <url>/posts/97d0e5b8.html</url>
      
        <content type="html"><![CDATA[<h1>PXE概述</h1><p>PXE(Pre-boot Execution Environment)是由Intel设计的协议，它可以使计算机通过网络启动。工作在Client/Server模式，允许客户机通过网络从远程服务器下载引导镜像，并加载安装文件或者整个操作系统</p><h1>PXE优点</h1><p>1、规模化：可以同时装配多台服务器；<br>2、自动化：安装系统、配置各种服务；<br>3、远程实现：不需要光盘、U盘等介质进行安装</p><h1>实现PXE安装条件</h1><p>1、客户机的网卡需要支持PXE协议，且主板支持网络引导。一般服务器都支持，只需要进入BIOS设置允许从Network或LAN启动即可<br>2、网络中有一台DHCP服务器以便为客户机自动分配IP地址，指定引导文件位置。<br>3、服务器要通过（简单文件传输协议）服务来提供系统内核和引导镜像文件的下载。</p><h1>注意事项</h1><p>安装成功的最关键因素在于kS脚本的编写，其他nginx tftp dhcp只是辅助用于客户机访问ks，源，传输用的</p><h1>安装步骤</h1><h2 id="安装组件功能介绍">安装组件功能介绍</h2><p>Kickstart ： 将安装过程的参数写入到ks.cfg文件，实现自动安装配置达到无人值守自动安装<br>： 支持PXE 引导的网卡中从服务器端下载pxelinux.0文件、vmlinuz、initrd.img等内核引导文件<br>DHCP ： PXE引导过程中先获取IP地址，并提供pxelinux.0文件位置<br>HTTP ： 用于下载ks.cfg以及系统镜像文件</p><h2 id="配置nginx">配置nginx</h2><ul><li>安装nginx<br>可以源码编译安装，如果源里面有需要的版本可以yum安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx </span><br></pre></td></tr></table></figure><ul><li>挂载镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/centos/7/os/x86_64 -p</span><br></pre></td></tr></table></figure><p>将centos7最小化镜像挂载到目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount CentOS-7-x86_64-Minimal-2009.iso   /data/centos/7/os/x86_64</span><br></pre></td></tr></table></figure><ul><li>修改nginx配置<br>挂载/data目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /data;</span><br><span class="line">        index index.html index.php index.htm;</span><br><span class="line">        autoindex on;   # 允许显示目录</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动nginx</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now nginx</span><br></pre></td></tr></table></figure><ul><li>验证结果<br>访问http://192.168.42.132/centos/7/os/x86_64,最终实现可以访问到centos挂载的内容</li></ul><h2 id="配置dhcp服务">配置dhcp服务</h2><ul><li>安装软件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y dhcp</span><br></pre></td></tr></table></figure><ul><li>修改主机名</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl set-hostname pxe.com</span><br></pre></td></tr></table></figure><ul><li>修改配置<br>修改/etc/dhcp/dhcpd.conf,对自己的一张网卡设置ip地址为192.168.1.100(具体可以自定义)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置租约时间和最大租约时间</span></span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义域名</span></span><br><span class="line">option domain-name &quot;pxe.com&quot;;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义地址池的子网、掩码、网关和地址池范围，定义地址</span></span><br><span class="line">subnet 192.168.1.0 netmask 255.255.255.0 &#123;</span><br><span class="line">      range 192.168.1.10 192.168.1.20;</span><br><span class="line">      option routers 192.168.1.1;</span><br><span class="line">      next-server 192.168.1.100;</span><br><span class="line">      filename &quot;pxelinux.0&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动服务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now dhcpd</span><br></pre></td></tr></table></figure><h2 id="编写KS脚本">编写KS脚本</h2><p>每个系统安装完毕之后在/root下都有一个anaconda-ks.cfg文件，这其实就是当前系统安装时用的脚本，我们可以根据此文件进行修改，也可以自己重头来写，也可以安装system-config-kickstart此软件进行图形化编写，如果不会就先安装一遍系统然后根据系统的学习</p><ul><li>设置新系统root密码<br>这个密码需要替换到ks脚本里面的rootpw，作为新系统的密码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import crypt;print crypt.crypt(&quot;niubi.ks&quot;)&#x27;</span><br></pre></td></tr></table></figure><ul><li>存放ks脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/ksdir</span><br><span class="line">touch /data/ksdir/ks7-mini.cfg</span><br><span class="line">chmod +r /data/ksdir/ks7-mini.cfg</span><br></pre></td></tr></table></figure><ul><li>ks脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">version=DEVEL</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System authorization information</span></span><br><span class="line">auth --enableshadow --passalgo=sha512</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use pxe install</span> </span><br><span class="line">url --url=http://192.168.1.100/centos/7/os/x86_64</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use graphical install</span></span><br><span class="line">graphical</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run the Setup Agent on first boot</span></span><br><span class="line">firstboot --disable</span><br><span class="line">ignoredisk --only-use=sda</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Keyboard layouts</span></span><br><span class="line">keyboard --vckeymap=us --xlayouts=&#x27;us&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System language</span></span><br><span class="line">lang en_US.UTF-8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Network information</span></span><br><span class="line">network  --bootproto=dhcp --device=eth0 --onboot=off --ipv6=auto --no-activate</span><br><span class="line">network  --hostname=localhost.localdomain</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Root password</span></span><br><span class="line">rootpw --iscrypted $6$9SJ2mbfniIe1xZMv$vQGhIJeDNIX7MeIgAV36vew9ptH.F8VuHloW3eacdKAxwDFVAa8TViUZlN8SpZgu22EEySuyegRsPlRLRoftN1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System services</span></span><br><span class="line">services --enabled=&quot;chronyd&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System timezone</span></span><br><span class="line">timezone Asia/Shanghai --isUtc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System bootloader configuration</span></span><br><span class="line">bootloader --append=&quot; crashkernel=auto&quot; --location=mbr --boot-drive=sda</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Partition clearing information</span></span><br><span class="line">clearpart --none --initlabel</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Disk partitioning information</span></span><br><span class="line">part /boot/efi --fstype=&quot;efi&quot; --ondisk=sda --size=200 --fsoptions=&quot;umask=0077,shortname=winnt&quot;</span><br><span class="line">part pv.156 --fstype=&quot;lvmpv&quot; --ondisk=sda --size=49974</span><br><span class="line">part /boot --fstype=&quot;ext4&quot; --ondisk=sda --size=1024</span><br><span class="line">volgroup centos --pesize=4096 pv.156</span><br><span class="line">logvol swap  --fstype=&quot;swap&quot; --size=2048 --name=swap --vgname=centos</span><br><span class="line">logvol /  --fstype=&quot;ext4&quot; --grow --maxsize=51200 --size=1024 --name=root --vgname=centos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">packages</span></span><br><span class="line">@^minimal</span><br><span class="line">@core</span><br><span class="line">chrony</span><br><span class="line">kexec-tools</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">end</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">addon com_redhat_kdump --<span class="built_in">enable</span> --reserve-mb=<span class="string">&#x27;auto&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">end</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">anaconda</span></span><br><span class="line">pwpolicy root --minlen=6 --minquality=1 --notstrict --nochanges --notempty</span><br><span class="line">pwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyok</span><br><span class="line">pwpolicy luks --minlen=6 --minquality=1 --notstrict --nochanges --notempty</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">end</span></span><br></pre></td></tr></table></figure><h2 id="配置tftp">配置tftp</h2><ul><li>安装软件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y  tftp-server syslinux xinetd</span><br></pre></td></tr></table></figure><ul><li>修改tftp配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/xinetd.d/tftp </span><br></pre></td></tr></table></figure><p>修改如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">service </span><br><span class="line">&#123;</span><br><span class="line">socket_type= dgram</span><br><span class="line">protocol= udp</span><br><span class="line">wait= yes</span><br><span class="line">user= root</span><br><span class="line">server= /usr/sbin/in.d</span><br><span class="line">server_args= -s /var/lib/boot</span><br><span class="line">disable= no</span><br><span class="line">per_source= 11</span><br><span class="line">cps= 100 2</span><br><span class="line">flags= IPv4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>拷贝文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/tftpboot</span><br><span class="line">mkdir 7 pxelinux.cfg</span><br><span class="line">cp /usr/share/syslinux/&#123;pxelinux.0,menu.c32&#125;  .</span><br><span class="line">cp /data/centos/7/os/x86_64/isolinux/&#123;vmlinuz,initrd.img&#125; 7</span><br></pre></td></tr></table></figure><ul><li>修改pxe启动项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/tftpboot/pxelinux.cfg/default</span><br></pre></td></tr></table></figure><p>内容如下，请确保http://192.168.1.100/ksdir/ks7-mini.cfg可以访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果将值修改为正文mini标签的话，默认选择mini标签，不会让用户选择</span></span><br><span class="line">default menu.c32</span><br><span class="line">timeout 600</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">背景标题</span></span><br><span class="line">menu title ########## GXM-PXE Boot Menu ##########</span><br><span class="line">label mini7</span><br><span class="line">    menu label install centos mini 7</span><br><span class="line">    kernel 7/vmlinuz</span><br><span class="line">    append initrd=7/initrd.img ks=http://192.168.1.100/ksdir/ks7-mini.cfg</span><br><span class="line">label local</span><br><span class="line">    menu default</span><br><span class="line">    menu label ^Boot from local drive</span><br><span class="line">    localboot 0xffff</span><br></pre></td></tr></table></figure><ul><li>启动服务</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">enable</span> <span class="comment">--now xinetd tftp</span></span><br></pre></td></tr></table></figure><h2 id="客户端网络引导启动">客户端网络引导启动</h2><p>设置客户端系统为网络启动，查看开机引导画面测试</p>]]></content>
      
      
      <categories>
          
          <category> 系统安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之ethtool</title>
      <link href="/posts/c0d4357c.html"/>
      <url>/posts/c0d4357c.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>查看网口用的</p><h1>查看网卡信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool eth0</span><br></pre></td></tr></table></figure><ul><li>网卡信息如下<br>可以看出网卡的很多信息,包括网卡速率是百兆还是千兆</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Settings for enp2s0:</span><br><span class="line">        Supported ports: [ TP    MII ]</span><br><span class="line">        Supported link modes:   10baseT/Half 10baseT/Full</span><br><span class="line">                                100baseT/Half 100baseT/Full</span><br><span class="line">                                1000baseT/Half 1000baseT/Full</span><br><span class="line">        Supported pause frame use: Symmetric Receive-only</span><br><span class="line">        Supports auto-negotiation: Yes</span><br><span class="line">        Supported FEC modes: Not reported</span><br><span class="line">        Advertised link modes:  10baseT/Half 10baseT/Full</span><br><span class="line">                                100baseT/Half 100baseT/Full</span><br><span class="line">                                1000baseT/Half 1000baseT/Full</span><br><span class="line">        Advertised pause frame use: Symmetric Receive-only</span><br><span class="line">        Advertised auto-negotiation: Yes</span><br><span class="line">        Advertised FEC modes: Not reported</span><br><span class="line">        Link partner advertised link modes:  10baseT/Half 10baseT/Full</span><br><span class="line">                                             100baseT/Half 100baseT/Full</span><br><span class="line">                                             1000baseT/Full</span><br><span class="line">        Link partner advertised pause frame use: Symmetric</span><br><span class="line">        Link partner advertised auto-negotiation: Yes</span><br><span class="line">        Link partner advertised FEC modes: Not reported</span><br><span class="line">        Speed: 1000Mb/s</span><br><span class="line">        Duplex: Full</span><br><span class="line">        Auto-negotiation: on</span><br><span class="line">        master-slave cfg: preferred slave</span><br><span class="line">        master-slave status: slave</span><br><span class="line">        Port: Twisted Pair</span><br><span class="line">        PHYAD: 0</span><br><span class="line">        Transceiver: external</span><br><span class="line">        MDI-X: Unknown</span><br><span class="line">        Supports Wake-on: pumbg</span><br><span class="line">        Wake-on: d</span><br><span class="line">        Link detected: yes</span><br></pre></td></tr></table></figure><h1>把网卡指示灯打开</h1><p>在网卡支持这种功能的前提下,使用此命令会使网卡的指示灯闪烁,但需要注意,有些系统会持续闪烁,但有些版本会闪烁几秒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -p eth0</span><br></pre></td></tr></table></figure><h1>查看错误信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -S eth0 | grep error</span><br></pre></td></tr></table></figure><p>同时，使用<code>ifconfig</code> 也可以看错误信息</p><h1>错误信息</h1><ul><li>RX errors<br>表示总的收包的错误数量，这包括 too-long-frames 错误，Ring Buffer 溢出错误，crc 校验错误，帧同步错误，fifo overruns 以及 missed pkg 等等</li><li>RX dropped<br>表示数据包已经进入了 Ring Buffer，但是由于内存不够等系统原因，导致在拷贝到内存的过程中被丢弃</li><li>RX overruns<br>表示了 fifo 的 overruns，这是由于 Ring Buffer(aka Driver Queue) 传输的 IO 大于 kernel 能够处理的 IO 导致的，而 Ring Buffer 则是指在发起 IRQ 请求之前的那块 buffer。很明显，overruns 的增大意味着数据包没到 Ring Buffer 就被网卡物理层给丢弃了(就是ring buffer满之后先有drop收到的，再overrun没收的)，而 CPU 无法即使的处理中断是造成 Ring Buffer 满的原因之一</li><li>RX frame<br>表示 misaligned 的 frames</li></ul><h1>rx_crc_errors</h1><p>在大多数情况下，增加rx_crc_errors的值意味着该问题出在网络模型的第1层，当在接口上接收到数据包时，它将经历数据完整性检查，这称为循环冗余检查。 如果数据包在该检查中失败，则将其标记为rx_crc_errors<br>1.更换电缆。<br>2.检查交换机配置。<br>3.更换网络接口卡。</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置网络-nmcli</title>
      <link href="/posts/b42b0a3e.html"/>
      <url>/posts/b42b0a3e.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 网络管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置网络-network</title>
      <link href="/posts/9aa692c0.html"/>
      <url>/posts/9aa692c0.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 网络管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之dd</title>
      <link href="/posts/3f7fa63c.html"/>
      <url>/posts/3f7fa63c.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><blockquote><p><a href="https://www.cnblogs.com/sylar5/p/6649009.html">Linux 中用 dd 命令来测试硬盘读写速度 - Cyril_Wu - 博客园 (cnblogs.com)</a></p></blockquote><h1>基本用法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time dd if=/dev/zero  of=/dev/null bs=block_size count=number_of_blocks</span><br></pre></td></tr></table></figure><h1>参数选项</h1><ul><li>选项<ul><li>if=file  ：从 file 中读而不是标准输入</li><li>of=file ：写到 file 里去而不是标准输出</li><li>bs=bytes ：一次读和写  bytes 字节</li><li>ibs=bytes ：一次读 bytes 字节。默认是512</li><li>obs=bytes ：一次写 bytes 字节。默认是512</li><li>count=blocks ： 仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数</li><li>iflag=FLAGS   ：指定读的方式FLAGS</li><li>oflag=FLAGS  ：指定写的方式FLAGS</li></ul></li><li>FLAGS如下<ul><li>direct　　　读写数据采用直接IO方式；</li><li>directory　读写失败除非是directory；</li><li>dsync　　　读写数据采用同步IO；</li><li>sync　　　　同上，但是针对是元数据</li><li>fullblock　　堆积满block(iflag only)；</li><li>nonblock　读写数据采用非阻塞IO方式</li><li>noatime　　 读写数据不更新访问时间</li></ul></li></ul><h1>磁盘写能力测试</h1><p>/dev/zero是一个伪设备，只产生空字符流，不会产生IO，IO都会集中在of文件中，所以这个命令是测试磁盘的写能力。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=test bs=8k count=10000 oflag=direct</span><br></pre></td></tr></table></figure><h1>读取能力测试</h1><p>/dev/sdb是一个物理分区，对它的读取会产生IO，/dev/null是伪设备，是黑洞，of到该设备不会产生IO，所以，这个命令的IO只发生在/dev/sdb上，也相当于测试磁盘的读能力</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=test of=/dev/null bs=8k count=10000 iflag=direct</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之rsync</title>
      <link href="/posts/bc5c9a0b.html"/>
      <url>/posts/bc5c9a0b.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>同步的手段</p><h1>简单用法</h1><p>静态文件部署，一般会用到此命令，完整命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --progress -e &#x27;ssh -p 2022&#x27; --exclude=&#x27;testfile&#x27; --delete $&#123;WORKSPACE&#125;/  root@192.168.42.100:/data/</span><br></pre></td></tr></table></figure><h1>参数可用</h1><ul><li>-a：–archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD</li><li>-v：输出详细过程</li><li>-z：对正在备份的文件进行压缩处理</li><li>-r：对子目录以递归模式处理</li><li>-l：保留软连接</li><li>-p：保持文件权限</li><li>-t：保持文件时间信息</li><li>-g：保持文件属组信息</li><li>-o：保持文件属主信息</li><li>-D：保持设备文件信息</li><li>-e： –rsh=command 指定使用rsh、ssh方式进行数据同步，一般使用ssh</li><li>exclude: 排除某文件的同步，可以多个。</li><li>–delete：删除那些DST中SRC没有的文件。</li><li>–progress：显示每个文件传输的进度。知道是否有大型文件正在备份可能是有用的</li></ul><h1>几个坑</h1><ul><li><p>将dirA的所有文件同步到dirB内，并删除dirB内多余的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --delete dirA/ dirB/ </span><br></pre></td></tr></table></figure></li></ul><blockquote><p>源目录和目标目录结构一定要一致！！</p><p>不能是dirA/* dirB/ 或者dirA/ dirB/* 或者 dirA/* dirB/*，如果不遵守，那么就不会删除。</p></blockquote><ul><li><p>将dirA的所有文件同步到dirB，但是在dirB内除了fileB3.txt这个文件不删之外，其他的都删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --delete --exclude &quot;fileB3.txt&quot; dirA/ dirB/</span><br></pre></td></tr></table></figure></li><li><p>将dirA目录内的fileA1.txt和fileA2.txt不同步到dirB目录内</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude=&quot;fileA1.txt&quot; --exclude=&quot;fileA2.txt&quot; dirA/ dirB/</span><br></pre></td></tr></table></figure></li><li><p>将dirA目录内的fileA1.txt和fileA2.txt不同步到dirB目录内，并且在dirB目录内删除多余的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude=&quot;fileA1.txt&quot; --exclude=&quot;fileA2.txt&quot; --delete dirA/ dirB/</span><br></pre></td></tr></table></figure></li><li><p>将dirA目录内的fileA1.txt和fileA2.txt不同步到dirB目录内，并且在dirB目录内删除多余的文件，同时，如果dirB内有fileA2.txt和fileA1.txt这两个被排除同步的文件，仍然将其删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude=&quot;fileA1.txt&quot; --exclude=&quot;fileA2.txt&quot; --delete-excluded dirA/ dirB/</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Centos中检查RPM包的依赖性</title>
      <link href="/posts/179557ff.html"/>
      <url>/posts/179557ff.html</url>
      
        <content type="html"><![CDATA[<h1>产生原因</h1><ol><li>定制本地yum源的时候漏了几个依赖包,导致软件无法安装</li><li>配置的仓库包不完整,下载的软件的时候缺少几个包</li><li>由于网络环境,无法配置外网源,只能导入rpm包,但是缺少了几个依赖</li></ol><blockquote><p>很多场景下，是不允许配置yum源的</p></blockquote><h1>一个简单的栗子</h1><ul><li>安装zabbix的时候缺少依赖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh zabbix-server-mysql-3.4.4-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error: Failed dependencies:</span><br><span class="line">libOpenIPMI.so<span class="number">.0</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libOpenIPMIposix.so<span class="number">.0</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libevent-<span class="number">2.0</span>.so<span class="number">.5</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libiksemel.so<span class="number">.3</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libnetsnmp.so<span class="number">.31</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libodbc.so<span class="number">.2</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br></pre></td></tr></table></figure><p>显然是机器导入的rpm缺少依赖包导致的,但我们只能看到文件,无法看到这个文件在什么包</p><ul><li>查询在哪个rpm包</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> whatprovides libOpenIPMI.so.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>结果如下,可以看到这文件是OpenIPMI-libs提供的,我们可以直接yum安装,或者由于网络问题,可以下载了导入机器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos, versionlock</span><br><span class="line">OpenIPMI-libs-2.0.27-1.el7.i686 : The OpenIPMI runtime libraries</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Provides    : libOpenIPMI.so.0</span><br></pre></td></tr></table></figure><ul><li><p>安装</p><ul><li><p>直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y OpenIPMI-libs-2.0.27-1.el7.i686</span><br></pre></td></tr></table></figure></li><li><p>下载导入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yumdownloader</span> --destdir=.   OpenIPMI-libs-<span class="number">2</span>.<span class="number">0</span>.<span class="number">27</span>-<span class="number">1</span>.el7.i686</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>优化解决依赖手法1</h1><p>除了<code>yum whatprovides libOpenIPMI.so.0</code>这种粗暴方式,其实我们有更好的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum deplist  zabbix50-5.0.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>输出如下.可以看到什么包需要什么,由谁提供</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos, versionlock</span><br><span class="line">package: zabbix50.x86_64 5.0.21-1.el7</span><br><span class="line">  dependency: config(zabbix50) = 5.0.21-1.el7</span><br><span class="line">   provider: zabbix50.x86_64 5.0.21-1.el7</span><br><span class="line">  dependency: libc.so.6()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.11)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.14)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.15)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.17)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.2.5)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.3)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.3.4)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.4)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.7)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libcrypto.so.10()(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcrypto.so.10(OPENSSL_1.0.1_EC)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcrypto.so.10(OPENSSL_1.0.2)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcrypto.so.10(libcrypto.so.10)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcurl.so.4()(64bit)</span><br><span class="line">   provider: libcurl.x86_64 7.29.0-59.el7_9.1</span><br><span class="line">  dependency: libdl.so.2()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libm.so.6()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libm.so.6(GLIBC_2.2.5)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libpcre.so.1()(64bit)</span><br><span class="line">   provider: pcre.x86_64 8.32-17.el7</span><br><span class="line">  dependency: libpthread.so.0()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libpthread.so.0(GLIBC_2.2.5)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libresolv.so.2()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libssl.so.10()(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libssl.so.10(libssl.so.10)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libz.so.1()(64bit)</span><br><span class="line">   provider: zlib.x86_64 1.2.7-20.el7_9</span><br><span class="line">  dependency: libz.so.1(ZLIB_1.2.0)(64bit)</span><br><span class="line">   provider: zlib.x86_64 1.2.7-20.el7_9</span><br><span class="line">  dependency: logrotate</span><br><span class="line">   provider: logrotate.x86_64 3.8.6-19.el7</span><br><span class="line">  dependency: rtld(GNU_HASH)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">   provider: glibc.i686 2.17-326.el7_9</span><br></pre></td></tr></table></figure><h1>优化解决依赖手法2</h1><p>配置一台和生产测试一样的虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zabbix50-5.0.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>使用yum install会自己查询依赖，如下所示，我们可以直接得到需要的依赖关系</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">正在安装</span><br><span class="line">ansible</span><br><span class="line">为依赖而安装</span><br><span class="line"><span class="keyword">python</span>-babel</span><br><span class="line"><span class="keyword">python</span>-httplib2</span><br><span class="line"><span class="keyword">python</span>-jinja2</span><br><span class="line"><span class="keyword">python</span>-paramiko</span><br><span class="line">python2-jmespath</span><br></pre></td></tr></table></figure><p>我们再次用<code>yumdownloader</code>命令进行下载包</p><h1>优化解决依赖手法3</h1><p>我常用的方法,但<code>需要注意</code>的是,使用<code>yumdownloader</code>的时候,他会检测本机的rpm包,然后下载软件缺失的依赖包,那么就是说,如果我本机和目的rpm列表有出入,可能我本机的包更多,那么我下载的依赖可能更少,那么导入目标机器结果依赖可能还是没解决,所以我们这个手法还是需要保持俩台机器的环境一致</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumdownloader --destdir=<span class="regexp">/root/</span>Desktop/rpms --resolve ansible</span><br></pre></td></tr></table></figure><h1>小工具-rpmreaper</h1><p>本来是用作清理系统中无用以及它们所依赖的包，它有很直观的ncurses界面来展示已安装的包和它们依赖关系的树形图</p><ul><li>安装</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> rpmreaper</span><br></pre></td></tr></table></figure><ul><li>运行</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rpmreaper</span></span><br></pre></td></tr></table></figure><p>rpmrepater会向用户显示已安装包的列表</p><ol><li><p>你可以使用上/下箭头来滚动屏幕</p></li><li><p>你可以在指定包上使用&quot;r&quot;键来显示其依赖关系，循环在指定包上按下&quot;r&quot;键可以展示出余下的信息</p></li><li><p>&quot;L&quot;标志的意思是说这个包是一片“孤叶”，意思说说没有任何包依赖它</p></li><li><p>&quot;o&quot;标志是说这个包是整个依赖链的中间部分</p></li><li><p>按下&quot;b&quot;键会显示其他依赖于该包的其他包</p></li></ol><h1>小工具-yumex</h1><p>yum Extender (简称 yumex ) , 是 yum 的图形化操作界面。可以通过 yumex 方便的查看软件包，安装、卸载软件包。对于对命令行不熟的人简直就是神奇，管理软件包很方便</p><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install yumex</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumex --root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局域网ip冲突解决方法</title>
      <link href="/posts/771f3e87.html"/>
      <url>/posts/771f3e87.html</url>
      
        <content type="html"><![CDATA[<h1>问题描述</h1><p>由于在一个网段下面ip地址是唯一的,当产生2个一样的ip的时候就会出现网络故障,可以hi使用一个工具<code>arp-scan</code>来扫描它们，这个工具会在本地网络发送ARP（Address Resolution Protocol）(地址解析协议)包来收集地址。如果有多个MAC地址声称拥有相同的IP地址，那么就存在冲突</p><h1>安装软件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y arp-scan</span><br></pre></td></tr></table></figure><h1>冲突检测</h1><p>指定eth1网卡进行检测</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan  --interface=eth1 -l</span><br></pre></td></tr></table></figure><h1>输出结果</h1><p>虚拟机不是很准,实际上是可以看到<code>DUP</code>的报错</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">1</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:c0:<span class="number">00</span>:<span class="number">08</span>VMware, Inc.</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">2</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:e1:<span class="number">0</span>b:edVMware, Inc.</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">254</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:e4:eb:<span class="number">75</span>VMware, Inc.</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">2</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:e1:<span class="number">0</span>b:edVMware, Inc. (DUP: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之tar</title>
      <link href="/posts/2208ab89.html"/>
      <url>/posts/2208ab89.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>Unix和<a href="https://baike.baidu.com/item/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F/4336219?fromModule=lemma_inlink">类Unix系统</a>上的压缩打包工具，可以将多个文件合并为一个文件，打包后的文件后缀亦为<strong>tar</strong></p><h1>参数</h1><h2 id="功能">功能</h2><ul><li>-c 创建压缩文件</li><li>-x  解压缩,提取</li><li>-t  查看压缩包内容</li><li>-r  附加新的文件到tar文件中</li><li>-u 用已打包的文件的较新版本更新tar文件</li><li>-A 将tar文件作为一个整体追加到另一个tar文件中</li><li>-d,–compare 将文件系统里的文件和tar文件里的文件进行比较</li><li>–delete  删除tar文件里的文件</li></ul><h2 id="常用选项">常用选项</h2><ul><li>-v 啰嗦模式,展示过程</li><li>-z 通过gzip指令压缩/解压缩文件,文件后缀名自己加<code>*.tar.gz</code></li><li>-p 保留原来的文件权限与属性</li><li>–exclude= 排除</li><li>-C 仅压缩指定目录里的内容或解压缩到指定目录</li></ul><h1>打包压缩</h1><ul><li>经典打包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf test.tar.gz  shell/  a.txt   b.sh</span><br></pre></td></tr></table></figure><ul><li>压缩带属性</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvpf log31.tar.gz log2014.log log2015.log log2016.log</span><br></pre></td></tr></table></figure><ul><li>压缩排除某些文件夹</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --exclude=/opt/test/a -czvf test.tar.gz /opt/test</span><br></pre></td></tr></table></figure><h1>列举查看压缩包</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf test<span class="selector-class">.tar</span><span class="selector-class">.gz</span> </span><br></pre></td></tr></table></figure><h1>解压缩</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf test.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压部分文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf  log.tar.gz  test/a.log</span><br></pre></td></tr></table></figure><blockquote><p>这个要先用-tvf列举出具体路径,不然找不到我示例的test/a.log</p></blockquote><ul><li>解压到指定位置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf a.tar.gz -C /opt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程压缩与解压</title>
      <link href="/posts/c9c09545.html"/>
      <url>/posts/c9c09545.html</url>
      
        <content type="html"><![CDATA[<h1>pigz简介</h1><p>使用pigz，利用了多核cpu，提高了压缩速度，将我们闲置的核心利用起来！</p><h1>前提</h1><p>首先要安装一个pigz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pigz</span><br></pre></td></tr></table></figure><h1>pigz常用命令参数</h1><ul><li>-p: 设置最大使用线程数量，默认所有在线cpu，如果不能获取cpu数量，则取8</li><li>-b：设置压缩块大小，默认128k</li><li>-d：解压缩</li><li>-q：静默模式，不输出任何信息</li><li>-k：不删除原始文件</li><li>-l：输出压缩内容</li><li>-r：递归子目录</li><li>-S：使用sss后缀替换gz</li><li>-v：输出详细信息</li></ul><h1>多线程压缩</h1><p>–use-compress-program=pigz即代表使用的pigz工具</p><blockquote><p>加time只是用来对比时间</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time tar --use-compress-program=pigz -cvpf dxc.tar.gz  ./*</span><br></pre></td></tr></table></figure><h1>多线程解压</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time tar --use-compress-program=pigz -xvpf dxc.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pigz -p 8 -d output.tgz</span><br></pre></td></tr></table></figure><h1>pigz参数使用方式</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --<span class="keyword">use</span>-<span class="keyword">compress</span>-<span class="keyword">program</span>=<span class="string">&quot;pigz -k -p8&quot;</span> -cvf output.tgz   /<span class="keyword">var</span>/<span class="keyword">log</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解压缩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的驱动问题</title>
      <link href="/posts/8715157e.html"/>
      <url>/posts/8715157e.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>安装windows系统一般都会下载<code>驱动总裁</code>或者<code>鲁大师</code>,又或者通过微软的自动更新来更新系统的驱动,但在Linux里面,驱动一般是集成在linux内核里面的,如果我们有一个pci设备没有驱动且内核不支持该怎么处理?</p><h1>查看设备驱动</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lspci -k</span> </span><br></pre></td></tr></table></figure><p>可以先浏览一遍所有的pci设备,只需要关注每个设备是否有<code>Kernel driver in use</code>等字样,如果有的话就代表该设备可以驱动</p><ul><li>举个例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">02</span>:<span class="number">01.0</span> Ethernet controller: Intel Corporation 82545EM Gigabit Ethernet <span class="title function_">Controller</span> <span class="params">(Copper)</span> (rev <span class="number">01</span>)</span><br><span class="line">DeviceName: Ethernet0</span><br><span class="line">Subsystem: VMware PRO/<span class="number">1000</span> MT Single Port Adapter</span><br><span class="line">Kernel driver in use: e1000</span><br><span class="line">Kernel modules: e1000</span><br></pre></td></tr></table></figure><p>例如我有一个网卡,他成功加载了e1000的驱动,这样就代表我们可以使用该网卡</p><h1>没有驱动的处理</h1><p>如果没有<code>Kernel driver in use</code>字样,处理手段一般是<code>确认硬件型号</code>-&gt;<code>搜寻源代码</code>-&gt;<code>编译安装</code>来解决的</p><h2 id="确定型号">确定型号</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -<span class="keyword">nn</span> | <span class="keyword">grep</span> -i eth</span><br></pre></td></tr></table></figure><p>我们通过<code>-nn</code>参数来将<code>厂商号:设备号</code>输出如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">02</span>:<span class="number">01</span>.<span class="number">0</span> Ethernet : Intel Corporation <span class="number">82545</span>EM Gigabit <span class="meta"> [8086:100f] (rev 01)</span></span><br></pre></td></tr></table></figure><p>其中,我们只需要关注<code>[8086:100f]</code>这组数据就可以了</p><h2 id="含义">含义</h2><p><code>8086</code>是厂商号,代表某家厂商,<code>100f</code>是设备号,代表该厂商的产品</p><p>一般来说,如果内核完全不认网卡的话我们只能看出产品名字写的是<code>Ethernet</code>,也有一部分系统<code>可以认出全名</code>,如果能认出全名我们直接搜索全名就可以了,但如果没有全名我们只能依赖<code>厂商号:设备号</code>来定位设备</p><h2 id="网页搜索">网页搜索</h2><p>登陆<a href="https://devicehunt.com/">devicehunt网站</a>,我们只需要将我们的<code>device id</code>,即我例子中的<code>100f</code>填入搜索框,他就会将该设备的名字查询出来,类似这种网站的还有很多,比如 <a href="http://pci-ids.ucw.cz/read/PC/8088/0107">pci-ids.ucw.cz</a></p><h2 id="查找驱动">查找驱动</h2><p>既然已经知道型号了,那么就可以搜索对应的驱动源代码,一般找的网站有如下</p><ol><li>各个产品的官网</li><li>github或者gitee</li><li>我不知道了</li></ol><p>假设我们成功的找到的某个产品的驱动源代码,我们只需要导入我们的<code>linux发行版</code>进行编译安装</p><h1>编译安装</h1><p>例如我成功在<code>INTEL</code>官网下载了<code>e1000e-3.8.7.tar.gz</code>源码包</p><ul><li>解压源码包</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf e1000e-<span class="number">3</span>.<span class="number">8</span>.<span class="number">7</span>.tar.gz</span><br></pre></td></tr></table></figure><ul><li>查看README</li></ul><p>每个产品都会有类似的<code>README</code>文档来指导你如何使用,例如有如下2种方式,第一种就是让我们用<code>rpmbuild</code>来自己生成一个<code>rpm</code>包,第二种会让我生成一个<code>ko</code>文件,然后安装到内核里面去,然后我们再去使用<code>lspci</code>查看驱动的办法来验证是否记载驱动就可以了</p><ol><li><code>rpmbuild -tb e1000e-&lt;x.x.x&gt;.tar.gz</code></li><li>手动编译<ol><li>查看具体步骤,是否要先./configure</li><li>make编译</li><li>insmod xx.ko 手动加载驱动</li><li>使用lspci -nvs 01:00.0这种来看设备的驱动是否加载</li><li>如果加载成功就make install</li></ol></li></ol><blockquote><ol><li>makera,centos这些系统有的命令</li><li>make,gcc,g++这种命令属于开发工具,如果系统没有的话需要自己安装</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之strace</title>
      <link href="/posts/dd9530c1.html"/>
      <url>/posts/dd9530c1.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>strace是用来诊断,调试的linux用户空间跟踪器,来监视用户空间进程和内核交互,比如系统调用,信号传递,进程状态变更</p><h1>示例</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -tt -T -v -f -e [close|openat|execve] -o log  ./ceshi.sh -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><h1>常用选项</h1><ul><li>-tt : 显示毫秒级别</li><li>-T : 显示每次系统调用所消耗的时间</li><li>-v : 对于某些相关的调用,展示完整的环境变量,文件stat结构</li><li>-f : 跟踪目标进程以及目标进程创建的子进程</li><li>-e : 控制要跟踪的时间和跟踪行为,比如指定要跟踪的系统调用名称</li><li>-o : 把strace输出单独写到文件</li><li>-s : 系统调用某个参数是字符串的四行,最多输出指定长度的内容,默认32字节</li><li>-p : 指定要跟踪的进程pid 多个pid写多个-p</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统资源异常处理思路</title>
      <link href="/posts/e853bb7.html"/>
      <url>/posts/e853bb7.html</url>
      
        <content type="html"><![CDATA[<h1>常见资源问题</h1><ol><li>系统操作卡顿</li><li>cpu,内存资源占用过高</li><li>进程占用资源高</li><li>系统异常重启或宕机</li><li>开机时间长</li></ol><h1>资源异常处理思路</h1><h2 id="日志分析">日志分析</h2><ul><li>dmesg</li><li>/var/log/*</li><li>串口调试</li><li>~/.xsession-errors</li></ul><h2 id="卡顿分析">卡顿分析</h2><ul><li>本地卡顿还是远程卡顿</li></ul><h2 id="异常进程">异常进程</h2><ul><li>strace进程跟踪</li><li>pstack进程跟踪</li><li>jstack进程跟踪(针对java)</li></ul><h2 id="更换用户测试">更换用户测试</h2><ul><li>切换用户没有问题则考虑~/.conf  ~/.cache 环境变量</li></ul><h2 id="是否和显卡有关系">是否和显卡有关系</h2><ul><li>是否有硬件加速</li><li>更换硬件</li><li>xdriinfo或Xorg.0.log日志分析</li></ul><h2 id="内核或驱动">内核或驱动</h2><ul><li>升级驱动(<a href="http://kernel.org">kernel.org</a>)</li><li>升级内核</li></ul><h2 id="core文件">core文件</h2><ul><li>tmp目录下是否有core,或者第三方程序下是否有</li><li>gdb调试</li></ul><h2 id="是否与桌面图形相关">是否与桌面图形相关</h2><ul><li>top看图形进程占用</li><li>关闭图形是否临时解决</li><li>lightdm/gdm服务状态</li></ul><h1>linux性能分析工具</h1><h2 id="cpu">cpu</h2><ul><li>top :  显示系统和进程cpu,内存关系</li><li>uptime :  系统平均负载</li><li>vmstat :  报告和采样内存,io,cpu信息</li><li>procinfo :  cpu和中断信息</li><li>mpstat :  分析cpu</li><li>sar :  分析cpu</li><li>oprofile :  分析系统,进程的消耗</li><li>perf :  分析cpu调用路径和消耗</li><li>time :  进程cpu使用信息</li><li>strace :  系统调用信息</li><li>lstrace :  库函数调用信息和耗时</li><li>ps :  对特定进程分析</li><li>pidstat :  分析进程对cpu的占用</li></ul><h2 id="内存">内存</h2><ul><li>vmstat :  分析内存,io,cpu</li><li>free :  展示系统和进程cpu,内存,使用情况</li><li>slabtop :  内核缓存分配和使用情况</li><li>sar -r :  内存信息</li><li>/proc/memoryinfo :  内存信息</li><li>ps  :  进程和内存关系</li><li>/proc/<pid>/mem :  进程内存信息</li><li>memprof :  图形化内存分析</li><li>kcachegnnd :  图形化内存分析</li><li>/proc/iomem :  物理地址分配信息</li><li>pmap :  进程内存映射信息</li></ul><h2 id="磁盘">磁盘</h2><ul><li>iostat :  统计设备和分区磁盘IO信息</li><li>iotop :  列出进程磁盘IO信息</li><li>sar -d :  报告磁盘IO相关信息</li><li>blktrace :  跟踪磁盘IO时间</li><li>lsof :  列出进程打开文件,目录信息</li><li>pidstat -d  :  进程磁盘io统计信息</li><li>dd :  测速</li><li>dstat :  全能的系统信息统计工具</li><li>fio :  测速</li><li>mount :  挂载</li><li>badblocks :  检查磁盘损坏的区块</li></ul><h2 id="网络">网络</h2><ul><li>nmcli :  网络配置工具</li><li>ifconfig :  网络接口和统计</li><li>iperf :  流量检测</li><li>tcpdump :  抓包</li><li>wireshark :  图形化抓包</li><li>ss :  套接字分析</li><li>netstat :  统计网络协议和接口信息</li><li>ethtool :  统计以太网设备信息</li><li>ping :  万能的ping检测</li><li>tracerout :  跟踪路由</li><li>route :  显示路由</li></ul><h1>进程分析</h1><h2 id="进程的相关知识">进程的相关知识</h2><h2 id="进程含义">进程含义</h2><ul><li><p>运行中的程序副本(指令加数据)</p></li><li><p>理想状态下是70%CPU时间用户模式+30%CPU时间内核模式.</p></li><li><p>进程需要内存来存放自己的指令和代码，需要cpu来运行指令并完成对数据的加工，此然也需要内存把自己所输出的数据及处理的结果给保存下来等等。事实上我们运行中的进程数量是远远多余cpu核心数量的</p></li><li><p>假如只有1个cpu,他要么在执行用户代码,要么执行内核代码,不能同时执行2个</p></li><li><p>内核为了追踪每个进程,必须实现每一个进程可随时调入和调出,准备很多数据结构来保存这些数据,这个过程即为<code>任务列表</code>,每个进程都有一个task,每一个task在内核中都有一个专门的数据格式来存放相关信息,包括进程id,进程的线程,在调度上进程和线程没有区别</p></li><li><p>io过程,进程运行的过程中,需要请求的数据如果不在内存里面,就会请求内核吧数据从磁盘载入内存,从而供程序访问,io就被分成了2段,第一段是内核将磁盘数据加载到内核内存,然后再从内核内存复制到进程内存</p></li></ul><h2 id="常用命令">常用命令</h2><ul><li>大致看进程使用全部内存,包括共享内存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | awk &#x27;&#123;total +=$6&#125;END&#123;print total&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>大致看进程易用内存,比aux精确</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep Pss /proc/[1-9]*/smaps | awk &#x27;&#123;total+=$2&#125;END&#123;print total&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>cpu占用最高的10个进程,以pid排序</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k3nr | head -n 10</span><br></pre></td></tr></table></figure><ul><li>内存占用最高的10个进程,以pid排序</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k4nr | head -n 10</span><br></pre></td></tr></table></figure><ul><li>树形看进程,但不能看内核进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -axjf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree</span><br></pre></td></tr></table></figure><ul><li>查看进程下的所有线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -efL | grep &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>查看进程下有哪些线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -T -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>top/htop<ul><li>top -Hp [pid]</li><li>top 然后按P或M</li><li>top 然后按F</li></ul></li><li>vmstat n m</li><li>mpstat nm</li><li>sar工具</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -u -h -f /var/log/saxxx</span><br></pre></td></tr></table></figure><ul><li>指定命令固定在某个cpu上</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -c 3 top</span><br></pre></td></tr></table></figure><ul><li>显示进程是否固定在某个cpu上</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">taskset -c -p &lt;pid&gt;</span><br><span class="line">ps -o pid,psr,comm -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><h1>java进程占用问题思路</h1><ul><li>找出占用最高的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top 按M</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k3nr | awk &#x27;&#123;print $3 &quot;\t&quot; $11&#125;&#x27; | head -n 10</span><br></pre></td></tr></table></figure><ul><li>找出进程占用最高的线程ID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top  -Hp &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>找出cpu占用最高的线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -mp 2688 -o &quot;THREAD,tid,time&quot;</span><br></pre></td></tr></table></figure><ul><li>十进制线程号转换成十六进制线程号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%x\n&quot; &lt;tid&gt;</span><br></pre></td></tr></table></figure><ul><li>jstack找出问题代码</li></ul><p>tid(16进制西那才ID小写英文)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstack -l &lt;pid&gt;</span><br><span class="line">jstack -f &lt;pid&gt;</span><br><span class="line">jstack -l &lt;pid&gt; | grep tid -A 30</span><br></pre></td></tr></table></figure><blockquote><p>如果是java代码问题,应该找研发</p><p>如果是java虚拟机或者系统问题,应该继续查</p></blockquote><h1>其他进程占用cpu问题思路</h1><h2 id="top大法">top大法</h2><h3 id="用户态">用户态</h3><p>%us+%sy &gt; 70 ,用户态是否有可疑进程</p><h3 id="中断">中断</h3><ul><li>硬中断 hi</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -d cat <span class="regexp">/proc/i</span>nterrupts</span><br></pre></td></tr></table></figure><ul><li>软中断 si</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">watch</span> -n <span class="number">1</span> <span class="string">&quot;cat /proc/softirqs&quot;</span></span><br></pre></td></tr></table></figure><h3 id="灵异进程">灵异进程</h3><p>cpu占用很高但找不到</p><ul><li>关注<code>running</code>进程,是否有什么在不停的重启</li><li>关注<code>D</code>状态进程,不可中断的睡眠状态,该状态的进程无法kill,更不能自行退出,只能重启或恢复他依赖的资源来解决</li></ul><h2 id="uptime或w">uptime或w</h2><p>load average 越高,说明任务队列越长,处于等待的任务越多</p><h2 id="vmstat">vmstat</h2><ul><li>cs  上下文切换次数陡增或者和正常差别很大</li><li>in  中断次数较多</li><li>r  就绪队列长度一直高于最大cpu个数,考虑cpu竞争</li><li>wa  op等待cpu时间,值越大,磁盘大量做随机访问造成的,磁盘性能有瓶颈</li></ul><h2 id="pidstat">pidstat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -p &lt;pid&gt; -wt 1 10</span><br></pre></td></tr></table></figure><ul><li>Cswch/s 每秒主动任务上下文切换数量</li><li>Nvcswch/s 每秒被动任务上下文切换数量,值越大活吗进程被强制调度,就是争抢cpu,cpu时间片不足</li></ul><h2 id="sar">sar</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -q #查看近段时间cpu负载</span><br></pre></td></tr></table></figure><h2 id="判断是否是系统进程">判断是否是系统进程</h2><ul><li>U系</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S</span><br></pre></td></tr></table></figure><ul><li>R系</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf</span><br></pre></td></tr></table></figure><h2 id="显卡相关">显卡相关</h2><p>涉及到显卡硬件加速相关,有些应用可能需要用到,但可能走的是cpu软实现,并没有用到硬件</p><h2 id="是否程序不断自启动">是否程序不断自启动</h2><p>有些程序利用定时任务不断拉起服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rni &quot;进程&quot; /etc</span><br></pre></td></tr></table></figure><h2 id="对比其他机器">对比其他机器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -c top -d 1 -n 5</span><br></pre></td></tr></table></figure><h1>内存分析</h1><p>linux内存管理子系统架构<code>用户空间</code>,<code>内核空间</code>,<code>机器硬件</code></p><h2 id="查看配置">查看配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure><p>关注如下</p><ol><li>MemTotal 物理大小</li><li>MemFree 空闲</li><li>MemAvailabe 可用</li><li>Buffers 给文件做缓冲的</li><li>Cached 高速缓冲控制器</li><li>SwapCacaed</li><li>Active 活跃使用的bufferf或cache</li><li>Inactive 不经常用的大小</li><li>Slab</li><li>Sreclaimable  可回收slab</li><li>Sunreclaim 不可回收slab</li></ol><h2 id="检查现有的">检查现有的</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><p>应用可用内存~free+buffers+cached</p><p>Mem:avaiable~/proc/meminfo的MenAvailable</p><h1>smem</h1><ul><li>VSS</li></ul><p>虚拟耗用内存,包含共享库使用的内存</p><ul><li>RSS</li></ul><p>实际使用内存,包含共享库占用的,用top可以查到,最常用的内存指标,是进程占用的物理内存大小,Rss包含进程间共享的内存,所以累加起来会超出系统的内存消耗</p><ul><li>PSS</li></ul><p>所有使用某共享库的程序均分该共享库占用的内存时,每个进程占用的内存,所有进程的PSS之和就是系统的内存使用量,更精确,是将共享内存平均分摊到各个进程中的</p><ul><li>USS</li></ul><p>进程独自占用的物理内存,是PSS中自己的部分,只计算进程独自占用的</p><h2 id="常用命令-2">常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure><ul><li>实时显示内核slab缓冲区信息</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">slabtop</span></span><br></pre></td></tr></table></figure><ul><li>是否有内存限制或预留内存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cmdline</span><br></pre></td></tr></table></figure><ul><li>查看进程总内存是否正常</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | awk &#x27;&#123;total+=$6&#125;END&#123;print total/1024&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>日志分析超出内存或alloc的问题</li></ul><ol><li>dmesg</li><li>kernel.log</li><li>syslog</li></ol><ul><li>近段时间内存分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -r -h -f /var/log/sa/saxx</span><br></pre></td></tr></table></figure><ul><li>串口调试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启,引导加入console=ttyS0,115200n8</span></span><br></pre></td></tr></table></figure><h2 id="对比测试">对比测试</h2><ol><li>和centos对比</li><li>重新部署程序或和正常机器对比</li><li>换个用户排除环境变量问题</li><li>异常和正常的机器硬件,系统,bios,主板,硬盘,cpu,内存,包,是否一致</li><li>内存泄露问题,meminfo取多份对比,看看是在内核还是用户进程</li></ol><h2 id="核内内存问题">核内内存问题</h2><ol><li>MemFree和MemAvailable,定位内存消耗的方向是内核还是用户</li><li>slabtop实时观察哪个slab一直增高</li><li>对比看slab增长情况</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo  | grep -Ei &quot;slab|reclaim&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>定位具体的slab问题</li></ol><p>取多份slabinfo对比,带着/sys/kernel/slab分析</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>slabinfo</span><br></pre></td></tr></table></figure><p>如果dentry高,判断下是否进程对文件频繁读写,可以用strace分析</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -fp &lt;pid&gt; -e trace=<span class="keyword">open</span>,<span class="keyword">stat</span>,<span class="keyword">close</span>,<span class="keyword">unlink</span></span><br></pre></td></tr></table></figure><ol start="5"><li>内核问题一般是驱动问题<ol><li>lsmod对比</li><li>卸载驱动</li><li>驱动分析</li></ol></li><li>找到驱动地址</li></ol><p>可以看到函数对应的地址,通过地址找到驱动,也可以通过驱动找到地址</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/i</span>omem</span><br></pre></td></tr></table></figure><h2 id="核外内存问题">核外内存问题</h2><ol><li><p>top按M查看占用最大的</p></li><li><p>ps大法</p></li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ps</span> -aux | awk <span class="string">&#x27;&#123;total+=<span class="variable">$6</span>&#125;END&#123;print total/1024&#125;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux --<span class="built_in">sort</span> -rss | <span class="built_in">head</span></span><br></pre></td></tr></table></figure><ol start="3"><li>ps_mem</li><li>dstat</li></ol><p>动态展示进程内存占用</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat <span class="comment">--top-mem</span></span><br></pre></td></tr></table></figure><ol start="5"><li>进程内存分析</li></ol><ul><li>查看smaps</li></ul><p>smaps展示了一个进程的内存消耗</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/&lt;pid&gt;/smaps</span><br></pre></td></tr></table></figure><ul><li>内存泄露</li></ul><p>VIRT/VSZ或者writeable/private,如果在重复操作中一直问题,那么应该是内存泄露</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pmap -d &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>strace调试</li></ul><h2 id="pid是否超过限度">pid是否超过限度</h2><p><code>fork:cannot allocate memory</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | wc -l</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat  /proc/sys/kernel/pid_max</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysc &amp;&amp; echo3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><p>linux下频繁存取文件之后,物理内存会被消耗完,程序结束之后不会立即被正常释放的</p><h1>磁盘问题</h1><ul><li>磁盘整体使用情况</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -i</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/fstab</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid</span><br></pre></td></tr></table></figure><ul><li>是否开启读写缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cache</span><br></pre></td></tr></table></figure><ul><li>查看队列模式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/block/&lt;磁盘名&gt;/queue/scheduler </span><br></pre></td></tr></table></figure><ul><li>设置队列模式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &lt;队列模式&gt; &gt;&gt;  /sys/block/&lt;磁盘名&gt;/queue/scheduler </span><br><span class="line">echo  mq-deadline &gt;&gt;  /sys/block/&lt;磁盘名&gt;/queue/scheduler </span><br></pre></td></tr></table></figure><p>grub加入scsi_mod.use_blk_mq=0 elevator=deadline 修改算法</p><ul><li>查看磁盘调度算法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i scheduler</span><br></pre></td></tr></table></figure><ul><li>查看io</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x -N -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat -d</span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat -d <span class="comment">--top-io</span></span><br></pre></td></tr></table></figure><ul><li>io性能测试</li></ul><ol><li>blktrace</li><li>fio</li><li>dd</li></ol><ul><li>检测磁盘健康</li></ul><ol><li>badblocks</li><li>e2fsck</li><li>fsck</li><li>xfs_repair</li></ol><ul><li>判断磁盘类型</li></ul><p>1=HDD</p><p>0=SSD</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/sys/</span>block<span class="regexp">/&lt;磁盘名&gt;/</span>queue/rotational  </span><br></pre></td></tr></table></figure><ul><li>是否开启缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cache | grep -i read #读缓存</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cache | grep -i write #读缓存</span><br></pre></td></tr></table></figure><h2 id="磁盘分析工具">磁盘分析工具</h2><h3 id="dd">dd</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试写速率,请求直接变成io指令发到磁盘</span></span><br><span class="line">time dd if=/dev/zero of=test bs=4k count=100000 oflag=direct status=progress</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试写速率,规避cache</span></span><br><span class="line">time dd if=test  of=/dev/null bs=4k count=100000 oflag=direct status=progress</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试读速率,规避cache</span></span><br><span class="line">time dd if=/dev/xxx  of=/dev/null bs=4k count=100000 oflag=direct status=progress</span><br></pre></td></tr></table></figure><h3 id="blktrace">blktrace</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.采集信息,根据cpu个数生成文件个数,名字是&#123;device&#125;.blktrace.&#123;cpu&#125;</span></span><br><span class="line">blktrace -d /dev/sdX  [-o /tmp/sda ]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.合并信息,执行btt就要先把blktrace生成的文件合并</span></span><br><span class="line">blkparse -i sda -d sda.blkparse.bin</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.统计信息,将合并的信息分解程很多歌名字相关的文件信息</span></span><br><span class="line">btt -i sda.blkparse.bin -o sda.btt</span><br></pre></td></tr></table></figure><h2 id="磁盘检查修复工具">磁盘检查修复工具</h2><h3 id="badblocks">badblocks</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.扫描</span></span><br><span class="line">badblocks -s -v /dev/xxx</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.如果找到了坏道,可以进行写入扫描进行修复,写入扫描遇到坏道的时候自动重映射,扫描会覆盖原有数据,要备份的,写入扫描速度很低,所以应该扫描只读扫描时候发现错误的地方</span></span><br><span class="line">badblocks -w -s -v /dev/xxx [END] [START]</span><br></pre></td></tr></table></figure><h3 id="fstrim">fstrim</h3><p>回收已经挂载的文件系统未使用的块</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fstrim -av</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之pidstat</title>
      <link href="/posts/33b1a077.html"/>
      <url>/posts/33b1a077.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之iostat</title>
      <link href="/posts/84a73f90.html"/>
      <url>/posts/84a73f90.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>分析io性能</p><h1>概述</h1><p>在衡量磁盘性能时的基本指标：<code>利用率</code>、<code>饱和度</code>、<code>IOPS</code>、<code>吞吐量</code>和<code>响应时间</code></p><ol><li>利用率(Utilization):磁盘处理I/O的时间百分比,过度使用<code>(如超过 80%)</code>通常意味着磁盘I/O存在性能瓶颈</li><li>饱和度(Saturation):指磁盘处理I/O的繁忙程度,过度饱和意味着磁盘存在严重的性能瓶颈,当饱和度为100%时,磁盘无法接受新的I/O请求</li><li>IOPS(Input/Output Per Second):指每秒I/O请求的数量</li><li>吞吐量(Throughput):每秒I/O请求的大小</li><li>响应时间(Response time):指发送I/O请求和接收响应之间的间隔时间</li></ol><blockquote><p>一般面对IO问题,我们先考虑<code>是否产生了IO问题</code>,在安装系统之后一般都是要对磁盘进行一个测试的,常用的工具有<code>dd</code>,<code>fio</code>等,目的是要检验出磁盘的<code>随机读</code>、<code>顺序读</code>、<code>随机写</code>、<code>顺序写</code><br>等性能(通常是 512B ~ 1MB 之间),以判断是否能够满足应用的需求</p></blockquote><h1>命令参数</h1><p><strong>-c：</strong> 显示CPU使用情况<br><strong>-d：</strong> 显示磁盘使用情况<br><strong>-N：</strong> 显示磁盘阵列(LVM) 信息<br><strong>-n：</strong> 显示NFS 使用情况<br><strong>-k：</strong> 以 KB 为单位显示<br><strong>-m：</strong> 以 M 为单位显示<br><strong>-t：</strong> 报告每秒向终端读取和写入的字符数和CPU的信息<br><strong>-V：</strong> 显示版本信息<br><strong>-x：</strong> 显示详细信息<br><strong>-p：</strong>[磁盘] 显示磁盘和分区的情况</p><h1>多种用法简介</h1><ul><li>间隔1秒，总共显示5次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat 1 5</span><br></pre></td></tr></table></figure><ul><li>每隔2秒,显示一次设备统计信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d 2</span><br></pre></td></tr></table></figure><ul><li>每隔2秒,显示一次设备统计信息.总共输出3次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d 2 3</span><br></pre></td></tr></table></figure><ul><li>每隔2秒显示一次sda, sdb两个设备的扩展统计信息,共输出3次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x sda sdb 2 3</span><br></pre></td></tr></table></figure><ul><li>每隔2秒显示一次sda及上面所有分区的统计信息,共输出3次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -p sda 2 3</span><br></pre></td></tr></table></figure><ul><li>以M为单位显示所有信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -m</span><br></pre></td></tr></table></figure><ul><li>报告每秒向终端读取和写入的字符数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -t</span><br></pre></td></tr></table></figure><ul><li>显示指定硬盘信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d sda</span><br></pre></td></tr></table></figure><ul><li>查看TPS和吞吐量信息</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">iostat</span> -d -k <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>查看设备使用率和响应时间</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">iostat</span> -d -k <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h1>简单使用方法</h1><p>直接使用,显示所有设备负载情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat</span><br></pre></td></tr></table></figure><p>下面是输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.30    0.00    0.07    0.01    0.00   99.62</span><br><span class="line"></span><br><span class="line">Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd</span><br><span class="line">dm-0              3.40        67.65         6.81         0.00     492797      49628          0</span><br><span class="line">dm-1              0.01         0.30         0.00         0.00       2216          0          0</span><br><span class="line">sda               1.89        84.39         6.52         0.00     614737      47473          0</span><br><span class="line">sdb               0.02         0.35         0.00         0.00       2569          4          0</span><br></pre></td></tr></table></figure><ul><li>含义解释</li></ul><ol><li>%user：CPU在<code>用户模式</code>下的时间百分比</li><li>%nice：CPU在带NICE值的用户模式下的时间百分比</li><li>%system：CPU在系统模式下的时间百分比</li><li>%iowait：CPU等待输入输出完成时间的百分比</li><li>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比</li><li>%idle：CPU<code>空闲时间</code>百分比</li><li>device:磁盘名称</li><li>tps：每秒钟发送到的I/O请求数</li><li>Blk_read/s：每秒读取的block数</li><li>Blk_wrtn/s：每秒写入的block数</li><li>Blk_read：读入的block总数</li><li>Blk_wrtn：写入的block总数</li></ol><blockquote><p>%iowait的值过高，表示硬盘存在I/O瓶颈<br>%idle值高，表示CPU较空闲<br>%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量<br>%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。</p></blockquote><h1>整体磁盘I/O观察(重点)</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x -N -p</span><br></pre></td></tr></table></figure><p>iostat 是最常用的磁盘 I/O 性能观察工具。它提供了各种常用性能指标，例如每个磁盘的利用率、IOPS 和吞吐量<br>下面是<code>iostat</code>的输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">scd0              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">dm-0              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">dm-1              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br></pre></td></tr></table></figure><p>每一列都对应了之前说的<code>基本指标</code></p><ul><li><code>%util</code> 是我们前面提到的磁盘I/O使用情况,</li><li><code>r/s</code> 和 <code>w/s</code> 是 IOPS</li><li><code>rkB/s</code> 和 <code>wkB/s</code> 是吞吐量</li><li><code>r_await</code> 和 <code>w_await</code> 是响应时间</li></ul><blockquote><p>关于磁盘饱和度,可以利用<code>平均请求队列长度</code>或<code>完成读写请求的等待时间</code>与<code>基准测试（例如通过 fio）的结果</code>进行比较</p><p>从iostat无法得出磁盘的饱和度,饱和度反应的是磁盘处理io的繁忙程度,过高的饱意味着磁盘有严重的io问题,饱和度100%时候无法接受新的io请求</p></blockquote><h1>查看设备使用率,响应时间</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x 1 1</span><br></pre></td></tr></table></figure><p>以下是输出结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Device</span>            r/s     rkB/s   rrqm/s  %rrqm r_await rareq-sz     w/s     wkB/s   wrqm/s  %wrqm w_await wareq-sz     d/s     dkB/s   drqm/s  %drqm d_await dareq-sz     f/s f_await  aqu-sz  %util</span><br><span class="line"><span class="attribute">dm</span>-<span class="number">0</span>             <span class="number">1</span>.<span class="number">70</span>     <span class="number">67</span>.<span class="number">07</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">2</span>.<span class="number">90</span>    <span class="number">39</span>.<span class="number">45</span>    <span class="number">1</span>.<span class="number">68</span>      <span class="number">6</span>.<span class="number">80</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">38</span>     <span class="number">4</span>.<span class="number">04</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">01</span>   <span class="number">0</span>.<span class="number">11</span></span><br><span class="line"><span class="attribute">dm</span>-<span class="number">1</span>             <span class="number">0</span>.<span class="number">01</span>      <span class="number">0</span>.<span class="number">30</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">2</span>.<span class="number">32</span>    <span class="number">22</span>.<span class="number">85</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span></span><br><span class="line"><span class="attribute">sda</span>              <span class="number">1</span>.<span class="number">10</span>     <span class="number">83</span>.<span class="number">67</span>     <span class="number">0</span>.<span class="number">82</span>  <span class="number">42</span>.<span class="number">71</span>    <span class="number">2</span>.<span class="number">38</span>    <span class="number">76</span>.<span class="number">10</span>    <span class="number">0</span>.<span class="number">78</span>      <span class="number">6</span>.<span class="number">50</span>     <span class="number">0</span>.<span class="number">91</span>  <span class="number">53</span>.<span class="number">78</span>    <span class="number">0</span>.<span class="number">66</span>     <span class="number">8</span>.<span class="number">34</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">15</span>    <span class="number">1</span>.<span class="number">66</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">11</span></span><br><span class="line"><span class="attribute">sdb</span>              <span class="number">0</span>.<span class="number">02</span>      <span class="number">0</span>.<span class="number">35</span>     <span class="number">0</span>.<span class="number">02</span>  <span class="number">43</span>.<span class="number">12</span>   <span class="number">15</span>.<span class="number">22</span>    <span class="number">16</span>.<span class="number">79</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">8</span>.<span class="number">75</span>     <span class="number">1</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">8</span>.<span class="number">75</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">03</span></span><br></pre></td></tr></table></figure><ol><li><strong>rrqm/s:</strong>  每秒进行 merge 的读操作数目。即 rmerge/s</li><li><strong>wrqm/s:</strong>  每秒进行 merge 的写操作数目。即 wmerge/s</li><li><strong>r/s:</strong>  每秒完成的读 I/O 设备次数。即 rio/s</li><li><strong>w/s:</strong>  每秒完成的写 I/O 设备次数。即 wio/s</li><li><strong>rkB/s:</strong>  每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</li><li><strong>wkB/s:</strong>  每秒写K字节数。是 wsect/s 的一半。</li><li><strong>avgrq-sz:</strong>  平均每次设备I/O操作的数据大小 (扇区)。</li><li><strong>avgqu-sz:</strong>  平均I/O队列长度。</li><li><strong>rsec/s:</strong>  每秒读扇区数。即 rsect/s</li><li><strong>wsec/s:</strong>  每秒写扇区数。即 wsect/s</li><li>**r_await:**每个读操作平均所需的时间</li><li>不仅包括硬盘设备读操作的时间，还包括了在kernel队列中等待的时间。</li><li>**w_await:**每个写操作平均所需的时间</li><li>不仅包括硬盘设备写操作的时间，还包括了在kernel队列中等待的时间。</li><li><strong>await:</strong> 平均每次设备I/O操作的等待时间 (毫秒)。</li><li><strong>svctm:</strong> 平均每次设备I/O操作的服务时间 (毫秒)。</li><li><strong>%util:</strong>  一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</li></ol><blockquote><p>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。</p><p>如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间</p><p>如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化</p><p>如果avgqu-sz比较大，也表示有当量io在等待。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件描述符和进程数调优</title>
      <link href="/posts/b379b34f.html"/>
      <url>/posts/b379b34f.html</url>
      
        <content type="html"><![CDATA[<h1>问题描述</h1><ul><li><p>文件描述符</p><p><code>Too many open files</code>是Linux系统中常见的错误,从字面意思上看就是说程序打开的文件数过多,其实files不单是文件的意思,也包括打开的通讯链接(比如socket),正在监听的端口等等,也可以叫做句柄(handle),这个错误通常也可以叫做<code>句柄数超出系统限制</code></p></li><li><p>用户打开进程数</p><p><code>no more progres</code>或者是<code>Resource temporarily unavailable</code>,是没有更多的进程可用,产生的原因可能有</p><ol><li>用户的nproc达到限制，无法创建新的进程</li><li>系统没有可分配的的pid，即进程号已经达到内核参数kernel.pid_max的限制</li><li>系统可用内存低，新的进程无法申请到内存导致不能启动</li></ol><p>nproc是操作系统级别对每个用户创建的进程数的限制,在Linux下运行多线程时,每个线程的实现其实是一个轻量级的进程,对应的术语是:light weight process(LWP)</p></li></ul><h1>产生的原因</h1><p>Linux操作系统中利用<code>ulimit</code>限制shell启动进程占用的资源,ulimit支持对用户的<code>打开进程数</code>、<code>进程打开文件句柄数</code>、<code>进程打开文件的大小</code>、进程coredump文件`大小等资源进行限制，从而防止某个用户进程过度占用系统资源，避免影响整个操作系统和其他应用的正常运行。但是使用ulimit进行限制后，当用户资源超限制时会出现各种各样的报错</p><h1>文件描述符达到上限</h1><h2 id="修改上限file-max">修改上限file-max</h2><p>这是<code>系统级</code>参数,file-max是查看所有进程的打开文件数量的系统范围限制,即系统可打开的最大数量,但日志里面报&quot;file-max reached&quot;的时候才去修改</p><ul><li>查看file-max数值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max  </span><br></pre></td></tr></table></figure><p>file-max的值也也和下面有近似</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r MemTotal /proc/meminfo | awk &#x27;&#123;printf(&quot;%d&quot;,$2/10)&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="修改方法">修改方法</h3><ul><li>写入sysctl.conf</li></ul><p>重启生效,建议先用临时设定确定一个值之后写入配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;fs.file-max = 6553560&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><p>重启恢复默认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo  6553560 &gt; /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w &quot;fs.file-max=6553560&quot;</span><br></pre></td></tr></table></figure><h2 id="修改nr-open">修改nr_open</h2><p>这是<code>进程级</code>的参数,查看单个进程可以打开的最大文件数</p><ul><li>查看</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/nr_open   #输出1048576即是1024*1024,正好是100万</span><br></pre></td></tr></table></figure><h3 id="修改方法-2">修改方法</h3><ul><li>写入sysctl.conf</li></ul><p>重启生效,建议先用临时设定确定一个值之后写入配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;fs.nr_open=100000000&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><p>,重启恢复默认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo  100000000 &gt; /proc/sys/fs/nr_open</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><p>重启恢复默认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w &quot;fs.nr_open=100000000&quot;</span><br></pre></td></tr></table></figure><h2 id="查看file-nr">查看file-nr</h2><p>他其实就是一个统计,输出<code>当前打开的文件数</code>,<code>空闲文件句柄数量</code>,<code>文件句柄的最大数量(file-max)</code>三列值,这是一个只读文件,是拿来看资源的,不用修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-nr   #输出55040195620</span><br></pre></td></tr></table></figure><h2 id="修改limits-conf">修改limits.conf</h2><p>既可以用<code>ulimit命令</code>来修改,也可以<code>写进系统的配置文件</code></p><blockquote><p>注意</p><ol><li><p>nofile是打开最大文件数, 对应limits.conf的nofile参数,重启生效</p></li><li><p>soft要小于hard</p></li><li><p>nofile的值需要小于等于nr_open的值</p></li></ol></blockquote><ul><li>修改成如下</li></ul><p>将所有用户的对<code>文件描述符</code>的限制都改成6553500</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 6553500</span><br><span class="line">* hard nofile 6553500</span><br></pre></td></tr></table></figure><h2 id="分析系统">分析系统</h2><p>其实<code>调优</code>只是释放资源的一种手段,更重要的是找出原因,可能是业务某个时间段业务量激增,也可能是应用触发了某个bug</p><ul><li>统计各命令打开句柄数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure><ul><li>统计各进程打开句柄数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &#x27;&#123;print $2&#125;&#x27; | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure><ul><li>统计各用户打开句柄数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &#x27;&#123;print $3&#125;&#x27; | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure><h2 id="复现方法">复现方法</h2><p>将我们的资源临时改成<code>6</code>,此时类似<code>top</code>或者<code>lsof</code>等命令就已经不能用了,因为他们产生的句柄会很多,而我们只限制只能打开<code>6</code></p><ul><li>临时修改nofile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 6</span><br></pre></td></tr></table></figure><ul><li>随便输入某些命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><ul><li>触发报错</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span>: failed <span class="attribute">openproc</span>: Too many open files</span><br></pre></td></tr></table></figure><h1>用户最大进程数量达到上限</h1><p>在rhel6和7上面,这个参数默认对root没有限制,他是从内核继承的,对于其他用户来说就4096,是根据下面的文件设定的</p><ul><li>CentOS6中limits.d下面是90-nproc.conf</li><li>CentOS7中limits.d下面是20-nproc.conf</li></ul><h2 id="如何查看">如何查看</h2><ul><li>查看所有用户创建的进程数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps h -Led -o user | sort | uniq -c | sort -n</span><br></pre></td></tr></table></figure><ul><li>指定某个用户查看创建的进程数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o nlwp,pid,lwp,args -u root | sort -n</span><br></pre></td></tr></table></figure><h2 id="修改xx-nproc-conf文件">修改xx-nproc.conf文件</h2><p>将第一行的nproc的值放大,我一般是改成4096,如果还不够继续放大</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*          soft    nproc     1024</span><br><span class="line">root       soft    nproc     unlimite</span><br></pre></td></tr></table></figure><h2 id="如何生效">如何生效</h2><p>有2种方法如下,任选其中之一</p><ul><li>本地注销桌面或者退出终端重新登陆</li><li>重启最好</li></ul><h2 id="验证结果">验证结果</h2><h3 id="对于bash用户">对于bash用户</h3><ul><li>查看方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><p>修改的是<code>nproc</code>参数,对应<code>max user processes</code>字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">real-time non-blocking time  (microseconds, -R) unlimited</span><br><span class="line">core file size              (blocks, -c) unlimited</span><br><span class="line">data seg size               (kbytes, -d) unlimited</span><br><span class="line">scheduling priority                 (-e) 0</span><br><span class="line">file size                   (blocks, -f) unlimited</span><br><span class="line">pending signals                     (-i) 61604</span><br><span class="line">max locked memory           (kbytes, -l) 64</span><br><span class="line">max memory size             (kbytes, -m) unlimited</span><br><span class="line">open files                          (-n) 65535</span><br><span class="line">pipe size                (512 bytes, -p) 8</span><br><span class="line">POSIX message queues         (bytes, -q) 819200</span><br><span class="line">real-time priority                  (-r) 0</span><br><span class="line">stack size                  (kbytes, -s) 8192</span><br><span class="line">cpu time                   (seconds, -t) unlimited</span><br><span class="line">max user processes                  (-u) 61604</span><br><span class="line">virtual memory              (kbytes, -v) unlimited</span><br><span class="line">file locks                          (-x) unlimited</span><br></pre></td></tr></table></figure><h3 id="对于tcsh用户">对于tcsh用户</h3><ul><li>查看方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><p>修改的是<code>nproc</code>参数,对应<code>maxproc</code>字段</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cputime</span>      unlimited</span><br><span class="line"><span class="attribute">filesize</span>     unlimited</span><br><span class="line"><span class="attribute">datasize</span>     unlimited</span><br><span class="line"><span class="attribute">stacksize</span>    <span class="number">8192</span> kbytes</span><br><span class="line"><span class="attribute">coredumpsize</span> unlimited</span><br><span class="line"><span class="attribute">memoryuse</span>    unlimited</span><br><span class="line"><span class="attribute">vmemoryuse</span>   unlimited</span><br><span class="line"><span class="attribute">descriptors</span>  <span class="number">65535</span> </span><br><span class="line"><span class="attribute">memorylocked</span> <span class="number">64</span> kbytes</span><br><span class="line"><span class="attribute">maxproc</span>      <span class="number">61604</span> </span><br><span class="line"><span class="attribute">maxlocks</span>     unlimited</span><br><span class="line"><span class="attribute">maxsignal</span>    <span class="number">61604</span> </span><br><span class="line"><span class="attribute">maxmessage</span>   <span class="number">819200</span> </span><br><span class="line"><span class="attribute">maxnice</span>      <span class="number">0</span> </span><br><span class="line"><span class="attribute">maxrtprio</span>    <span class="number">0</span> </span><br><span class="line"><span class="attribute">maxrttime</span>    unlimited</span><br></pre></td></tr></table></figure><h2 id="复现方法-2">复现方法</h2><ul><li>将普通用户的nproc临时修改</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ulimit</span> -u  <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>简单写个test.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        pid=fork();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count= %d\n&quot;</span>,count);&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="keyword">test</span>.c -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><ul><li>执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure><ul><li>报错</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: fork: retry: 资源暂时不可用</span><br></pre></td></tr></table></figure><h1>想法</h1><ul><li><p>[x] <code>limits.conf和xx-nproc.conf都支持修改</code>nproc<code>,为什么就改xx-nproc.conf? </code>因为/etc/security/limits.d/里面的文件里面的配置会覆盖/etc/security/limits.conf的配置</p></li><li><p>[x] <code>顺序</code>?soft&lt;hard&lt;nr_open&lt;file-max</p></li><li><p>[ ] <code>文件描述符的上限在哪?</code></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for  V in `seq  100000  10000000` ; do ulimit -n $V ; [[ $? != 0 ]] &amp;&amp; break;done</span><br></pre></td></tr></table></figure><ul><li><p>[x] <code>lsof是否可以用来排查这俩个报错?</code>lsof可以看打开的文件数量,用ps看进程数量</p></li><li><p>[x] <code>file-max的上限在哪里呢?</code>只要你的内存足够大，file-max的值可以非常大(大概这么说)</p></li><li><p>[x] <code>nproc的最大是在哪里?</code></p></li></ul><p>这个数字在centos8(不包括8)是和配置显示一致的,在8之后由内核决定,通过下面的命令,可以计算出我们可以配置的最大的nproc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(($(cat /proc/sys/kernel/threads-max)/2))</span><br></pre></td></tr></table></figure><ul><li>[x] 之前一直拿root做实验,其实得用普通用户来验证所有的效果,就比如nproc,root和普通用户看到是不一样的,明显默认root就会多一点,而普通用户是根据配置来的</li></ul><h1>推荐阅读</h1><ol><li><a href="https://xie.infoq.cn/article/30eeb766ecfac245cc96c45c6">https://xie.infoq.cn/article/30eeb766ecfac245cc96c45c6</a></li><li><a href="https://www.cnblogs.com/Chary/p/15842219.html">https://www.cnblogs.com/Chary/p/15842219.html</a></li><li><a href="https://blog.csdn.net/cnbird2008/article/details/8666620">https://blog.csdn.net/cnbird2008/article/details/8666620</a></li><li><a href="https://elixir.bootlin.com/linux/latest/source">linux内核代码</a></li><li><a href="https://elixir.bootlin.com/linux/v5.10.143/source/kernel/fork.c#L2523">kernel/forc.c,内核定义的nproc最大值,810行左右</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防止误删的操作</title>
      <link href="/posts/e27212c1.html"/>
      <url>/posts/e27212c1.html</url>
      
        <content type="html"><![CDATA[<h1>rm -rf /*</h1><p>众所周知,这是一条执行了就很难挽回的命令,如果在生产环境执行了这条命令,那基本很难救回数据了</p><h1>小技巧</h1><ul><li>新建一个垃圾桶</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir  ~/.trash</span><br></pre></td></tr></table></figure><ul><li>修改环境变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim   ~/.bashrc</span><br></pre></td></tr></table></figure><ul><li>添加一下内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alias rm=del   #使用别名del代替rm   </span><br><span class="line">del()                #函数del，作用：将rm命令修改为mv命令</span><br><span class="line">&#123;  </span><br><span class="line">  mv $@ ~/.trash/  </span><br><span class="line">&#125;  </span><br><span class="line">cleardel()          #函数cleardel，作用：清空回收站.trash文件夹，y或Y表示确认，n表示取消</span><br><span class="line">&#123;  </span><br><span class="line">    read -p &quot;clear sure?[Input &#x27;y&#x27; or &#x27;Y&#x27; to confirm. &amp;&amp; Input &#x27;n&#x27; to cancel.]&quot; confirm   </span><br><span class="line">    [ $confirm == &#x27;y&#x27; ] || [ $confirm == &#x27;Y&#x27; ]  &amp;&amp; /bin/rm -rf ~/.trash/*   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li>更新环境变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h1>原理</h1><p>实际上就是将<code>rm</code>这个命令指向我们自己定义的<code>del</code>命令,而<code>del</code>命令会将我们所有的参数都<code>mv</code>移动到<code>~/.trash</code>目录下,这样当我们误执行rm的时候,实际上只是将文件移动了路径,然后我们在配置一个<code>定时任务</code>,定期清理这个<code>垃圾桶</code>就可以了</p><h1>缺陷</h1><ol><li>由于数据都是mv到家目录的,所以家目录的占用会越来越大,如果不定期清理,可能会导致其他问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 防止误删 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看centos系统引导方式</title>
      <link href="/posts/b5cf572b.html"/>
      <url>/posts/b5cf572b.html</url>
      
        <content type="html"><![CDATA[<h1>运行以下命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -d /sys/firmware/efi ] &amp;&amp; echo UEFI || echo BIOS</span><br></pre></td></tr></table></figure><blockquote><p>会输出对应引导方式的单词</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git拉取总是需要密码</title>
      <link href="/posts/e07e5f84.html"/>
      <url>/posts/e07e5f84.html</url>
      
        <content type="html"><![CDATA[<h1>解决办法</h1><ul><li>先在本地git仓库下执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><ul><li>然后拉取</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><ul><li>此时他会提示输入密码,完成验证之后就可以了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mdadm制作raid测试</title>
      <link href="/posts/e6331d74.html"/>
      <url>/posts/e6331d74.html</url>
      
        <content type="html"><![CDATA[<h1>mdadm</h1><p>Linux内核中有一个md(multiple devices)模块在底层管理RAID设备，它会在应用层给我们提供一个应用程序的工具mdadm ，mdadm是linux下用于创建和管理软件RAID的命令</p><h1>参数</h1><p>-a检测设备名称或添加磁盘<br>-n指定设备数量<br>-l指定RAID级别<br>-C创建<br>-v显示过程<br>-f模拟设备损坏<br>-r移除设备<br>-Q查看摘要信息<br>-D查看详细信息<br>-S停止RAID磁盘阵列</p><h1>搭建raid10</h1><h2 id="准备">准备</h2><ul><li>硬件准备<br>使用虚拟机增加2块5G的虚拟磁盘,然后开机</li><li>软件准备<br>安装mdadm命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mdadm</span><br></pre></td></tr></table></figure><h2 id="创建阵列">创建阵列</h2><p>利用mdadm创建raid,名字是<code>md1</code>的,raid模式是<code>主备</code>的,硬盘块数是<code>2</code>,使用sdb,sdc两块磁盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -C -v /dev/md1 -l 1 -n 2 /dev/sd&#123;b,c&#125;</span><br></pre></td></tr></table></figure><h2 id="查看raid">查看raid</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -D /dev/md1</span><br></pre></td></tr></table></figure><h2 id="格式化">格式化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/md1</span><br></pre></td></tr></table></figure><h2 id="挂载设备">挂载设备</h2><blockquote><p>永久挂载的话就是写入fstab里面</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/md1 /raid-test</span><br></pre></td></tr></table></figure><h2 id="写入配置文件">写入配置文件</h2><blockquote><p>说明</p><ol><li>/etc/mdadm.conf作为默认的配置文件，方便跟踪软RAID的配置，尤其是可以配置监视和事件上报选项。</li><li>–scan只能扫描配置里写的盘符,没有配置在配置文件中的RAID不能组装起来</li><li>DEVICE中配置的是组装RAID时，所有要扫描的磁盘，如RAID中的成员盘没有配置到DEVICE项中，则该磁盘无法组装到RAID中</li></ol></blockquote><ul><li>将盘符纳入磁盘</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo DEVICE /dev/sd[b-i] &gt; /etc/mdadm.conf</span><br></pre></td></tr></table></figure><ul><li>配置软raid信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm --detail --scan &gt;&gt; /etc/mdadm.conf</span><br></pre></td></tr></table></figure><ul><li>组装raid</li></ul><blockquote><p>强制组装–force</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -A --scan</span><br></pre></td></tr></table></figure><h1>模拟故障</h1><h2 id="模拟损坏磁盘">模拟损坏磁盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm /dev/md1 -f /dev/sdb</span><br></pre></td></tr></table></figure><h2 id="查看损坏详情">查看损坏详情</h2><blockquote><p>在状态栏可以看到faulty  /dev/sdb等字样</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -D /dev/md1</span><br></pre></td></tr></table></figure><blockquote><p>[UU]这块很复杂</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/mdstat</span><br></pre></td></tr></table></figure><h2 id="移除损坏盘">移除损坏盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm /dev/md1 -r /dev/sdb</span><br></pre></td></tr></table></figure><h2 id="恢复">恢复</h2><ul><li>给raid1加入新磁盘</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm /dev/md1 -a /dev/sdd</span><br></pre></td></tr></table></figure><ul><li>查看raid状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -D /dev/md1</span><br></pre></td></tr></table></figure><ul><li>查看进度条</li></ul><blockquote><p>这块如果不修改参数,速度会很慢的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 cat /proc/mdstat</span><br></pre></td></tr></table></figure><h1>软raid提速参数</h1><h2 id="坏盘恢复同步提速参数">坏盘恢复同步提速参数</h2><p>此参数会提高同步时硬盘的速度,相当于解封限制,更快同步,但是会影响系统</p><ul><li>内核参数<br>修改<code>/etc/sysctl.conf</code>,加入</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dev.raid.speed_limit_min = 500000</span><br><span class="line">dev.raid.speed_limit_max = 900000</span><br></pre></td></tr></table></figure><ul><li>生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软raid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置bond-network</title>
      <link href="/posts/7a4729e2.html"/>
      <url>/posts/7a4729e2.html</url>
      
        <content type="html"><![CDATA[<h1>声明</h1><p>本文章适用于centos6和centos7使用network配置bond的方式,因为在centos7同时会开启NetworkManager去管理网络,我个人建议,在centos7可以关闭<code>NetworkManager</code>,使用<code>network</code>配置网络,在centos8以上要逐渐掌握<code>nmcli</code>工具</p><h1>bond</h1><p>所谓bond，就是把多个物理网卡绑定成一个逻辑上的网卡，使用同一个IP工作，在增加带宽的同时也可以提高冗余性，一般使用较多的就是来提高冗余，分别和不同交换机相连，提高可靠性，但有时服务器带宽不够了也可以用作增加带宽。</p><h1>网卡bond的模式</h1><p>网卡绑定mode共有七种(0~6)模式</p><ul><li>mode=0:平衡负载模式<br>传输数据包顺序是依次传输（即：第1个包走eth0，下一个包就走eth1….一直循环下去，直到最后一个传输完毕,一个连接的数据包从不同的接口发出的话，中途再经过不同的链路，在客户端很有可能会出现数据包无序到达的问题，而无序到达的数据包需要重新要求被发送</li><li>mode=1:主-备份策略<br>bond1为主备模式，只有一个网卡在使用中。优点就是很安全，两块网卡同时坏的概率很低。缺点则是利用率低下，只有50%的利用率。</li><li>mode=2:平衡策略<br>基于指定的传输HASH策略传输数据包</li><li>mode=3:广播策略<br>在每个slave接口上传输每个数据包</li><li>mode=4:动态链接聚合<br>创建一个聚合组，它们共享同样的速率和双工设定。相当于两块小网卡合并一起当作一个大网卡用，类似1+1=2</li><li>mode=5:适配器传输负载均衡<br>不需要交换机支持的通道bonding。在每个slave上根据当前的负载（根据速度计算）分配外出流量。如果正在接受数据的slave出故障了，另一个slave接管失败的slave的MAC地址</li><li>mode=6:平衡负载模式<br>该模式包含了上一个模式，同时加上针对IPV4流量的接收负载均衡，而且不需要任何交换机的支持。接收负载均衡是通过ARP协商实现的。bonding驱动截获本机发送的ARP应答，并把源硬件地址改写为bond中某个slave的唯一硬件地址，从而使得不同的对端使用不同的硬件地址进行通信</li></ul><h1>修改配置</h1><blockquote><p>文件目录/etc/sysconfig/network-scripts/<br>如果bond0没有就创建一个</p></blockquote><h2 id="bond0虚拟网卡">bond0虚拟网卡</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-bond0</span><br></pre></td></tr></table></figure><ul><li>文件内容</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=bond0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">USERCTL=no</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">IPADDR=190.1.1.1</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=190.1.1.254</span><br><span class="line">BONDING_OPTS=&quot;mode=1 miimon=100&quot;</span><br></pre></td></tr></table></figure><h2 id="slave1网卡">slave1网卡</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line">NAME=eth0</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">USERCTL=no</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPV6INIT=no</span><br><span class="line">SLAVE=yes</span><br><span class="line">MASTER=bond0</span><br></pre></td></tr></table></figure><h2 id="slave2网卡">slave2网卡</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth1</span><br><span class="line">NAME=eth1</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">USERCTL=no</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPV6INIT=no</span><br><span class="line">SLAVE=yes</span><br><span class="line">MASTER=bond0</span><br></pre></td></tr></table></figure><h1>启动bond</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><h1>查看bond</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/net/bonding/bond0</span><br></pre></td></tr></table></figure><ul><li>输出如下</li></ul><blockquote><p>Bonding Mode: fault-tolerance (active-backup)就是主备模式</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)</span><br><span class="line"></span><br><span class="line">Bonding Mode: fault-tolerance (active-backup)</span><br><span class="line">Primary Slave: None</span><br><span class="line">Currently Active Slave: ens34</span><br><span class="line">MII Status: up</span><br><span class="line">MII Polling Interval (ms): 100</span><br><span class="line">Up Delay (ms): 0</span><br><span class="line">Down Delay (ms): 0</span><br><span class="line"></span><br><span class="line">Slave Interface: ens33</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: 1000 Mbps</span><br><span class="line">Duplex: full</span><br><span class="line">Link Failure Count: 0</span><br><span class="line">Permanent HW addr: 00:0c:29:fe:d5:e1</span><br><span class="line">Slave queue ID: 0</span><br><span class="line"></span><br><span class="line">Slave Interface: ens34</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: 1000 Mbps</span><br><span class="line">Duplex: full</span><br><span class="line">Link Failure Count: 0</span><br><span class="line">Permanent HW addr: 00:0c:29:fe:d5:eb</span><br><span class="line">Slave queue ID: 0</span><br></pre></td></tr></table></figure><h1>修改bond模式</h1><h2 id="修改配置">修改配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-bond0</span><br></pre></td></tr></table></figure><p>将<code>BONDING_OPTS</code>里面<code>mode=1</code>改成<code>mode=3</code></p><h2 id="删除bonding驱动">删除bonding驱动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmmod bonding</span><br></pre></td></tr></table></figure><h2 id="重启网络">重启网络</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之nmcli</title>
      <link href="/posts/6ad86d1e.html"/>
      <url>/posts/6ad86d1e.html</url>
      
        <content type="html"><![CDATA[<h1>NetworkManager</h1><ol><li>NetworkManager服务是管理和监控网络设置的守护进程,Centos7之前的版本都是通过network.service管理网络配置</li><li>到了Centos7就同时支持network.service和NetworkManager.service</li><li>在RHEL 8/Centos 8上已废弃network.service（默认不安装）,只能通过NetworkManager进行网络配置。</li><li>NetworkManager主要管理2个对象 <code>Connection</code>（网卡连接配置） 和 <code>Device</code>（网卡设备）,他们之间是多对一的关系,但是同一时刻只能有一个Connection对于Device才生效</li></ol><h1>启动方法</h1><p>启动+开机自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now NetworkManager</span><br></pre></td></tr></table></figure><h1>三种方法配置网络</h1><ol><li>通过nmcli connection add命令配置,会自动生成ifcfg文件</li><li>手动配置ifcfg文件,通过nmcli connection reload来加载生效</li><li>手动配置ifcfg文件,通过传统network.service来加载生效</li></ol><h1>nmcli基操</h1><p>NetworkManager在系统中的管理工具为nmcli,这个命令<code>嘎嘎好用</code></p><h2 id="查看所有连接">查看所有连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show </span><br></pre></td></tr></table></figure><h2 id="查看所有激活的连接">查看所有激活的连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show --active</span><br></pre></td></tr></table></figure><h2 id="查看指定的网口的连接">查看指定的网口的连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show eth0</span><br></pre></td></tr></table></figure><h2 id="关闭连接">关闭连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection down eth0</span><br></pre></td></tr></table></figure><h2 id="启用连接">启用连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up eth0</span><br></pre></td></tr></table></figure><h1>nmcli配置网络实例-dhcp</h1><h2 id="新增连接">新增连接</h2><ul><li>创建一个连接名<code>dachui</code>,使用ens33设备</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui type Ethernet ifname ens33</span><br></pre></td></tr></table></figure><h2 id="展示创建后的效果">展示创建后的效果</h2><p>(实在不想配图)<br>可以看出只有一个行<code>NAME</code>是ens33是激活的(因为激活的连接在终端显示绿色,或者用–active可以看出来)</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME    UUID                                  TYPE      DEVICE </span><br><span class="line">ens33   c96bc909-188e-ec64-3a96-6a90982b08ad  ethernet  ens33  </span><br><span class="line">dachui  4b27c0d3-17d5-434b-90d1-5ac57a0f6147  ethernet  --     </span><br><span class="line">ens34   94aea789-efb3-ef4c-81b0-e8b18ecc9797  ethernet  -- </span><br></pre></td></tr></table></figure><h2 id="查看dachui的配置">查看<code>dachui</code>的配置</h2><p>如果不加<code>grep</code>,他会显示很多信息,但我们只需要关注ipv4的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show dachui | grep ipv4</span><br></pre></td></tr></table></figure><h2 id="配置展示">配置展示</h2><p>可以看出第一行<code>ipv4.method</code>的是<code>auto</code>,他代表<code>dachui</code>这个连接是用<code>dhcp</code>的方式获取ip的</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ipv4.method:                            auto</span><br><span class="line">ipv4.dns:                               --</span><br><span class="line">ipv4.dns-search:                        --</span><br><span class="line">ipv4.dns-options:                       &quot;&quot;</span><br><span class="line">ipv4.dns-priority:                      0</span><br><span class="line">ipv4.addresses:                         --</span><br><span class="line">ipv4.gateway:                           --</span><br><span class="line">ipv4.routes:                            --</span><br><span class="line">ipv4.route-metric:                      -1</span><br><span class="line">ipv4.route-table:                       0 (unspec)</span><br><span class="line">ipv4.routing-rules:                     --</span><br><span class="line">ipv4.ignore-auto-routes:                否</span><br><span class="line">ipv4.ignore-auto-dns:                   否</span><br><span class="line">ipv4.dhcp-client-id:                    --</span><br><span class="line">ipv4.dhcp-timeout:                      0 (default)</span><br><span class="line">ipv4.dhcp-send-hostname:                是</span><br><span class="line">ipv4.dhcp-hostname:                     --</span><br><span class="line">ipv4.dhcp-fqdn:                         --</span><br><span class="line">ipv4.never-default:                     否</span><br><span class="line">ipv4.may-fail:                          是</span><br><span class="line">ipv4.dad-timeout:                       -1 (default)</span><br></pre></td></tr></table></figure><h2 id="激活dhcp">激活dhcp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con show ens33 | grep IP4</span><br></pre></td></tr></table></figure><ul><li>激活的结果<br>可以看出这边ipv4的地址已经自动获取了</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP4.ADDRESS[1]:                         192.168.42.135/24</span><br><span class="line">IP4.GATEWAY:                            192.168.42.2</span><br><span class="line">IP4.ROUTE[1]:                           dst = 0.0.0.0/0, nh = 192.168.42.2, mt = 102</span><br><span class="line">IP4.ROUTE[2]:                           dst = 192.168.42.0/24, nh = 0.0.0.0, mt = 102</span><br><span class="line">IP4.DNS[1]:                             192.168.42.2</span><br><span class="line">IP4.DOMAIN[1]:                          localdomain</span><br></pre></td></tr></table></figure><h1>nmcli配置网络实例-static</h1><p>刚才是展示的新增一个连接,使用默认的<code>dhcp</code>方式配置网络,但实际项目中需要使用静态ip的方式,配置静态的手段有很多,可以对现在有<code>连接</code>进行系iu改,也可以再创建一个<code>连接</code>并且同时指定他的ip地址</p><h2 id="一次性创建">一次性创建</h2><p>乍一看命令<code>嘎嘎</code>长,其实很简单</p><ul><li><code>嘎嘎</code>长的命令,其实可以更长</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui-static type ethernet ifname ens33 ipv4.method manual ipv4.address 192.168.42.5/24 ipv4.gateway 192.168.42.2</span><br></pre></td></tr></table></figure><blockquote><p>我拆开两部分分析</p></blockquote><ol><li>创建连接,指定模式<br>这边就是创建了<code>dahcui-static</code>的连接,使用<code>type</code>指定此连接为<code>ethernet</code>(以太网),并且设备是<code>ens33</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui-static type ethernet ifname ens33</span><br></pre></td></tr></table></figure><ol start="2"><li>配置网络要素<br>一个ip地址至少需要指定一个<code>ip</code>和<code>子网掩码</code>才可以生效,网关也是需要配置的,还有指定是手动</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ipv4</span>.method manual ipv4.address <span class="number">192.168.42.5</span>/<span class="number">24</span> ipv4.gateway <span class="number">192.168.42.2</span></span><br></pre></td></tr></table></figure><ul><li>激活连接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static | grep IP4</span><br></pre></td></tr></table></figure><blockquote><p>输出为下面的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP4.ADDRESS[1]:                         192.168.42.5/24</span><br><span class="line">IP4.GATEWAY:                            192.168.42.2</span><br><span class="line">IP4.ROUTE[1]:                           dst = 0.0.0.0/0, nh = 192.168.42.2, mt = 102</span><br><span class="line">IP4.ROUTE[2]:                           dst = 192.168.42.0/24, nh = 0.0.0.0, mt = 102</span><br><span class="line">IP4.DNS[1]:                             192.168.42.2</span><br><span class="line">IP4.DOMAIN[1]:                          localdomain</span><br></pre></td></tr></table></figure><h2 id="编辑连接">编辑连接</h2><p>如果之前是创建好了多个连接,但是需要修改,可以通过modify的方法</p><ul><li>提示一点<br>如果要修改,请看好原先的<code>连接</code>是<code>自动获取</code>还是<code>手动获取</code>,如果是自动,需要改模式</li></ul><blockquote><p>可以一并加入修改的,我只是拆开提示一下,遇到过一次改了半天没生效,一看连接方式是dhcp</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static ipv4.method manual </span><br></pre></td></tr></table></figure><ul><li>修改ip<br>也可以修改其他的,在输入<code>dachui-static</code>之后按<code>tap</code>会列举出所有的<code>配置项</code>,然后根据语法修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static ipv4.address 192.168.42.200/24</span><br></pre></td></tr></table></figure><ul><li>重启网卡<br>修改之后需要激活一下才能生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static</span><br></pre></td></tr></table></figure><blockquote><p>这样一个基本的nmlci创建连接就结束了</p></blockquote><h1>其他基操</h1><h2 id="增加路由">增加路由</h2><p>内网环境下,机器可能有多个网段,那么加路由肯定是必须的,比如我这需要访问<code>10.10.10.0/24</code>的机器,那么通过如下方法进行配置</p><ul><li>加路由</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static +ipv4.routes &quot;10.10.10.0/24 192.168.42.2&quot;</span><br></pre></td></tr></table></figure><ul><li>激活看信息</li></ul><ol><li>配置信息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP4.ROUTE[5]:                           dst = 10.10.10.0/24, nh = 192.168.42.2, mt = 102</span><br></pre></td></tr></table></figure><ol start="2"><li>路由信息</li></ol><ul><li>route展示</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><ul><li>输出结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.42.2    0.0.0.0         UG    102    0        0 ens33</span><br><span class="line">10.10.10.0      192.168.42.2    255.255.255.0   UG    102    0        0 ens33</span><br></pre></td></tr></table></figure><h2 id="删除路由">删除路由</h2><p>学会增加,也要学会删除</p><ul><li><code>乍一看</code>是不是一样的?其实将<code>+</code>改成<code>-</code>,然后<code>重新激活</code>就可以了</li></ul><blockquote><p>所以修改的逻辑很简单的,<code>+</code>就增加,<code>-</code>就是删除,<code>什么都不加</code>就是修改</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static -ipv4.routes &quot;10.10.10.0/24 192.168.42.2&quot;</span><br></pre></td></tr></table></figure><h2 id="增加ip">增加ip</h2><p>有时候需要在一个连接上加多个ip地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static +ipv4.addresses 2.2.2.2/16</span><br></pre></td></tr></table></figure><h2 id="删除连接">删除连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection delete dachui-static</span><br></pre></td></tr></table></figure><h2 id="网卡开机自启动">网卡开机自启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static autoconnect yes</span><br></pre></td></tr></table></figure><h1>nmtui</h1><p>其实nmcli的玩法有很多,但其实还有一个工具<code>nmtui</code>,他是<code>NetworkManager-tui</code>的一个工具,通过字符图形化配置网络</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之top</title>
      <link href="/posts/5285e72b.html"/>
      <url>/posts/5285e72b.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>top命令的功能是用于实时显示系统运行状态，包含处理器、内存、服务、进程等重要资源信息</p><h1>语法格式</h1><p>top [参数]</p><h1>用法</h1><h2 id="基本用法">基本用法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><h2 id="指定刷新时间">指定刷新时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -d 1</span><br></pre></td></tr></table></figure><h2 id="显示进程的命令行参数">显示进程的命令行参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -c</span><br></pre></td></tr></table></figure><h2 id="监视指定进程">监视指定进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 5201 -p 54231</span><br></pre></td></tr></table></figure><h2 id="显示指定用户">显示指定用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -u root</span><br></pre></td></tr></table></figure><blockquote><p>我的top输出</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 23:15:06 up 21 min,  3 users,  load average: 1.19, 0.72, 0.32</span><br><span class="line">Tasks: 191 total,   3 running, 144 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  1.5 us,  3.0 sy,  0.0 ni, 95.0 <span class="built_in">id</span>,  0.0 wa,  0.5 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  4009048 total,  2791500 free,   493780 used,   723768 buff/cache</span><br><span class="line">KiB Swap:   839676 total,   839676 free,        0 used.  3218592 avail Mem </span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                        </span><br><span class="line">8671 root      20   0  511852 105736  43568 S   4.0  2.6   0:04.58 X                                                                                              </span><br><span class="line">9872 root      20   0  702884  46780  35292 S   2.0  1.2   0:00.81 mate-terminal                                                                                        </span><br></pre></td></tr></table></figure><h1>top的交互功能</h1><ul><li>在top基本视图中，敲击c键，可以显示进程的路径</li><li>在top基本视图中，敲击k键，可以在不退出top命令的情况下杀死某个正在运行的进程</li><li>在top基本视图中，敲击1键，可监控每个逻辑CPU的状况</li><li>在top基本视图中，敲击上下键，可以增减显示的进程数目</li></ul><h1>top输出解释</h1><h2 id="第一行-基本信息">第一行-基本信息</h2><h3 id="系统当前时间">系统当前时间</h3><p>top - 23:15:06</p><h3 id="系统运行时间">系统运行时间</h3><p>up 21 min</p><h3 id="当前登录用户数量">当前登录用户数量</h3><p>3 users</p><h3 id="负载均衡情况">负载均衡情况</h3><p>load average: 1.19, 0.72, 0.32<br>三个数分别是1分钟、5分钟、15分钟的负载情况</p><blockquote><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以<code>逻辑CPU</code>的数量，结果高于5的时候就表明系统在超负荷运转了</p></blockquote><h2 id="第二行-进程">第二行-进程</h2><h3 id="总进程">总进程</h3><p>Tasks: 191 total</p><h3 id="当前运行进程数量">当前运行进程数量</h3><p>3 running</p><h3 id="休眠进程数量">休眠进程数量</h3><p>144 sleeping</p><h3 id="停止进程数量">停止进程数量</h3><p>0 stopped,</p><h3 id="僵尸进程数量">僵尸进程数量</h3><p>0 zombie</p><blockquote><p>在unix/linux中，正常情况下,子进程是通过父进程创建的,子进程在创建新的进程,子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束.当一个进程完成它的工作终止之后,它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态</p></blockquote><ul><li>孤儿进程<br>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li><li>僵尸进程<br>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</li></ul><h2 id="第三行-cpu状态">第三行-cpu状态</h2><h3 id="us">us</h3><p>用户空间占用CPU的百分比</p><h3 id="sy">sy</h3><p>内核空间占用CPU的百分比</p><h3 id="ni">ni</h3><p>改变过优先级的进程占用CPU的百分比</p><h3 id="id">id</h3><p>空闲CPU百分比</p><h3 id="wa">wa</h3><p>IO等待占用CPU的百分比</p><h3 id="hi">hi</h3><p>硬中断占用CPU的百分比</p><h3 id="si">si</h3><p>软中断占用CPU的百分比</p><h3 id="st">st</h3><p>当Linux系统是在虚拟机中运行时，等待CPU资源的时间占比</p><blockquote><p>简单说，Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p></blockquote><ul><li>Kernel space<br>用户空间可以执行任意命令，调用系统的一切资源；</li><li>User space<br>内核空间只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令</li></ul><h2 id="第四行-内存状态">第四行-内存状态</h2><h3 id="total">total</h3><p>总内存量4009048</p><h3 id="free">free</h3><p>空闲内存2791500</p><h3 id="used">used</h3><p>已用内存493780</p><h3 id="buff-cache">buff/cache</h3><p>缓存内存723768</p><blockquote><p>KiB Mem：Kib表示描述单位，MEM表示内存</p></blockquote><h2 id="第五行-swap状态">第五行-swap状态</h2><h3 id="total-2">total</h3><p>总内存量839676</p><h3 id="free-2">free</h3><p>空闲内存839676</p><h3 id="used-2">used</h3><p>已用内存0</p><h3 id="avail-Mem">avail Mem</h3><p>可用内存3218592</p><ul><li>free 是真正尚未被使用的物理内存数量。</li><li>available 是应用程序认为可用内存数量，available = free + buffer + cache (注：只是大概的计算方法)</li></ul><h2 id="第六行-进程监控">第六行-进程监控</h2><ul><li>PID — 进程id</li><li>USER — 进程所有者</li><li>PR — 进程优先级</li><li>NI — nice值。负值表示高优先级，正值表示低优先级</li><li>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li><li>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li><li>SHR — 共享内存大小，单位kb</li><li>S — 进程状态。D=不可中断的睡眠状态；R=运行；S=睡眠；T=跟踪/停止；Z=僵尸进程</li><li>%CPU — 上次更新到现在的CPU时间占用百分比</li><li>%MEM — 进程使用的物理内存百分比</li><li>TIME+ — 进程使用的CPU时间总计，单位1/100秒</li><li>COMMAND — 进程名称（命令名/命令行）</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RH442系统调优笔记</title>
      <link href="/posts/69bbfb9a.html"/>
      <url>/posts/69bbfb9a.html</url>
      
        <content type="html"><![CDATA[<h1>基础知识</h1><p>调优是很困难的,也<code>不是万能</code>的,调优只是对系统策略进行一定的调整来获取更大的<code>吞吐量</code>和<code>响应时间</code>,调优之前要尽可能分析系统瓶颈在哪</p><h1>调优目的</h1><ul><li>为某一特定的角色来调优<ul><li>数据库服务器</li><li>文件服务器</li><li>web服务器</li><li>电子邮件服务器</li><li>中间件等</li></ul></li><li>找出和调整系统瓶颈</li><li>得更快的响应时间或者更大的吞吐量</li></ul><h1>相关概念</h1><ul><li>调优目标：设置明确的性能目标可以在成功调节性能后获得可度量的收益</li><li>性能瓶颈：当资源或设备达到其最大操作容量时，就出现了瓶颈，瓶颈会影响整体性能</li><li>人为因素：在系统调优时，必须考虑人的主观因素</li><li>负载优化：性能调优通常针对特定工作负载进行优化，但这时可能其他工作进程会被这些设置所阻碍</li><li>吞吐量和延迟：吞吐量是指给定时间内资源可以传输或处理的数据量的度量；延迟是资源必须等待开始数据传输或处理的延迟</li></ul><h1>处理步骤</h1><h2 id="收集信息">收集信息</h2><p>调优之前要尽可能收集所有信息,可以通过sosreport命令收集这些信息进行分析,但是收集的时候也需要把握一个<code>度</code>,因为收集信息的过程其实是<code>监控</code>过程,监控是需要消耗一定的资源的,比如CPU的使用率已经99%了,如果还需要<code>实时监控</code>获取信息,可能会导致不可预想的后果</p><ol><li>系统配置信息(OS版本,处理器信息,内存信息等)</li><li>存储信息</li><li>进程信息</li><li>网络信息</li><li>日志信息</li></ol><h2 id="分析过程">分析过程</h2><p>分析是决策的关键,通常将系统分为四个层次来逐步分析,减少问题的集中化</p><ol><li>CPU</li><li>磁盘</li><li>内存</li><li>网络</li></ol><h1>注意</h1><ol><li>系统调优不是万能的,没有系统调优也是万万不能的</li><li>调优是竟可能的发挥硬件和系统的性能,但实际上能提升性能最简单的方法就是升级硬件,你从Gtx750ti换RTX3060他不比优化配置提升来的快吗…机械换固态直接解决大部分io问题…</li><li>但实际上已经2022年了,服务器的配置不会太低,所以在有限的条件下通过系统调优优化业务是一项0成本的方法</li><li>系统调优需要注意每一步操作,因为不是所有参数都可以解决问题,还可能产生新的问题,就和写bug一样</li></ol><h1>调优工具</h1><h2 id="基操工具">基操工具</h2><h3 id="top">top</h3><p>全局统揽</p><h3 id="ps">ps</h3><p>监控进程</p><h3 id="free">free</h3><p>内存分析</p><h3 id="pcp">pcp</h3><p>收集性能数据</p><h3 id="df">df</h3><p>磁盘信息</p><h3 id="lsblk">lsblk</h3><p>磁盘信息</p><h3 id="ss">ss</h3><p>套接字信息</p><h3 id="tuna">tuna</h3><p>调试配置细节</p><h3 id="ulimit">ulimit</h3><p>资源限制参数</p><h2 id="sysstat工具">sysstat工具</h2><h3 id="vmstat">vmstat</h3><p>报告虚拟内存使用情况</p><h3 id="pidstat">pidstat</h3><p>pidstat命令通过进程或线程报告CPU，磁盘I/O，内存使用情况。-p选项可以指定某个进程的ID</p><h3 id="iostat">iostat</h3><p>报告CPU的统计数据和I/O的统计数据。iostat命令可以加入时间间隔和计数次数</p><h3 id="mpstat">mpstat</h3><p>先查看是用户态还是内核态的cpu负载高，如果是用户态就用pidstat看具体进程，如果是内核态就用iostat查看调用的I/O</p><h3 id="sar">sar</h3><p>生成系统活动报告</p><h1>查看硬件资源</h1><h2 id="dmesg">dmesg</h2><p>用于检测和控制内核环缓冲,回顾内核信息</p><h2 id="lscpu">lscpu</h2><p>查看CPU信息,cpu是机器的核心,如果cpu太弱那基本玩不转</p><h2 id="dmidecode">dmidecode</h2><p>检索SMBIOS和DMI的数据结构，并显示出重要的硬件信息</p><h2 id="lspci">lspci</h2><p>检测连接到PCI总线的设备</p><h2 id="lsusb">lsusb</h2><p>检测连接到USB总线的设备</p><h2 id="lshw">lshw</h2><p>列出具体的硬件配置信息，该命令列出精确的内存配置，如固件版本，主板配置，CPU版本和速度，缓存信息和总栈信息</p><h1>内核调优</h1><h2 id="proc文件系统">proc文件系统</h2><p>proc是一个伪文件系统，它提供了内核数据结构的结构。一些/proc文件直接指向了内核参数,编辑/proc文件中的设置与直接编辑内核参数相同。例如vmstat指令就是读取的/proc/meminfo中的信<br>/proc下面有一些常用子文件</p><ul><li>/proc/cpuinfo 提供CPU信息</li><li>/proc/meminfo 提供内存信息</li><li>/proc/swaps 提供swap空间利用率的信息</li><li>/proc/partitions 提供块设备信息</li><li>/proc/<code>PID</code>/ 提供特定某个运行中的进程信息</li></ul><h2 id="内核调节参数">内核调节参数</h2><p>Linux内核通过/proc像用户公开信息和可调节参数，/proc/sys子目录包含了可调节的参数。由于/proc/sys下的更改都直接写入内存中的内核，<code>所以当下次重启时并不会永久保存</code><br>/proc/sys/dev下常见的子目录：</p><ul><li>/proc/sys/dev：系统设备的可调节参数，例如RAID、CD-ROW、SCSI设备等</li><li>/proc/sys/fs：文件系统的可调参数</li><li>/proc/sys/kernel：包含内核内部工作的可调参数</li><li>/proc/sys/net：网络可调参数</li><li>/proc/sys/vm：虚拟内存可调参数</li></ul><h2 id="更改内核参数">更改内核参数</h2><h3 id="编辑器或重定向">编辑器或重定向</h3><ul><li>例如释放缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><ul><li>例如</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1&quot; &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure><h3 id="sysctl指令">sysctl指令</h3><ul><li>查看所有内核可调参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a </span><br></pre></td></tr></table></figure><ul><li>加载配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><ul><li>打印出某个内核参数的值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -n vm.swappiness</span><br></pre></td></tr></table></figure><ul><li>更改某个内核参数的值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.swappiness=60</span><br></pre></td></tr></table></figure><h3 id="etc-sysctl-d-下创建条目">/etc/sysctl.d/下创建条目</h3><p>在系统引导过程中，从以下三个目录中的配置文件中加载可调参数：</p><ul><li>/etc/sysctl.d/*.conf（首选）</li><li>/run/sysctl.d/*.conf</li><li>/usr/lib/sysctl.d/*.conf（不建议）</li></ul><h2 id="sys文件系统">sys文件系统</h2><p>sysfs文件系统也是伪文件系统，挂载到/sys目录上。/sys下的文件提供对作为内核模块加载的设备，文件系统和其他软件的信息和参数的访问。sysfs树曾经也是/proc的一部分，但出于安全性考虑被移植到了自己的文件系统中<br>/sys下常见的子目录：</p><ul><li>/sys/module 加载的内核模块信息</li><li>/sys/devices 保存了所有设备的信息（硬件设备）</li><li>/sys/dev  主要包含b（块block）设备和c（字符串char）设备，但都是以链接文件的形式指向了/sys/devices下真实设备</li><li>/sys/bus 包含各种总线类型</li><li>/sys/class 按照功能来划分的设备，但都是以链接文件的形式指向了/sys/devices下真实设备</li></ul><h2 id="tuned">tuned</h2><p>RHEL系统提供了一个名为tuned的调优服务，来帮助管理员针对不同的工作负载做调优<br>tuned有很多与定义好的profile文件，不同的profile文件是为了满足不同的工作负载而定义的。tuned服务分为静态调优和动态调节</p><ul><li>静态<br>tuned守护进程会在服务启动时或选择新的调优配置文件时应用系统配置。对于静态而言，内核参数是针对整体性能预期而设置的，不会随着活跃度的变化而进行调整</li><li>动态<br>tuned服务会一直监视系统，并根据运行时行为的变化而调整设置。RHLE8中默认关闭了动态调优，如果想启用，则需要修改/etc/tuned/tuned-main.conf文件中的dynamic_tuning = 0，把0换成1。同时动态调优会默认10秒调整一次。可以修改update_interval参数来设定希望的间隔时间</li></ul><h3 id="配置">配置</h3><ul><li>显示出当前正在使用的profile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuned-adm active</span><br></pre></td></tr></table></figure><ul><li>列出所有可用的profile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuned-adm list</span><br></pre></td></tr></table></figure><ul><li>切换某个profile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuned-adm profile PROFILE</span><br></pre></td></tr></table></figure><ul><li>推荐使用某个profile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuned-adm recommend</span><br></pre></td></tr></table></figure><ul><li>关闭调优服务器的调优参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuned-adm off</span><br></pre></td></tr></table></figure><h1>资源限制</h1><p>使用ulimit限制系统资源<br>交互式的使用ulimit将限制到单个用户shell，当某个用户登录系统后，pam_limits限制其使用的资源。在/etc/pam.d/system-auth文件中，有一个&quot;session&quot;调用了pam_limits<br>当用户登录系统后，PAM模块通过/etc/security/limits.conf和/etc/security/limits.d/*.conf的设置来解析和应用ulimit设置。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux机器信息采集</title>
      <link href="/posts/739a6897.html"/>
      <url>/posts/739a6897.html</url>
      
        <content type="html"><![CDATA[<h1>采集信息分类</h1><p>构成计算机的有硬件设备和软件设备</p><h2 id="软件">软件</h2><ol><li>系统的版本,ip,主机名,内核等信息</li></ol><h2 id="硬件">硬件</h2><ol><li>CPU</li><li>内存</li><li>硬盘</li><li>显卡</li><li>网卡</li></ol><h1>软件采集</h1><p>linux发行版很多<br>例如有debian,Ubuntu,centos,redhat,fedora,kylinsec,kylin,linx,arch,majaro,gentoo等,所以各个发行版看版本的命令也不一样,这边只对<code>R系</code>的发行版进行说明</p><h2 id="系统版本">系统版本</h2><ul><li>centos</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/centos-release</span><br></pre></td></tr></table></figure><ul><li>kylin系列</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/.kyinfo</span><br></pre></td></tr></table></figure><ul><li>其他命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有些发行版需要单独安装此包</span></span><br><span class="line">lsb_release -a </span><br></pre></td></tr></table></figure><h2 id="查看系统内核版本">查看系统内核版本</h2><p><code>uname</code>命令是所有Linux发行版基本通用的命令,uname的选项有很多,我会更新这个命令的用法的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><h2 id="查看系统架构">查看系统架构</h2><p>系统架构有以下两大类</p><ul><li>x86_64</li><li>ARM</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch</span><br></pre></td></tr></table></figure><h1>处理器CPU采集</h1><h2 id="查看CPU生产厂家">查看CPU生产厂家</h2><p>防止小作坊生产的(233333),用<code>uniq</code>基本上都是<code>过滤重复项</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s processor-manufacturer | uniq</span><br></pre></td></tr></table></figure><h2 id="CPU型号">CPU型号</h2><ol><li>通过查看cpuinfo文件过滤model name,并且过滤出重复项,因为cpu基本上是多核心的,再用cut剪切不需要的部分</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &#x27;model name&#x27; | uniq | cut -d: -f2</span><br></pre></td></tr></table></figure><ol start="2"><li>也可以通过dmidecode命令进行查看</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s processor-version | uniq</span><br></pre></td></tr></table></figure><ol start="3"><li>还可以通过命令查看<br>但是如果服务器是多路CPU可能输出会比较多</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure><h2 id="查看处理器位数">查看处理器位数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getconf LONG_BIT</span><br></pre></td></tr></table></figure><h2 id="查看机器是几路CPU">查看机器是几路CPU</h2><p>几路就是机器有几个实实在在的<code>cpu</code>硬件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;physical id&quot; /proc/cpuinfo | sort | uniq | wc -l</span><br></pre></td></tr></table></figure><h2 id="查看每颗处理器cores-核心-数量">查看每颗处理器cores(核心)数量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq | awk &#x27;&#123;print $4&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="查看总核数">查看总核数</h2><p>简单计算就出来了<br><code>总核数</code> = 物理CPU个数 X <code>每颗</code>物理CPU的<code>核数</code></p><h2 id="查看总逻辑CPU数">查看总逻辑CPU数</h2><p><code>总逻辑CPU数</code> = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l</span><br></pre></td></tr></table></figure><h2 id="查看所有cores-核心数量">查看所有cores(核心数量)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;cpu cores&quot; | wc -l</span><br></pre></td></tr></table></figure><h2 id="查看L1缓存">查看L1缓存</h2><p>一级缓存是CPU第一层高速缓存,分为数据缓存(L1d)和指令缓存(L1i),内置的L1高速缓存的容量和结构对CPU的性能影响较大,不过高速缓冲存储器均由静态RAM组成,结构较复杂m在CPU管芯面积不能太大的情况下,L1级高速缓存的容量不可能做得太大,一般服务器CPU的L1缓存的容量通常在32—256KB</p><ul><li>数据缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep -i &#x27;L1d cache&#x27; </span><br></pre></td></tr></table></figure><ul><li>指令缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep -i &#x27;L1i cache&#x27;</span><br></pre></td></tr></table></figure><h2 id="查看L2缓存">查看L2缓存</h2><p>二级缓存是CPU的第二层高速缓存,L2高速缓存容量也会影响CPU的性能,原则是越大越好,现在家庭用CPU容量最大的是4MB,而服务器和工作站上用CPU的L2高速缓存更高达2MB—4MB，有的高达8MB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep -i &#x27;L2 cache&#x27; </span><br></pre></td></tr></table></figure><h2 id="查看L3缓存">查看L3缓存</h2><p>进一步提高了CPU的效率,越大越好,比如谁给我买一个<a href="https://www.amd.com/zh-hans/products/cpu/amd-ryzen-threadripper-pro-5955wx">AMD Ryzen™ Threadripper™ PRO 5955WX</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep -i &#x27;L3 cache&#x27;</span><br></pre></td></tr></table></figure><h2 id="查看处理器频率">查看处理器频率</h2><ol><li>lscpu过滤<br>这个数值是<code>动态</code>变化的!</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep -i &#x27;CPU MHz&#x27; | awk -F &#x27;：|:&#x27; &#x27;&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure><ol start="2"><li>cpuinfo文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep MHz</span><br></pre></td></tr></table></figure><ol start="3"><li>DMI查看</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s processor-frequency | uniq</span><br></pre></td></tr></table></figure><h1>查看内存信息</h1><h2 id="查看内存总大小">查看内存总大小</h2><ul><li>大小</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode | grep -A16 &quot;Memory Device&quot; | grep Size | grep -v No | awk &#x27;&#123;sum+=$2&#125;END&#123;print sum&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>单位<br>其实单位一般就是MB</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode | grep -A16 &quot;Memory Device&quot; | grep Size | grep -v No | awk &#x27;&#123;print $3&#125;&#x27; | uniq</span><br></pre></td></tr></table></figure><h2 id="从系统角度看内存">从系统角度看内存</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><h2 id="查看内存条数量和每根的具体大小">查看内存条数量和每根的具体大小</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode | grep -A16 &quot;Memory Device&quot; | grep Size </span><br></pre></td></tr></table></figure><blockquote><p>输入如下,其实只要看Size:字段</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Size: 8192 MB</span><br><span class="line">Size: 4096 MB</span><br><span class="line">Size: 4096 MB</span><br><span class="line">Size: No Module Installed</span><br><span class="line">Range Size: 8 GB</span><br><span class="line">Range Size: 4 GB</span><br><span class="line">Range Size: 4 GB</span><br></pre></td></tr></table></figure><h2 id="查看机器最大支持内存容量">查看机器最大支持内存容量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode | grep &quot;Maximum Capacity&quot; | sed  &quot;s/^[ \t]*//&quot;</span><br></pre></td></tr></table></figure><h2 id="查看内存频率">查看内存频率</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode|grep -A16 &quot;Memory Device&quot;|grep &#x27;Speed&#x27; </span><br></pre></td></tr></table></figure><blockquote><p>其实上面的命令就足够了,但可以过滤其他参数来显示更加精确,比如</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode|grep -A16 &quot;Memory Device&quot;|grep &#x27;Speed&#x27; | grep -iv &#x27;unKnown&#x27;</span><br></pre></td></tr></table></figure><h2 id="查看内存制造商">查看内存制造商</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode | grep -A16 &quot;Memory Device&quot; | grep &#x27;Manufacturer&#x27;</span><br></pre></td></tr></table></figure><h2 id="查看内存规格">查看内存规格</h2><blockquote><p>我只有家用的物理机器,服务器没有试过</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -t memory | grep Type:</span><br></pre></td></tr></table></figure><h2 id="查看内存序列号">查看内存序列号</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -t memory | grep -i &#x27;Serial Number&#x27; </span><br></pre></td></tr></table></figure><h1>查看主板信息</h1><h2 id="总揽信息">总揽信息</h2><blockquote><p>可以看出很多信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -t bios</span><br></pre></td></tr></table></figure><p>比如我这张昂达主板</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># dmidecode 3.2</span><br><span class="line">Getting SMBIOS data from sysfs.</span><br><span class="line">SMBIOS 3.0.0 present.</span><br><span class="line"></span><br><span class="line">Handle 0x0000, DMI type 0, 24 bytes</span><br><span class="line">BIOS Information</span><br><span class="line">        Vendor: American Megatrends Inc.</span><br><span class="line">        Version: 5.11</span><br><span class="line">        Release Date: 2016/05/30</span><br><span class="line">        Address: 0xF0000</span><br><span class="line">        Runtime Size: 64 kB</span><br><span class="line">        ROM Size: 6144 kB</span><br><span class="line">        Characteristics:</span><br><span class="line">                PCI is supported</span><br><span class="line">                BIOS is upgradeable</span><br><span class="line">                BIOS shadowing is allowed</span><br><span class="line">                Boot from CD is supported</span><br><span class="line">                Selectable boot is supported</span><br><span class="line">                BIOS ROM is socketed</span><br><span class="line">                EDD is supported</span><br><span class="line">                5.25&quot;/1.2 MB floppy services are supported (int 13h)</span><br><span class="line">                3.5&quot;/720 kB floppy services are supported (int 13h)</span><br><span class="line">                3.5&quot;/2.88 MB floppy services are supported (int 13h)</span><br><span class="line">                Print screen service is supported (int 5h)</span><br><span class="line">                Serial services are supported (int 14h)</span><br><span class="line">                Printer services are supported (int 17h)</span><br><span class="line">                ACPI is supported</span><br><span class="line">                USB legacy is supported</span><br><span class="line">                BIOS boot specification is supported</span><br><span class="line">                Targeted content distribution is supported</span><br><span class="line">                UEFI is supported</span><br><span class="line">        BIOS Revision: 5.11</span><br><span class="line"></span><br><span class="line">Handle 0x0057, DMI type 13, 22 bytes</span><br><span class="line">BIOS Language Information</span><br><span class="line">        Language Description Format: Long</span><br><span class="line">        Installable Languages: 2</span><br><span class="line">                zh|CN|unicode</span><br><span class="line">                &lt;BAD INDEX&gt;</span><br><span class="line">        Currently Installed Language: zh|CN|unicode</span><br></pre></td></tr></table></figure><h2 id="主板BIOS厂商">主板BIOS厂商</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s bios-vendor</span><br></pre></td></tr></table></figure><h2 id="BIOS版本">BIOS版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s bios-version</span><br></pre></td></tr></table></figure><h2 id="主板厂家">主板厂家</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s system-manufacturer</span><br></pre></td></tr></table></figure><h2 id="主板具体型号">主板具体型号</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s system-product-name</span><br></pre></td></tr></table></figure><h2 id="机器序列号">机器序列号</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s system-serial-number</span><br></pre></td></tr></table></figure><h1>查看显卡信息</h1><h2 id="定位型号">定位型号</h2><ul><li>查看显卡厂商ID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nn | grep -i vga</span><br></pre></td></tr></table></figure><blockquote><p>输出结果如,只需要关注 [10de:1c82] 类似这个的字段</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01:00.0 VGA compatible controller [0300]: NVIDIA Corporation GP107 [GeForce GTX 1050 Ti] [10de:1c82] (rev a1)</span><br></pre></td></tr></table></figure><ul><li>登陆网站查询</li></ul><ol><li>有些显卡可能比较老,在lspci可能不会输出,此时就要登陆<a href="https://devicehunt.com/">devicehunt</a>进行查询</li><li>上面说了要关注<code>[10de:1c82]</code> 字段,其中<code>10de</code>是<code>Vendor ID</code>,<code>1c82</code>是<code>Device ID</code></li><li>只需要在<a href="https://devicehunt.com/">devicehunt</a>网站的<code>Device ID</code>输入框输入<code>1c82</code>就可以查询了</li></ol><h2 id="N卡">N卡</h2><p>如果已经安装好了驱动,只要输入N卡命令</p><ul><li>以字符模式输出信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><ul><li>打开显卡设置面板</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-settings</span><br></pre></td></tr></table></figure><h2 id="查看显存">查看显存</h2><p>(我也没试过)</p><ol><li>dmesg查看</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i VRAM</span><br></pre></td></tr></table></figure><ol start="2"><li>查看proc下内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/gpuinfo_0</span><br></pre></td></tr></table></figure><h1>查看网卡信息</h1><h2 id="定位型号-2">定位型号</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpi -nn | grep -i eth</span><br></pre></td></tr></table></figure><p>输出如下,可以看到有四个设备,查询方法和显卡一直,一般来说都会有驱动,但如果没有,则需要去对应网站下载源码进行编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0b:00.0 Ethernet controller [0200]: Intel Corporation Ethernet Controller I225-V [8086:15f3] (rev 03)</span><br><span class="line">0b:00.1 Ethernet controller [0200]: Intel Corporation Ethernet Controller I225-V [8086:15f3] (rev 03)</span><br><span class="line">0b:00.2 Ethernet controller [0200]: Intel Corporation Ethernet Controller I225-V [8086:15f3] (rev 03)</span><br><span class="line">0b:00.3 Ethernet controller [0200]: Intel Corporation Ethernet Controller I225-V [8086:15f3] (rev 03)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/posts/f3fb008f.html"/>
      <url>/posts/f3fb008f.html</url>
      
        <content type="html"><![CDATA[<h1>用到的软件</h1><ol><li>hexo博客</li><li>node.js语言,进行本地部署</li><li>git代码管理,托管服务器</li><li>nginx代理服务,用于代理</li><li>centos7.9-2204操作系统</li><li>vscode博客编辑软件</li><li>windterm远程工具</li><li>docker运行容器</li><li>twikoo评论系统</li><li>vercel部署api显示github贡献图</li></ol><h1>原理</h1><p>1.为本地hexo博客配置一个部署静态文件的远程仓库<br>2.配置 Nginx 托管博客文件目录<br>3.配置远程仓库自动更新到博客文件目录的钩子<br>在本地将博客同步到服务器之后会自动更新到nginx的页面</p><h1>搭建步骤</h1><h2 id="初始化centos">初始化centos</h2><ol><li>关闭selinux</li><li>关闭防火墙</li><li>配置网络</li></ol><h2 id="初始化git仓库">初始化git仓库</h2><p>使用windterm连接服务器</p><ul><li>创建用户管理</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -s /sbin/nologin test</span><br></pre></td></tr></table></figure><ul><li>创建一个仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/repo</span><br><span class="line">mkdir -p /var/www/hexo</span><br></pre></td></tr></table></figure><ul><li>配置权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R test:test /var/repo</span><br><span class="line">chown -R test:test /var/www/hexo</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 755 /var/repo</span><br><span class="line">chmod -R 755 /var/www/hexo</span><br></pre></td></tr></table></figure><ul><li>初始化仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/repo</span><br><span class="line">git init --bare hexo.git</span><br></pre></td></tr></table></figure><ul><li>创建git钩子</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch /var/repo/hexo.git/hooks/post-receive</span><br><span class="line">chmod +x /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>post-receive添加如下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">git <span class="attr">--work-tree</span>=/var/www/hexo --git-dir=/var/repo/hexo.git checkout -f</span><br></pre></td></tr></table></figure><h2 id="配置nginx">配置nginx</h2><ul><li>修改nginx.conf</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">     server &#123;</span><br><span class="line">     #SSL 访问端口号为 443</span><br><span class="line">     listen      443 ssl;</span><br><span class="line">     #填写绑定证书的域名</span><br><span class="line">     server_name 域名;</span><br><span class="line">     #证书文件名称</span><br><span class="line">     ssl_certificate crt的绝对路径;</span><br><span class="line">     #私钥文件名称</span><br><span class="line">     ssl_certificate_key key的绝对路径;</span><br><span class="line">     ssl_session_timeout 5m;</span><br><span class="line">     #请按照以下协议配置</span><br><span class="line">     ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">     #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。</span><br><span class="line">     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">     ssl_prefer_server_ciphers on;</span><br><span class="line">     location / &#123;</span><br><span class="line">         root   /var/hexo;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">填写绑定证书的域名</span></span><br><span class="line"> server_name 域名;</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">把http的域名请求转成https</span></span><br><span class="line"> return 301 https://域名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置本地hexo同步">配置本地hexo同步</h2><ul><li>编辑_config.yml</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@域名或者ip:/var/repo/hexo.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><ul><li>安装依赖<br>本地机器需要安装node.js才能操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dnf插件</title>
      <link href="/posts/a5bbe015.html"/>
      <url>/posts/a5bbe015.html</url>
      
        <content type="html"><![CDATA[<h1>dnf插件查看</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf --help</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">插件命令列表：</span><br><span class="line">builddep                  Install build dependencies for package or spec file</span><br><span class="line">changelog                 查看软件包的改变日志数据</span><br><span class="line">config-manager            管理 dnf 配置选项和软件仓库</span><br><span class="line">copr                      与 Copr 仓库交互。</span><br><span class="line">debug-dump                转储已安装的 RPM 软件包信息至文件</span><br><span class="line">debug-restore             恢复调试用转储文件中的软件包记录</span><br><span class="line">debuginfo-install         安装调试信息软件包</span><br><span class="line">download                  下载软件包至当前目录</span><br><span class="line">groups-manager            创建并编辑组元数据文件</span><br><span class="line">needs-restarting          判断所升级的二进制文件是否需要重启</span><br><span class="line">playground                与 Playground 仓库交互。</span><br><span class="line">repoclosure               显示仓库中未被解决的依赖关系的列表</span><br><span class="line">repodiff                  列出两组仓库中的不同</span><br><span class="line">repograph                 以点线图方式输出完整的软件包依赖关系图</span><br><span class="line">repomanage                管理 RPM 软件包目录</span><br><span class="line">reposync                  下载远程仓库中的全部软件包</span><br></pre></td></tr></table></figure><p>功能有很多,只看几个我会的</p><h1>changelog</h1><p>在源仓库可以使用的时候才可以查询</p><ul><li>查询openssh的改动日志</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf changelog openssh</span><br></pre></td></tr></table></figure><ul><li>查看指定行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf changelog  --count=30  kernel</span><br></pre></td></tr></table></figure><ul><li>查看bugfix</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf changelog --bugfix</span><br></pre></td></tr></table></figure><h1>config-manager</h1><p>类似yum-config-manager?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --disable cdrom</span><br></pre></td></tr></table></figure><h1>download</h1><ul><li>只下载到当前路径</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf download  openssh</span><br></pre></td></tr></table></figure><h1>repoclosure</h1><p>显示仓库中未被解决的依赖关系的列表,是仓库!不是本机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf repoclosure</span><br></pre></td></tr></table></figure><h1>repograph</h1><p>将结果输出重定向到文件,vim进行搜索</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf repograph &gt; yilai.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;openssh-server&quot; [color=&quot;0.891304347826 0.991304347826 1.0&quot;];</span><br><span class="line">&quot;openssh-server&quot; -&gt; &#123;</span><br><span class="line">&quot;glibc&quot;</span><br><span class="line">&quot;bash&quot;</span><br><span class="line">&quot;systemd&quot;</span><br><span class="line">&quot;openssl-libs&quot;</span><br><span class="line">&quot;libselinux&quot;</span><br><span class="line">&quot;zlib&quot;</span><br><span class="line">&quot;systemd-libs&quot;</span><br><span class="line">&quot;krb5-libs&quot;</span><br><span class="line">&quot;libxcrypt&quot;</span><br><span class="line">&quot;libcom_err&quot;</span><br><span class="line">&quot;pam&quot;</span><br><span class="line">&quot;audit-libs&quot;</span><br><span class="line">&quot;shadow-utils&quot;</span><br><span class="line">&quot;openssh&quot;</span><br><span class="line">&quot;crypto-policies&quot;</span><br><span class="line">&#125; [color=&quot;0.891304347826 0.991304347826 1.0&quot;];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包管理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>repo文件解释</title>
      <link href="/posts/834a969d.html"/>
      <url>/posts/834a969d.html</url>
      
        <content type="html"><![CDATA[<h1>什么是repo文件</h1><p>repo文件是yum仓库的配置文件后缀，通常一个repo文件中可以设置多个yum仓库源，当安装和升级时yum会读取此配置文件，到yum仓库下载所需的rpm包并安装</p><h1>yum工作原理</h1><ul><li><p>服务器端：在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内。</p></li><li><p>客户端：如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的记录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装。</p></li></ul><h1>举个栗子</h1><p>repo文件一般都在<code>/etc/yum.repo.d</code>路径下面</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Base]</span></span><br><span class="line"><span class="attr">name</span>=CentOS-<span class="variable">$releasever</span> - Base</span><br><span class="line"><span class="attr">baseurl</span>=https://mirrors.ustc.edu.cn/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centos<span class="literal">off</span>icial</span><br></pre></td></tr></table></figure><ul><li><p>[Base]<br>是serverid,.必选值,不可重复,重复了以后面的为准,定义软件仓库(Repository)的名称,用作Yum识别不同仓库</p></li><li><p>name<br>用于定义仓库名和描述信息,用做配置说明,支持<code>$releasever</code>和<code>$basearch</code>这样的变量</p></li><li><p>baseurl<br>必填选项,定义仓库文件路径。可选的协议值为http, https, file://, ftp://,可以在里面使用变量,<code>但只能写一个</code></p></li><li><p>mirrorlist</p><p>是指定一个镜像服务器的地址列表</p></li><li><p>enabled<br>是否开启当前仓库，0表示关闭，1表示开启。如未指明，默认为1</p></li><li><p>gpgcheck<br>是否检查软件包的GPG签名，1为开启，0为关闭</p></li><li><p>gpgkey<br>用于指定GPG签名文件的URL</p></li><li><p>常用变量</p><ul><li><p>$releasever</p><p>发行版的版本，从yum.conf文件中的distroverpkg获取，如果没有，则根据redhat-release包进行判断。</p></li><li><p>$arch</p><p>cpu体系，如i686,athlon等</p></li><li><p>$basearch</p><p>cpu的基本体系组，如i686和athlon同属i386，alpha和alphaev6同属alpha。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 配置解释 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置解释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code-server搭建</title>
      <link href="/posts/a74d3561.html"/>
      <url>/posts/a74d3561.html</url>
      
        <content type="html"><![CDATA[<h1>下载软件</h1><p>code-server软件</p><h1>解压</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf code-server.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><h1>定义配置文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.config/code-server</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.config/code-server/config.yml</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#加入内容</span><br><span class="line">bind-addr: 0.0.0.0:81</span><br><span class="line">auth: password</span><br><span class="line">password: test.2022</span><br><span class="line">cert: false</span><br></pre></td></tr></table></figure><h1>定义service资源</h1><ul><li>创建文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim code-server.service</span><br></pre></td></tr></table></figure><ul><li>写入配置,ExecStart的是二进制所在路径</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=code-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=exec</span><br><span class="line">ExecStart=/usr/local/code-server/bin/code-server</span><br><span class="line">Restart=always</span><br><span class="line">User=root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure><ul><li>移动配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv code-server.service /etc/systemd/system/</span><br></pre></td></tr></table></figure><ul><li>如果后面修改 /etc/systemd/system/code-server.service</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h1>管理服务</h1><ul><li>启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start code-server</span><br></pre></td></tr></table></figure><ul><li>查看</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status code-server</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之systemctl</title>
      <link href="/posts/5154c07a.html"/>
      <url>/posts/5154c07a.html</url>
      
        <content type="html"><![CDATA[<h1>概念</h1><ul><li>systemd<br>systemd是与SysV和LSB初始化脚本兼容的系统和服务管理器,开启systemd服务,可以基于守护进程按需启动策略<br>systemd服务支持快照和系统状态恢复,维护挂载和自动挂载点,服务之间的从属关系也有逻辑控制</li><li>systemd unit<br>system服务的开启和监督系统是基于unit的,unit就是一个与配置文件对应的名称和类型组成,unit的类型如下</li></ul><ol><li>service unit 系统服务</li><li>Target unit 一组systemd units</li><li>Automount unit 文件系统挂载点</li><li>Device unit  内核识别的设备文件</li><li>Mount unit   文件系统挂载点</li><li>Path unit    一个文件系统中的文件或目录</li><li>Scope unit  外部创建的进程</li><li>Snapshot unit   systemd manager  的保存状态</li></ol><ul><li>systemd的特性</li></ul><ol><li>更快的启动速度</li><li>按需启动能力</li><li>采用cgroup特性跟踪和管理进程的生命周期</li><li>采用挂载点和自动挂载的管理</li><li>实现事务依赖性关系管理</li><li>与SysV初始化脚本兼容</li><li>对系统进程快照和恢复</li></ol><h1>管理服务</h1><p>用systemctl命令管理进行 运行 启动 重启 显示 自启动 关闭自启动 等</p><h1>基操</h1><h2 id="显示运行的服务">显示运行的服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type service</span><br></pre></td></tr></table></figure><h2 id="显示所有的服务">显示所有的服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type service --all</span><br></pre></td></tr></table></figure><h2 id="查看服务状态">查看服务状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status httpd</span><br></pre></td></tr></table></figure><ul><li>显示指标<br>loaded: 说明服务是否被加载,同时显示对应的绝对路径是否启用<br>active: 是否运行<br>main pid: 进程pid<br>cgroup: 相关控制组的其他信息</li></ul><h2 id="管理服务的基操">管理服务的基操</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start sshd</span><br><span class="line">systemctl stop  sshd</span><br><span class="line">systemctl restart sshd</span><br><span class="line">systemctl enable sshd</span><br><span class="line">systemctl disable sshd</span><br></pre></td></tr></table></figure><h2 id="操作系统电源">操作系统电源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl poweroff  #关闭系统,下电</span><br><span class="line">systemctl halt      #关闭系统,不下电</span><br><span class="line">systemctl reboot    #重启</span><br><span class="line">systemctl suspend   #待机</span><br><span class="line">systemctl hibernate  #休眠</span><br><span class="line">systemctl hybrid-sleep #待机+休眠</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码安装软件</title>
      <link href="/posts/15a364b4.html"/>
      <url>/posts/15a364b4.html</url>
      
        <content type="html"><![CDATA[<h1>R系安装软件的2种方式</h1><ul><li>rpm包安装</li><li>编译安装软件</li></ul><h1>为什么用源码安装</h1><ol><li>rpm包版本太旧,官方的新包还没有出来,使用源码编译安装可以解决业务问题</li><li>rpm包安装的软件缺少某些功能</li><li>优化编译参数提升性能,兼容性好</li><li>但是过程繁琐,可能缺少其他依赖包</li></ol><h1>简易源码安装步骤</h1><ol><li>下载源码包,检查包的完整性并解压</li><li>查看README或者install文件,里面是安装方法</li><li>使用./configure命令生成Makefile文件</li><li>编译 make</li><li>安装 make install,默认路径/usr/local</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码安装步骤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之dnf</title>
      <link href="/posts/a36cc04b.html"/>
      <url>/posts/a36cc04b.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>DNF:Dandified YUM,是基于RPM的Linux发行版的软件包管理器,它用于在 Fedora / RHEL / CentOS操作系统中安装,更新和删除软件包,目前 DNF 命令和yum命令相互兼容,软件包仓库依旧使用 YUM 仓库。</p><h1>注意</h1><p>dnf和yum的基础命令都是兼容的,但是dnf默认安装了很多插件,后会出一个插件的学习记录</p><h1>配置dnf</h1><ul><li>dnf主要配置文件<br>/etc/dnf/dnf.conf<br>在rockylinux和centos9stream系统中/etc/yum.conf是指向dnf.conf的软链接,内容如下</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">installonly_limit</span>=<span class="number">3</span></span><br><span class="line"><span class="attr">clean_requirements_on_remove</span>=<span class="literal">True</span></span><br><span class="line"><span class="attr">best</span>=<span class="literal">True</span></span><br><span class="line"><span class="attr">skip_if_unavailable</span>=<span class="literal">False</span></span><br></pre></td></tr></table></figure><p>参数说明</p><ol><li>cachedir:缓存目录,存储rpm包和数据库文件(默认没写,在其他路径)</li><li>best: 升级包的时候总是尝试安装最高版本,如果最高不能装就停止并显示原因</li><li>installonly_limit: 同时安装&quot;installonlypkgs&quot; 指令列出包的数量,默认3,不建议降低</li><li>clean_requirements_on_remove:删除dnf remove期间不在使用的依赖项,即是dnf连带安装的依赖,只能通过此参数为true来删除</li></ol><h1>设置仓库</h1><h2 id="修改dnf源文件">修改dnf源文件</h2><p>还是修改/etc/yum.repos.d下面的repo文件,配置和yum一样</p><h2 id="创建本地源仓库">创建本地源仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install createrepo</span><br></pre></td></tr></table></figure><ul><li>将软件包放在该目录下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createrepo --database /mnt/test </span><br></pre></td></tr></table></figure><h2 id="命令添加源">命令添加源</h2><p>会在/etc/yum.repo.d下生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --add-repo repo_url</span><br></pre></td></tr></table></figure><h1>查看源</h1><ul><li>查看本机配置的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf repolist</span><br></pre></td></tr></table></figure><ul><li>查看具体的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf repolist base</span><br></pre></td></tr></table></figure><h1>启停源</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --set-enable repo_name</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --set-disable repo_name</span><br></pre></td></tr></table></figure><h1>基操</h1><p>基本没yum没有区别</p><ul><li>查</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf search ssh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf provides ssh</span><br></pre></td></tr></table></figure><ul><li>列举安装的包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf list all</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf list openssh</span><br></pre></td></tr></table></figure><ul><li>查看包的信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf info openssh</span><br></pre></td></tr></table></figure><h1>光下载不安装</h1><p>这是一个dnf插件实现的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf download package_name</span><br></pre></td></tr></table></figure><h1>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install httpd</span><br></pre></td></tr></table></figure><h1>卸载软件包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf remove httpd</span><br></pre></td></tr></table></figure><h1>列出详细的组信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf  groups info &quot;开发工具&quot;</span><br></pre></td></tr></table></figure><h1>安装卸载软件包组</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf groups install 软件包组/id</span><br><span class="line">dnf groups remove 软件包组/id</span><br></pre></td></tr></table></figure><h1>检查更新</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf check-update</span><br></pre></td></tr></table></figure><h1>升级软件包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf update</span><br></pre></td></tr></table></figure><h1>升级单独的</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf update 包名</span><br></pre></td></tr></table></figure><h1>升级组</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf group update group_name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之xz</title>
      <link href="/posts/2307c602.html"/>
      <url>/posts/2307c602.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>用来压缩文件的命令</p><h1>用法</h1><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -Jcf a.tar.xz  shell/</span><br></pre></td></tr></table></figure><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xz -z a.txt</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -Jxf a.tar.xz</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xz -d  a.tar.xz</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之zip</title>
      <link href="/posts/e416da7.html"/>
      <url>/posts/e416da7.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>日常工作中,我们在linux发行版直接一般不用zip,但为了和windows一起分享资料,可以用zip打包</p><h1>压缩</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip a.zip  shell/</span><br></pre></td></tr></table></figure><h1>解压</h1><p>unzip a.zip</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之bizp2</title>
      <link href="/posts/29735a96.html"/>
      <url>/posts/29735a96.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>解压缩的,不能压缩文件夹</p><h1>用法</h1><ul><li>压缩<br>效果是源文件不见了，多了一个a.txt.bz2</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 a.txt</span><br></pre></td></tr></table></figure><ul><li>覆盖原文件压缩<br>如果当前目录下存在一样的文件，强制覆盖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -f a.txt</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -dv a.txt.bz2</span><br></pre></td></tr></table></figure><ul><li>模拟解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -tv a.txt.bz2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之gzip</title>
      <link href="/posts/eda8d2e4.html"/>
      <url>/posts/eda8d2e4.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>可以压缩文件节省磁盘 60%~70%的压缩率,但不能压文件夹</p><h1>操作</h1><ul><li>压缩文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -v a.txt</span><br></pre></td></tr></table></figure><ul><li>解压文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dv  a.txt.gz</span><br></pre></td></tr></table></figure><ul><li>列出压缩文件内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -l a.txt.gz</span><br></pre></td></tr></table></figure><ul><li>递归压缩(不是压缩文件,是分别压缩文件夹下的文件)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -r shell/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之at</title>
      <link href="/posts/5fbf421d.html"/>
      <url>/posts/5fbf421d.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>额,暂时没用到,一次性的定时任务</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fcitx码表</title>
      <link href="/posts/80826a5.html"/>
      <url>/posts/80826a5.html</url>
      
        <content type="html"><![CDATA[<h1>生成码表txt文件(罗马字符为例子)</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim test.txt</span><br></pre></td></tr></table></figure><p>加入如下内容</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;fcitx Version 0x03 Table file</span><br><span class="line"><span class="attribute">KeyCode</span>=abcdefghijklmnopqrstuvwxy</span><br><span class="line"><span class="attribute">Length</span>=4</span><br><span class="line"><span class="attribute">Pinyin</span>=@</span><br><span class="line"><span class="attribute">PinyinLength</span>=4</span><br><span class="line"><span class="attribute">Prompt</span>=&amp;</span><br><span class="line"><span class="attribute">ConstructPhrase</span>=^</span><br><span class="line">[Rule]</span><br><span class="line"><span class="attribute">e2</span>=p11+p12+p21+p22</span><br><span class="line"><span class="attribute">e3</span>=p11+p21+p31+p32</span><br><span class="line"><span class="attribute">a4</span>=p11+p21+p31+n11</span><br><span class="line">[Data]</span><br><span class="line">a 工</span><br><span class="line">a 戈</span><br><span class="line">a 或</span><br><span class="line">a 其</span><br><span class="line">aa 式</span><br><span class="line">aa 戒<span class="built_in"></span></span><br><span class="line"><span class="built_in">aaa </span>工</span><br><span class="line">aaaa 工</span><br><span class="line">aaaa 恭恭敬敬</span><br></pre></td></tr></table></figure><h1>转换成码表</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txt2mb test.txt test.mb</span><br></pre></td></tr></table></figure><h1>配置文件的解释</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[CodeTable]</span><br><span class="line">UniqueName=wubi</span><br><span class="line">Name=Wubi</span><br><span class="line">Name[bo_CN]=སྨྱུག་རིམ་ཡིག་གཟུགས།</span><br><span class="line">Name[ca]=Wubi</span><br><span class="line">Name[da]=Wubi</span><br><span class="line">Name[de]=Wubi</span><br><span class="line">Name[en]=Wubi</span><br><span class="line">Name[ja]=Wubi</span><br><span class="line">Name[ko]=Wubi</span><br><span class="line">Name[ru]=Уби (Wubi)</span><br><span class="line">Name[ug_CN]=ۋۇبى خەت شەكلى</span><br><span class="line">Name[zh_CN]=五笔字型</span><br><span class="line">Name[zh_HK]=五筆字型</span><br><span class="line">Name[zh_TW]=五筆字型</span><br><span class="line">IconName=wubi</span><br><span class="line">File=wbx.mb                    # 码表文件名称，一般不动</span><br><span class="line">AdjustOrder=AdjustNo            # 自动调频</span><br><span class="line">Priority=10</span><br><span class="line">UsePY=True                     # 万能键</span><br><span class="line">PYKey=z</span><br><span class="line">AutoSend=-1                 　  #　 自动上屏</span><br><span class="line">NoneMatchAutoSend=1            #　空码自动上屏</span><br><span class="line">UseMatchingKey=True</span><br><span class="line">MatchingKey=z</span><br><span class="line">AutoPhrase=True</span><br><span class="line">AutoPhraseLength=4</span><br><span class="line">AutoPhrasePhrase=True</span><br><span class="line">SaveAutoPhrase=3</span><br><span class="line">ExactMatch=False</span><br><span class="line">PromptTableCode=False     # 编码提示</span><br><span class="line">Symbol=zzzz</span><br><span class="line">Enabled=True</span><br><span class="line">LangCode=zh_CN</span><br><span class="line">NoMatchDontCommit=True</span><br><span class="line">SimpleCodeOrderLevel=2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> fcitx输入法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fcitx输入法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之dos2unix</title>
      <link href="/posts/816f4133.html"/>
      <url>/posts/816f4133.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>由于windows上文件的结束符和linux上的不同，那么在windows上编写的文件或者是脚本在Linux上就会遇到类似于下面的错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh^M: bad interpreter: No such file or directory</span><br></pre></td></tr></table></figure><h1>使用方法</h1><h2 id="转换单个文件">转换单个文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dos2unix demo.sh</span><br></pre></td></tr></table></figure><h2 id="转换多个文件">转换多个文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.sh&quot; | xargs dos2unix</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之lscpu</title>
      <link href="/posts/52a81fc0.html"/>
      <url>/posts/52a81fc0.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>查看cpu信息</p><h1>lscpu输出</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Architecture:          x86_64 <span class="comment">#架构，这里的64指的位处理器</span></span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit <span class="comment">#CPU支持的模式：32位、64位</span></span><br><span class="line">Byte Order:            Little Endian <span class="comment">#字节排序的模式，常用小端模式</span></span><br><span class="line">CPU(s):                2 <span class="comment">#逻辑CPU数量</span></span><br><span class="line">On-line CPU(s) list:   0,1 <span class="comment">#在线的cpu数量 有些时候为了省电或者过热的时候，某些CPU会停止运行</span></span><br><span class="line">Thread(s) per core:    2 <span class="comment">#每个核心支持的线程数</span></span><br><span class="line">Core(s) per socket:    1 <span class="comment">#每颗物理cpu的核数</span></span><br><span class="line">Socket(s):             1 <span class="comment">#主板上插CPU的槽的数量，即物理cpu数量</span></span><br><span class="line">NUMA node(s):          1</span><br><span class="line">Vendor ID:             GenuineIntel <span class="comment">#cpu厂商ID</span></span><br><span class="line">CPU family:            6 <span class="comment">#CPU系列</span></span><br><span class="line">Model:                 85 <span class="comment">#CPU型号</span></span><br><span class="line">Model name:            Intel(R) Xeon(R) Gold 6271C CPU @ 2.60GHz</span><br><span class="line">Stepping:              7</span><br><span class="line">CPU MHz:               2593.906 <span class="comment">#cpu主频</span></span><br><span class="line">BogoMIPS:              5187.81 <span class="comment">#MIPS是每秒百万条指令,Bogo是Bogus(伪)的意思，这里是估算MIPS值</span></span><br><span class="line">Hypervisor vendor:     KVM  <span class="comment">#cpu支持的虚拟化技术</span></span><br><span class="line">Virtualization type:   full</span><br><span class="line">L1d cache:             32K <span class="comment">#一级高速缓存 dcache 用来存储数据</span></span><br><span class="line">L1i cache:             32K <span class="comment">#一级高速缓存 icache 用来存储指</span></span><br><span class="line">L2 cache:              1024K <span class="comment">#二级缓存</span></span><br><span class="line">L3 cache:              33792K <span class="comment">#三级缓存 缓存速度上 L1 &gt; L2 &gt; L3 &gt; DDR(内存)</span></span><br><span class="line">NUMA node0 CPU(s):     0,1</span><br><span class="line">Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat umip pku ospke avx512_vnni spec_ctrl</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpuinfo</title>
      <link href="/posts/f7ef0533.html"/>
      <url>/posts/f7ef0533.html</url>
      
        <content type="html"><![CDATA[<h1>linux查看cpu信息的方式</h1><ul><li>使用命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure><ul><li>查看文件<br>cpuinfo这个文件的输出行数是非常多的,取决于机器cpu的数量配置,对于服务器来说输出可能几百行,但大部分的都是重复的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><h1>cpuinfo示例</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">processor: 0</span><br><span class="line">vendor_id: GenuineIntel</span><br><span class="line">cpu family: 6</span><br><span class="line">model: 85</span><br><span class="line">model name: Intel(R) Xeon(R) Gold 6271C CPU @ 2.60GHz</span><br><span class="line">stepping: 7</span><br><span class="line">microcode: 0x1</span><br><span class="line">cpu MHz: 2593.906</span><br><span class="line">cache size: 33792 KB</span><br><span class="line">physical id: 0</span><br><span class="line">siblings: 2</span><br><span class="line">core id: 0</span><br><span class="line">cpu cores: 1</span><br><span class="line">apicid: 0</span><br><span class="line">initial apicid: 0</span><br><span class="line">fpu: yes</span><br><span class="line">fpu_exception: yes</span><br><span class="line">cpuid level: 13</span><br><span class="line">wp: yes</span><br><span class="line">flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat umip pku ospke avx512_vnni spec_ctrl</span><br><span class="line">bogomips: 5187.81</span><br><span class="line">clflush size: 64</span><br><span class="line">cache_alignment: 64</span><br><span class="line">address sizes: 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br><span class="line"></span><br><span class="line">processor: 1</span><br><span class="line">vendor_id: GenuineIntel</span><br><span class="line">cpu family: 6</span><br><span class="line">model: 85</span><br><span class="line">model name: Intel(R) Xeon(R) Gold 6271C CPU @ 2.60GHz</span><br><span class="line">stepping: 7</span><br><span class="line">microcode: 0x1</span><br><span class="line">cpu MHz: 2593.906</span><br><span class="line">cache size: 33792 KB</span><br><span class="line">physical id: 0</span><br><span class="line">siblings: 2</span><br><span class="line">core id: 0</span><br><span class="line">cpu cores: 1</span><br><span class="line">apicid: 1</span><br><span class="line">initial apicid: 1</span><br><span class="line">fpu: yes</span><br><span class="line">fpu_exception: yes</span><br><span class="line">cpuid level: 13</span><br><span class="line">wp: yes</span><br><span class="line">flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat umip pku ospke avx512_vnni spec_ctrl</span><br><span class="line">bogomips: 5187.81</span><br><span class="line">clflush size: 64</span><br><span class="line">cache_alignment: 64</span><br><span class="line">address sizes: 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br></pre></td></tr></table></figure><h1>字符解释</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">processor: 0 <span class="comment">#系统中逻辑处理核心数的编号，从0开始排序</span></span><br><span class="line">vendor_id: GenuineIntel <span class="comment">#CPU制造商</span></span><br><span class="line">cpu family: 6 <span class="comment">#CPU产品系列代号</span></span><br><span class="line">model: 85 <span class="comment">#CPU属于其系列中的哪一代的代号</span></span><br><span class="line">model name: Intel(R) Xeon(R) Gold 6271C CPU @ 2.60GHz <span class="comment">#CPU属于的名字及其编号、标称主频</span></span><br><span class="line">stepping: 7 <span class="comment">#CPU属于制作更新版本</span></span><br><span class="line">microcode: 0x1 <span class="comment">#CPU微代码</span></span><br><span class="line">cpu MHz: 2593.906 <span class="comment">#CPU的实际使用主频</span></span><br><span class="line">cache size: 33792 KB <span class="comment">#CPU二级缓存大小</span></span><br><span class="line">physical id: 0 <span class="comment">#单个物理CPU的标号</span></span><br><span class="line">siblings: 2 <span class="comment">#单个物理CPU的逻辑CPU数。siblings=cpu cores [*2]</span></span><br><span class="line">core id: 0 <span class="comment">#当前物理核在其所处CPU中的编号，这个编号不一定连续</span></span><br><span class="line">cpu cores: 1 <span class="comment">#该逻辑核所处CPU的物理核数。比如此处cpu cores 是4个，那么对应core id 可能是 1、3、4、5</span></span><br><span class="line">apicid: 0 <span class="comment">#用来区分不同逻辑核的编号，系统中每个逻辑核的此编号必然不同，此编号不一定连续</span></span><br><span class="line">initial apicid: 0 <span class="comment">#我不知道</span></span><br><span class="line">fpu: yes <span class="comment">#是否具有浮点运算单元</span></span><br><span class="line">fpu_exception: yes <span class="comment">#是否支持浮点计算异常</span></span><br><span class="line">cpuid level: 13 <span class="comment">#执行cpuid指令前，eax寄存器中的值，根据不同的值cpuid指令会返回不同的内容</span></span><br><span class="line">wp: yes <span class="comment">#表明当前CPU是否在内核态支持对用户空间的写保护</span></span><br><span class="line">flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat umip pku ospke avx512_vnni spec_ctrl <span class="comment">#当前CPU支持的功能</span></span><br><span class="line">bogomips: 5187.81 <span class="comment">#在系统内核启动时粗略测算的CPU速度</span></span><br><span class="line">clflush size: 64 <span class="comment">#每次刷新缓存的大小单位</span></span><br><span class="line">cache_alignment: 64 <span class="comment">#缓存地址对齐单位</span></span><br><span class="line">address sizes: 46 bits physical, 48 bits virtual <span class="comment">#可访问地址空间位数</span></span><br><span class="line">power management: <span class="comment">#对能源管理的支持</span></span><br></pre></td></tr></table></figure><h1>cpu数量的计算</h1><ul><li>物理CPU数(physical id)<br>就是处理器的实际数量,一颗还是两颗(你肉眼看得见的那个)</li><li>CPU核心数(cpu cores)<br>单块CPU上面能处理数据的芯片组的数量，如双核、四核等</li><li>计算<br>总核数 = 物理CPU个数 * 每颗物理CPU的核数<br>总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 配置解释 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置解释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lvm操作</title>
      <link href="/posts/93b16f73.html"/>
      <url>/posts/93b16f73.html</url>
      
        <content type="html"><![CDATA[<h1>lvm是什么</h1><p>想要随着实际需求的变化调整硬盘分区的大小时，会受到硬盘的限制。这时就需要用到另外一项非常普及的硬盘设备资源管理技术了—LVM（逻辑卷管理器）,LVM 可以允许用户对硬盘资源进行动态调整,LVM 技术是在硬盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行卷组合并,用户不必关心物理硬盘设备的低层架构和布局，就可以实现对硬盘分区的动态调整</p><h1>几个概念</h1><ul><li>物理卷<br>PV(Physical Volume)是LVM的最底层概念</li><li>卷组<br>VG(Volume Group)是LVM概念上的磁盘设备,通过将单个或者多个物理卷组合生成卷组,卷组的大小又物理卷的容量和个数决定</li><li>物理长度<br>PE(Physical Extent)是将物理卷组成卷组之后划分的最小存储单位,默认大小是4MB</li><li>逻辑卷<br>LV(Logical Volume)是逻辑意义上的分区,可以指定从卷组中提取多少容量来创建逻辑卷并格式化和挂载</li></ul><h1>创建LVM分区</h1><h2 id="创建之前首先要查看磁盘设备">创建之前首先要查看磁盘设备</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk  </span><br></pre></td></tr></table></figure><p>可以看到如下,其中sdb是新插入的磁盘</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME              MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda                 8:0    0   30G  0 disk </span><br><span class="line">├─sda1              8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2              8:2    0   29G  0 part </span><br><span class="line">  ├─kylinsec-root 253:0    0   26G  0 lvm  /</span><br><span class="line">  └─kylinsec-swap 253:1    0    3G  0 lvm  <span class="section">[SWAP]</span></span><br><span class="line">sdb                 8:16   0    1G  0 disk </span><br><span class="line">sr0                11:0    1 1024M  0 rom  </span><br></pre></td></tr></table></figure><h2 id="创建物理卷">创建物理卷</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/sdb</span><br></pre></td></tr></table></figure><h2 id="创建卷组">创建卷组</h2><p>使用sdb硬盘,创建出一块名为<code>test_vg</code>的卷组设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgcreate test_vg /dev/sdb</span><br></pre></td></tr></table></figure><h2 id="创建逻辑卷">创建逻辑卷</h2><p>在已有的卷组中（test_vg）创建一个逻辑卷（home_nice），大小为400M</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvcreate  -n  home_kylin -L 400M  test_vg</span><br></pre></td></tr></table></figure><p>如果需要使用所有的空间可以这么写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvcreate  -n  home_kylin -l +100%FREE  test_vg</span><br></pre></td></tr></table></figure><h2 id="格式化逻辑卷">格式化逻辑卷</h2><p>首先需要获取逻辑卷的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -p</span><br></pre></td></tr></table></figure><p>其中<code>/dev/mapper/test_vg-home_kylin</code>是刚创建的逻辑卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lsblk -p的信息</span> </span><br><span class="line">NAME                            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">/dev/sda                          8:0    0   30G  0 disk </span><br><span class="line">├─/dev/sda1                       8:1    0    1G  0 part /boot</span><br><span class="line">└─/dev/sda2                       8:2    0   29G  0 part </span><br><span class="line">  ├─/dev/mapper/kylinsec-root   253:0    0   26G  0 lvm  /</span><br><span class="line">  └─/dev/mapper/kylinsec-swap   253:1    0    3G  0 lvm  [SWAP]</span><br><span class="line">/dev/sdb                          8:16   0    1G  0 disk </span><br><span class="line">└─/dev/mapper/test_vg-home_kylin 253:2    0  400M  0 lvm  </span><br><span class="line">/dev/sr0                         11:0    1 1024M  0 rom  </span><br></pre></td></tr></table></figure><h2 id="使用mkfs进行格式化">使用mkfs进行格式化</h2><p>示例中使用的是ext4文件系统,还可以选择xfs等其他文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/mapper/test_vg-home_kylin</span><br></pre></td></tr></table></figure><h2 id="挂载磁盘到系统">挂载磁盘到系统</h2><p>提供了2种方式,推荐使用<code>永久挂载</code>方式</p><h3 id="临时挂载磁盘">临时挂载磁盘</h3><h4 id="创建一个临时的目录">创建一个临时的目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/kylin</span><br></pre></td></tr></table></figure><h4 id="挂载逻辑卷">挂载逻辑卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/mapper/test_vg-home_kylin  /home/kylin</span><br></pre></td></tr></table></figure><h4 id="查看挂载信息">查看挂载信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -Th</span><br></pre></td></tr></table></figure><p>挂载的信息如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件系统                       容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/kylinsec-root       26G  7.0G   18G   29% /</span><br><span class="line">devtmpfs                       1.9G     0  1.9G    0% /dev</span><br><span class="line">tmpfs                          2.0G     0  2.0G    0% /dev/shm</span><br><span class="line">tmpfs                          2.0G   13M  2.0G    1% /run</span><br><span class="line">tmpfs                          2.0G     0  2.0G    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                      976M  198M  712M   22% /boot</span><br><span class="line">tmpfs                          393M   28K  393M    1% /run/user/0</span><br><span class="line">/dev/mapper/test_vg-home_kylin  380M  2.3M  354M    1% /home/data</span><br></pre></td></tr></table></figure><h3 id="将磁盘永久挂载到系统">将磁盘永久挂载到系统</h3><h4 id="修改-etc-fstab文件">修改/etc/fstab文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure><ul><li>方法1：使用路径挂载<br>在/etc/fstab最后加入,其中ext4是文件系统类型,需要和格式化(mkfs)时的保持一致</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/mapper/test_vg-home_kyin   /home/kylin        ext4    defaults        1 1</span><br></pre></td></tr></table></figure><ul><li>方法2：使用UUID挂载<br>使用blkid查看磁盘的UUID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid</span><br></pre></td></tr></table></figure><p>结果如下（只截取了需要的内容）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/mapper/test_vg-home_kylin: UUID=&quot;e98054f6-b74b-49fb-9c9d-04fd53c831b0&quot; TYPE=&quot;ext4&quot; </span><br></pre></td></tr></table></figure><p>将/dev/mapper/test_vg-home_kylin的UUID值加入就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=e98054f6-b74b-49fb-9c9d-04fd53c831b0   /        ext4    defaults        1 1</span><br></pre></td></tr></table></figure><p>验证fstab修改是否正确,如果已经临时挂载了,需要先将挂载的磁盘umount,才能验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a</span><br></pre></td></tr></table></figure><h1>删除lvm分区</h1><h2 id="卸载需要删除的分区">卸载需要删除的分区</h2><p>删除磁盘前需要确认已经umount，否则会失败,查看分区和挂载点信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><p>挂载点信息如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件系统                        容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/kylinsec-root        26G  7.1G   18G   30% /</span><br><span class="line">/dev/sda1                       976M  198M  712M   22% /boot</span><br><span class="line">/dev/mapper/test_vg-home_kylin  380M  2.3M  354M    1% /home/kylin</span><br></pre></td></tr></table></figure><p>首先需要卸载<code>/home/kylin</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /home/kylin</span><br></pre></td></tr></table></figure><h2 id="查看逻辑卷信息">查看逻辑卷信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvdisplay</span><br></pre></td></tr></table></figure><p>只截取了home_kylin的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--- Logical volume ---</span><br><span class="line">LV Path                /dev/test_vg/home_kylin</span><br><span class="line">LV Name                home_kylin</span><br><span class="line">VG Name                test_vg</span><br><span class="line">LV UUID                bA2Rjo-YS01-vTAd-Ze1f-DdwP-lvaf-ugZt7N</span><br><span class="line">LV Write Access        read/write</span><br><span class="line">LV Creation host, time ceshi, 2022-05-31 10:08:19 +0800</span><br><span class="line">LV Status              available</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">open                 1</span></span><br><span class="line">LV Size                400.00 MiB</span><br><span class="line">Current LE             100</span><br><span class="line">Segments               1</span><br><span class="line">Allocation             inherit</span><br><span class="line">Read ahead sectors     auto</span><br><span class="line">- currently set to     8192</span><br><span class="line">Block device           253:2</span><br></pre></td></tr></table></figure><h2 id="使用lvremove删除此分区">使用lvremove删除此分区</h2><p>lvremove 后面接的是LV Path对应的名字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvremove  /dev/test_vg/home_kylin</span><br></pre></td></tr></table></figure><p>确认/etc/fstab是否有相关的信息,将与这块磁盘的信息删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/fstab</span><br></pre></td></tr></table></figure><h1>对lvm分区扩容</h1><h2 id="查看空闲空间">查看空闲空间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgdisplay</span><br></pre></td></tr></table></figure><p>内容如下,可以看出Free PE有3839块，其中一块pe是4m，那么Free Pe的大小就是3839*4=15356m</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--- Volume group ---</span><br><span class="line"> VG Name               vg_test</span><br><span class="line"> System ID             </span><br><span class="line"> Format                lvm2</span><br><span class="line"> Metadata Areas        1</span><br><span class="line"> Metadata Sequence No  2</span><br><span class="line"> VG Access             read/write</span><br><span class="line"> VG Status             resizable</span><br><span class="line"> MAX LV                0</span><br><span class="line"> Cur LV                1</span><br><span class="line"> Open LV               1</span><br><span class="line"> Max PV                0</span><br><span class="line"> Cur PV                1</span><br><span class="line"> Act PV                1</span><br><span class="line"> VG Size               &lt;20.00 GiB</span><br><span class="line"> PE Size               4.00 MiB</span><br><span class="line"> Total PE              5119</span><br><span class="line"> Alloc PE / Size       1280 / 5.00 GiB</span><br><span class="line"> Free  PE / Size       3839 / &lt;15.00 GiB</span><br><span class="line"> VG UUID               GDHYHs-f1Yd-vmop-dLWR-VlRQ-h8ju-S5Tkr4</span><br></pre></td></tr></table></figure><h2 id="给vg卷组扩容">给vg卷组扩容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgextend vg_name /dev/sdb</span><br></pre></td></tr></table></figure><h2 id="给具体分区扩容">给具体分区扩容</h2><p>具体分区可以df -Th看出来</p><ul><li>扩指定大小容量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvextend -L +200M /dev/mapper/vg_home</span><br></pre></td></tr></table></figure><ul><li>也可以把所有的给他</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvextend -l +<span class="number">100</span>%FREE <span class="regexp">/dev/m</span>apper/vg_home</span><br></pre></td></tr></table></figure><h1>对lvm分区缩小容量(不建议)</h1>]]></content>
      
      
      <categories>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之git</title>
      <link href="/posts/1dd2999d.html"/>
      <url>/posts/1dd2999d.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理,也是Linus Torvalds(大佬)为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件#</p><h1>先说一个坑</h1><p>千万不要用windows来开发shell脚本,就算是要开发也要用好空格(LF),不然到linux就是会报错的,所以用git的时候会将你的代码上传到云端的库,这样别人用的时候要是遇到这个坑心态可能崩溃</p><h1>开局操作</h1><h2 id="个人信息">个人信息</h2><p>接下来要和平台进行联动,所以要配置一下自己的信息,才能代表你是你</p><ul><li>用户名</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;dddachui&quot;</span><br></pre></td></tr></table></figure><ul><li>email</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;xx@xx.com&quot;</span><br></pre></td></tr></table></figure><h2 id="查看配置">查看配置</h2><ul><li>查看当前配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><ul><li>查看全局配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list --global</span><br></pre></td></tr></table></figure><ul><li>查看系统配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure><h1>正常开局方法</h1><h2 id="初始化仓库">初始化仓库</h2><p>可以用git创建出一个目录，也可以使用一个现有的文件夹做为repo</p><ul><li>指定一个目录作为仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init newrepo  </span><br></pre></td></tr></table></figure><ul><li>又或者是在当前目录下初始化</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">init</span></span><br></pre></td></tr></table></figure><h2 id="添加新文件">添加新文件</h2><p>在仓库编辑保存之后git就会跟踪,此时要把文件提交暂存区,一般是不会输出什么的,不输出就是好事</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add filename</span><br></pre></td></tr></table></figure><h2 id="提交版本">提交版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;写点注释划划水&quot;</span><br></pre></td></tr></table></figure><h2 id="和远端仓库玩耍">和远端仓库玩耍</h2><ul><li>设置远端仓库地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin http://ip:port/username/项目</span><br></pre></td></tr></table></figure><ul><li>推送</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="克隆仓库">克隆仓库</h2><p>一般用于将远端的项目拉到本地，或者你电脑坏了换了新的环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git_url</span><br></pre></td></tr></table></figure><h1>分支</h1><ul><li>查看当前分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><ul><li>创建分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br></pre></td></tr></table></figure><ul><li>切换分支</li></ul><pre><code class="language-shell">git branch test</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机容量换算</title>
      <link href="/posts/5cd3a7a8.html"/>
      <url>/posts/5cd3a7a8.html</url>
      
        <content type="html"><![CDATA[<h1>计算机的存储单位</h1><ul><li>bit 比特最小的存储单位</li><li>Byte 字节是计算机信息技术用于计量存储容量的一种计量单位</li><li>KB 千字节</li><li>MB 兆字节</li><li>GB gb也叫吉字节,十亿字节</li><li>TB 太字节</li><li>PB拍字节</li><li>EB 艾字节</li><li>ZB 泽字节</li><li>BB 尧字节</li></ul><h1>换算关系</h1><p>1Byte = 8 Bit<br>1 KB = 1,024 Bytes<br>1 MB = 1,024 KB = 1,048,576 Bytes<br>1 GB = 1,024 MB = 1,048,576 KB = 1,073,741,824 Bytes<br>1 TB = 1,024 GB = 1,048,576 MB = 1,073,741,824 KB = 1,099,511,627,776 Bytes<br>1 PB = 1,024 TB = 1,048,576 GB =1,125,899,906,842,624 Bytes<br>1 EB = 1,024 PB = 1,048,576 TB = 1,152,921,504,606,846,976 Bytes<br>1 ZB = 1,024 EB = 1,180,591,620,717,411,303,424 Bytes<br>1 YB = 1,024 ZB = 1,208,925,819,614,629,174,706,176 Bytes</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之free</title>
      <link href="/posts/9a6f4fde.html"/>
      <url>/posts/9a6f4fde.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>显示系统中可用和已用内存的量</p><h1>输出的结果</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        total       used        free        shared      buff/cache      available</span><br><span class="line">Mem:    1978        399         223          32         1355            1323</span><br><span class="line">Swap:   2047        0           2047</span><br></pre></td></tr></table></figure><h1>分析下每一列的含义</h1><h2 id="total">total</h2><p>是安装的总内存大小,MemTotal和SwapTotal可以在<code>/proc/meminfo</code>中查看</p><h2 id="used">used</h2><p>使用的内存大小</p><p>used=total - free - buffers - cache</p><h2 id="free">free</h2><p>没有使用的内存,Mem free和Swap free可以在<code>/proc/meminfo</code>中查看,真正尚未被使用的物理内存数量</p><h2 id="shared">shared</h2><p>表示进程共享的内存,大部分被tmpfs用了,在<code>/proc/meminfo</code>中查看Shmem</p><h2 id="buff">buff</h2><p>内核缓冲区使用的内存,在<code>/proc/meminfo</code>中查看Buffers</p><h2 id="cache">cache</h2><p>页面缓存和slabs使用的内存,在<code>/proc/meminfo</code>中查看Cached和Slab</p><h2 id="buff-cache">buff/cache</h2><p>buff+cacahe</p><h2 id="available">available</h2><p>估计有多少内存可用于<code>启动新应用程序</code>，而不进行交换,应用程序认为可用内存数量</p><p>available = free + buffer/cache - 不可被回收内存(共享内存段、tmpfs、ramfs等)。</p><h2 id="buffers-cache">-buffers/cache</h2><p>表示一个应用程序认为系统被用掉多少内存</p><p>-buffers/cache = used - buffers - cached</p><h2 id="buffers-cache-2">+buffers/cache</h2><p>表示一个应用程序认为系统还有多少内存；<br>+buffers/cache = free + buffers + cached</p><h1>混淆点</h1><h2 id="free和available应该看哪个">free和available应该看哪个</h2><p>Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache,所以对于内核来说，buffer 和 cache 都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，available = free + buffer + cache 这个计算不大可靠,但可以得出这两个是不一样的</p><h1>常用命令</h1><ul><li>free里面以不同单位显示换算是1024哦!</li></ul><h2 id="以Byte显示内存使用情况">以Byte显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -b</span><br></pre></td></tr></table></figure><h2 id="以kb为单位显示内存使用情况">以kb为单位显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -k</span><br></pre></td></tr></table></figure><h2 id="以mb为单位显示内存使用情况">以mb为单位显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><h2 id="以gb为单位显示内存使用情况">以gb为单位显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -g</span><br></pre></td></tr></table></figure><h2 id="持续显示内存">持续显示内存</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -s</span><br></pre></td></tr></table></figure><h2 id="显示内存使用总合">显示内存使用总合</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -t</span><br></pre></td></tr></table></figure><h2 id="以易读的单位显示内存使用情况">以易读的单位显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之md5sum</title>
      <link href="/posts/99132266.html"/>
      <url>/posts/99132266.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>md5sum计算并检查MD5消息摘要</p><h1>常用选项</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-b, --binary       以二进制模式读取文件</span><br><span class="line">-c, --check        从文件中读取MD5的校验值并予以检查</span><br><span class="line">-t, --text   以文本模式读入文件内容</span><br><span class="line">--quiet            只会输出校验不通过的文件</span><br><span class="line">--status           校验完成后，不生成错误或正确的提示信息，可以通过命令的返回值来判断echo $?</span><br><span class="line">--strict           对于格式不正确的校验和行，退出非零</span><br><span class="line">-w, --warn         检查输入的md5信息有没有非法行，若有则输出相应信息</span><br><span class="line">--help   显示此帮助信息并退出</span><br><span class="line">--version   显示版本信息并退出</span><br></pre></td></tr></table></figure><h1>基本用法</h1><h2 id="计算文件的md5">计算文件的md5</h2><p>直接计算文件的md5值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum 文件</span><br></pre></td></tr></table></figure><h2 id="利用md5文件校验">利用md5文件校验</h2><ul><li>计算文件的md5并写入文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum 文件 &gt; file.md5</span><br></pre></td></tr></table></figure><ul><li>使用文件校验<br>如果校验成功会提示,不成功的也会提示</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum -c file.md5</span><br></pre></td></tr></table></figure><h1>其他用法</h1><p>除了直接计算和指定md5文件之外还有其他选项</p><ul><li>计算的时候只输出不符合的文件</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum -c <span class="built_in">file</span>.md5  <span class="comment">--quiet</span></span><br></pre></td></tr></table></figure><ul><li>计算md5之后根据$?来判断是否正确<br>echo $?的返回值0或1</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum -c <span class="built_in">file</span>.md5  <span class="comment">--status</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之pssh</title>
      <link href="/posts/8cf6e4c0.html"/>
      <url>/posts/8cf6e4c0.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>pssh命令是一个python编写可以在多台服务器上执行命令的工具，同时文件的并行复制，杀掉远程主机上的进程等<br>要使用pssh之前,必须配置本地主机和被管理的远程主机之间ssh单向的免秘钥认证,这一点和ansible类似</p><h1>安装</h1><p>配置好软件源之后就可以安装这个工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pssh</span><br></pre></td></tr></table></figure><h1>命令使用</h1><p>安装完pssh之后默认有5个命令</p><ul><li>pssh 在多台远程主机上并行执行命令</li><li>pscp或pscp.pssh 把文件并行复制到多台远程主机上</li><li>pslurp 把文件从多台远程主机上复制到本地</li><li>pnuke 在多台远程主机上并行杀掉某一进程（类似于killall命令）</li><li>prsync 使用rsync协议将文件从本地主机同步到多台远程主机上</li></ul><h2 id="pssh">pssh</h2><p>在多台远程主机上并行执行命令</p><h3 id="常用参数">常用参数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  <span class="comment">--version             显示pssh程序的版本</span></span><br><span class="line">  <span class="comment">--help                显示ssh的命令帮助页面</span></span><br><span class="line">  <span class="operator">-</span>h HOST_FILE, <span class="comment">--hosts=HOST_FILE</span></span><br><span class="line">                        hosts file (每行这么写root<span class="variable">@192</span><span class="number">.168</span><span class="number">.42</span><span class="number">.10</span>:<span class="number">22</span>即[<span class="keyword">user</span>@]host[:port])</span><br><span class="line">  <span class="operator">-</span>H HOST_STRING, <span class="comment">--host=HOST_STRING</span></span><br><span class="line">                        主机字符串(root<span class="variable">@192</span><span class="number">.168</span><span class="number">.42</span><span class="number">.10</span>:<span class="number">22</span>即[<span class="keyword">user</span>@]host[:port])</span><br><span class="line">  <span class="operator">-</span>l <span class="keyword">USER</span>, <span class="comment">--user=USER  远程机器的用户名</span></span><br><span class="line">  <span class="operator">-</span>p PAR, <span class="comment">--par=PAR     一次最大允许多少连接</span></span><br><span class="line">  <span class="operator">-</span>o OUTDIR, <span class="comment">--outdir=OUTDIR</span></span><br><span class="line">                        将输出的内容保持到指定文件中</span><br><span class="line">  <span class="operator">-</span>e ERRDIR, <span class="comment">--errdir=ERRDIR</span></span><br><span class="line">                        错误文件的输出路径</span><br><span class="line">  <span class="operator">-</span>t TIMEOUT, <span class="comment">--timeout=TIMEOUT</span></span><br><span class="line">                        TIMEOUT 超时时间设置，<span class="number">0</span>是无限制</span><br><span class="line">  <span class="operator">-</span>O OPTION, <span class="comment">--option=OPTION</span></span><br><span class="line">                        设置ssh参数的具体配置，参照ssh_config配置文件</span><br><span class="line">  <span class="operator">-</span>v, <span class="comment">--verbose         详细模式</span></span><br><span class="line">  <span class="operator">-</span>A, <span class="comment">--askpass         提示输入密码并且把密码传递给ssh（注意这个参数添加后只是提示作用，随便输入或者不输入直接回车都可以）</span></span><br><span class="line">  <span class="operator">-</span>x ARGS, <span class="comment">--extra-args=ARGS</span></span><br><span class="line">                        传递多个SSH 命令，多个命令用空格分开，用引号括起来</span><br><span class="line">  <span class="operator">-</span>X ARG, <span class="comment">--extra-arg=ARG</span></span><br><span class="line">                        同<span class="operator">-</span>x 但是一次只能传递一个命令</span><br><span class="line">  <span class="operator">-</span>i, <span class="comment">--inline          显示命令执行的标准输出和错误输出</span></span><br><span class="line">  <span class="comment">--inline-stdout       inline standard output for each server</span></span><br><span class="line">  <span class="operator">-</span>I, <span class="comment">--send-input      从标准输入读取并作为输入发送到 ssh</span></span><br><span class="line">  <span class="operator">-</span>P, <span class="comment">--print           显示命令结果</span></span><br></pre></td></tr></table></figure><h3 id="操作单个主机">操作单个主机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -H root@yun -P uptime</span><br></pre></td></tr></table></figure><p>输入结果如下,会显示yun这个机器的执行结果,并反馈执行的状态</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:  21:26:50 up  6:56,  5 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line"><span class="section">[1]</span> 21:26:50 <span class="section">[SUCCESS]</span> 127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="操作多台主机">操作多台主机</h3><ul><li>首先编写host文件</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@node1:22</span><br><span class="line">root@node2:22</span><br></pre></td></tr></table></figure><ul><li>然后执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -h host -i uptime</span><br></pre></td></tr></table></figure><ul><li>执行结果</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[1]</span> 21:27:32 <span class="section">[SUCCESS]</span> 127.0.0.1</span><br><span class="line"> 21:27:32 up  6:57,  5 users,  load average: 0.08, 0.04, 0.05</span><br><span class="line"><span class="section">[2]</span> 21:27:32 <span class="section">[SUCCESS]</span> yun</span><br><span class="line"> 21:27:32 up 34 days,  7:47,  1 user,  load average: 0.03, 0.04, 0.05</span><br></pre></td></tr></table></figure><h3 id="保存每台运行的结果">保存每台运行的结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -h hosts -i -o /tmp/pssh/ uptime</span><br></pre></td></tr></table></figure><p>执行之后他会将每个主机的执行结果分别存入对应主机名的文件之中</p><h2 id="pscp或pscp-pssh">pscp或pscp.pssh</h2><p>把文件并行复制到多台远程主机上</p><h3 id="常用参数-2">常用参数</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  其他的解释和pssh一致,多了一个-r</span><br><span class="line">  -r, <span class="comment">--recursive       递归复制目录</span></span><br></pre></td></tr></table></figure><h3 id="同步单个文件到多个主机">同步单个文件到多个主机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pscp.pssh -h host /etc/hosts /etc</span><br></pre></td></tr></table></figure><h3 id="同步目录到多个主机">同步目录到多个主机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pscp -h host -r /usr/local/test  /tmp</span><br></pre></td></tr></table></figure><h2 id="pslurp">pslurp</h2><p>把文件并行复制到多台远程主机上</p><h3 id="常用参数-3">常用参数</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其他的解释和pssh一致</span><br><span class="line">-r, <span class="comment">--recursive       递归复制目录</span></span><br><span class="line">-L LOCALDIR, <span class="comment">--localdir=LOCALDIR</span></span><br><span class="line">                      将文件从远程主机复制到给定的本地目录</span><br></pre></td></tr></table></figure><h3 id="拷贝远端到本地">拷贝远端到本地</h3><p>将远端的/etc/hosts拷贝到本地/etc/并改名为hosts(不是很会,感觉会出问题)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pslurp -h host -L /etc/hosts /etc hosts</span><br></pre></td></tr></table></figure><h2 id="pnuke">pnuke</h2><p>在多台远程主机上并行杀掉某一进程（类似于killall命令）</p><h3 id="常用参数-4">常用参数</h3><p>和pssh一致</p><h3 id="杀死远程的nginx">杀死远程的nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnuke -h host nginx</span><br></pre></td></tr></table></figure><h2 id="prsync">prsync</h2><p>使用rsync协议将文件从本地主机同步到多台远程主机上</p><h3 id="常用参数-5">常用参数</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">其他解释一致</span><br><span class="line">-r, <span class="comment">--recursive       递归复制目录</span></span><br><span class="line">-<span class="keyword">a</span>, <span class="comment">--archive         use rsync -a (archive mode) (OPTIONAL)</span></span><br><span class="line">-z, <span class="comment">--compress        use rsync compression (OPTIONAL)</span></span><br><span class="line">-S ARGS, <span class="comment">--ssh-args=ARGS</span></span><br><span class="line">                      extra arguments <span class="keyword">for</span> ssh</span><br></pre></td></tr></table></figure><h3 id="传文件">传文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prsync -h host test.txt /tmp/dir</span><br></pre></td></tr></table></figure><h3 id="传目录">传目录</h3><p>这个得注意下目录…感觉和rsync差不多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prsync -r -h host /data/ /data</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bash和csh的区别</title>
      <link href="/posts/8ac16b70.html"/>
      <url>/posts/8ac16b70.html</url>
      
        <content type="html"><![CDATA[<h1>什么是shell</h1><p>shell是用户和Linux（或者更准确的说，是用户和Linux内核）之间的接口程序。你在提示符下输入的每个命令都由shell先解释然后传给Linux内核。</p><h1>shell的分类</h1><ul><li>sh<br>sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名,现代的 Linux 上，sh 已经被 bash 代替，/bin/sh往往是指向/bin/bash的符号链接</li><li>bash<br>bash 由 GNU 组织开发，保持了对 sh shell 的兼容性，是各种 Linux 发行版默认配置的 shell</li><li>csh<br>sh 之后另一个广为流传的shell是由柏克莱大学的Bill Joy设计的，这个shell 的语法有点类似C语言，所以才得名为C shell,简称为 csh,往往csh也是指向tcsh的链接符号</li><li>tcsh<br>tcsh 是 csh 的增强版，加入了命令补全功能，提供了更加强大的语法支持</li></ul><h1>查看本机支持的shell</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -l</span><br></pre></td></tr></table></figure><h1>查看当前使用的shell</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><h1>csh和bash的语法区别</h1><p>(这个会慢慢更新,区别有点多)</p><h2 id="环境变量定义">环境变量定义</h2><ul><li>bash定义</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=`pwd`                     # =号两边必须无空格,命令转变量也可以用$(pwd)</span><br><span class="line">export b=1                  # 设置环境变量</span><br></pre></td></tr></table></figure><ul><li>csh定义</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set a = `pwd`               # 用关键词 set， = 两边必须有空格,命令转变量只能用``</span><br><span class="line">setenv  b   1               # 设置环境变量</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之ulimit</title>
      <link href="/posts/4501ee1d.html"/>
      <url>/posts/4501ee1d.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>ulimit提供对shell和由它启动的进程可用的资源的控制。<code>ulimit</code>这个命令貌似是bash才可以用的,如果使用的是csh或者tcsh这个命令对应的是limit</p><blockquote><p>man手册:Provides control over the resources available to the shell and to processes started by it, on systems that allow such control.  The -H and -S options specify that the hard or soft limit is set for the given resource. A hard limit cannot be increased by a non-root user once it is set; a soft limit may be increased up to the value of the hard limit.  If neither -H nor -S is specified, both the soft and  hard  limits  are  set.   The  value  of limit can be a number in the unit specified for the resource or one of the special values hard, soft, or unlimited, which stand for the current hard limit, the current soft limit, and no limit, respectively. If limit is omitted, the current value of the soft limit of the resource is printed, unless the -H option is given.</p></blockquote><h1>注意</h1><ol><li>ulimit这个命令是对<code>单一程序</code>的限制,当前终端修改之后生效,但打开其他终端就还是默认的大小</li><li>ulimit主要限制的包括打开文件描述符数量、用户的最大进程数量、coredump文件的大小等,他是一个临时的开关,如果需要重启生效必须在limits.conf设置</li></ol><h1>如何查看当前系统限制</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@dddachui ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 15695</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 65535</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 15695</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><h1>首先分析下ulimit输出的参数是什么</h1><h2 id="core-file-size">core file size</h2><p>限制core文件的大小,默认情况下是0就是没有打开的,使用如下命令快速查看此配置,单位是blocks,一个blocks是1024个字节</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c size</span><br></pre></td></tr></table></figure><h2 id="data-seg-size">data seg size</h2><p>限制进程使用数据段的大小,这个限制会影响程序调用brk(系统调用)和sbrk(库函数)调用malloc,如果发现vm不够了,就会用brk去内核申请,一般不做限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -d size</span><br></pre></td></tr></table></figure><h2 id="scheduling-priority">scheduling priority</h2><p>限制进程优先级的,就是进程的NICE值,scheduling priority默认值为0,这个值只对<code>普通用户</code>起作用,对root用户不起作用,nice值的范围为-20到20,优先级从高到底,-20最高</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -e size</span><br></pre></td></tr></table></figure><h2 id="file-size">file size</h2><p>限制进程产生的文件大小,默认情况不限制,单位是blocks,1个blocks=1kb,如果设置了 100kb,那么将不n创建大于100KB的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -f size</span><br></pre></td></tr></table></figure><h2 id="pending-signals">pending signals</h2><p>主要是表示可以被挂起/阻塞的最大信号数量,linux下信号有64种,可以通过下面的kill查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@dddachui ~]# kill -l</span><br><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL10) SIGUSR1</span><br><span class="line">11) SIGSEGV12) SIGUSR213) SIGPIPE14) SIGALRM15) SIGTERM</span><br><span class="line">16) SIGSTKFLT17) SIGCHLD18) SIGCONT19) SIGSTOP20) SIGTSTP</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGURG24) SIGXCPU25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM27) SIGPROF28) SIGWINCH29) SIGIO30) SIGPWR</span><br><span class="line">31) SIGSYS34) SIGRTMIN35) SIGRTMIN+136) SIGRTMIN+237) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+439) SIGRTMIN+540) SIGRTMIN+641) SIGRTMIN+742) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+944) SIGRTMIN+1045) SIGRTMIN+1146) SIGRTMIN+1247) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+1449) SIGRTMIN+1550) SIGRTMAX-1451) SIGRTMAX-1352) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-1154) SIGRTMAX-1055) SIGRTMAX-956) SIGRTMAX-857) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-659) SIGRTMAX-560) SIGRTMAX-461) SIGRTMAX-362) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-164) SIGRTMAX</span><br></pre></td></tr></table></figure><p>编号为1-31的信号为传统unix支持的信号,是不可靠信号(非实时的),编号为32-64的信号是后来扩充的,称作可靠信号(实时信号)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -i size</span><br></pre></td></tr></table></figure><h2 id="max-locked-memory">max locked memory</h2><p>限制内存锁定,只对<code>普通用户</code>起作用,对root用户不起作用,linux对内存是分页管理的,内存中的数据,当不再需要时,会被从物理内存交换到swap或磁盘上,有需要时会被交换到物理内存,因为内存的换入/换出有一定的性能损耗,所以有时候会需要将数据锁定到物理内存,比如数据库等,或安全角度考虑的,比如用户名、密码等,被交换到swap或磁盘会有泄密的可能,所以一直锁定再内存中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -l size</span><br></pre></td></tr></table></figure><h2 id="max-memory-size">max memory size</h2><p>指定可使用内存的上限,单位为KB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -m size</span><br></pre></td></tr></table></figure><h2 id="open-files">open files</h2><p>打开的文件描述符的最大数量,这个值是针对<code>所有用户</code>的,表示可以在进程中打开文件的数量,默认是1024,但这个默认值太小,经常会遇到<code>Too many open files</code>的问题,但不能光顾着改大参数,还得检查程序是否正常释放资源,产生这个<code>Too many open files</code>问题大多是单进程使用文件句柄超过ulimit -n的值</p><h2 id="pipe-size">pipe size</h2><p>指定管道缓冲区的大小,单位512字节</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -p size</span><br></pre></td></tr></table></figure><h2 id="POSIX-message-queues">POSIX message queues</h2><p>限制可以创建使用POSIX消息队列的大小的,单位是bytes,默认是800KB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -q size</span><br></pre></td></tr></table></figure><h2 id="real-time-priority">real-time priority</h2><p>real-time priority是限制程序实时优先级的范围,只针对普通用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -r size</span><br></pre></td></tr></table></figure><h2 id="stack-size">stack size</h2><p>指定堆叠的上限,单位为KB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -s size</span><br></pre></td></tr></table></figure><h2 id="cpu-time">cpu time</h2><p>指定CPU使用时间的上限,单位为秒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -t size</span><br></pre></td></tr></table></figure><h2 id="max-user-processes">max user processes</h2><p>限制每个用户可以fork的进程数的,这里默认是不限的,而且该参数只对普通用户有效,这个参数影响并发,比如nginx、php-fpm的fork子进程,或者mysql的最大连接数,这个参数,默认情况下是根据系统的threads-max来定的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -u size</span><br></pre></td></tr></table></figure><h2 id="virtual-memory">virtual memory</h2><p>限制进程使用虚拟内存大小,单位是KB,默认是不限制的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -v size</span><br></pre></td></tr></table></figure><h2 id="file-locks">file locks</h2><p>文件锁的限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -x size</span><br></pre></td></tr></table></figure><h1>注意</h1><ol><li>修改时，若不加H或S参数，两个参数一起变改</li><li>查询时，若不加H或S参数，默认显示的是软限制</li></ol><h1>设置ulimit的位置</h1><p>可以在以下位置进行ulimit设置:</p><ol><li>/etc/profile 所有用户有效，永久生效</li><li>~/.bash_profile 当前用户有效，永久生效</li><li>直接在控制台输入 当前用户有效，临时生效</li><li>放在程序的启动脚本中</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux环境变量</title>
      <link href="/posts/289d0c5f.html"/>
      <url>/posts/289d0c5f.html</url>
      
        <content type="html"><![CDATA[<h1>环境变量</h1><p>在Linux登录成功以后，Linux会从文件中获取一系列的数据为该次登录所用，这些数据会在某些指令或某些程序中被使用到。这些数据就称为Linux Shell运行时的环境</p><h1>环境变量分类</h1><ul><li>系统变量<ol><li>/etc/bashrc</li><li>/etc/profile</li><li>/etc/environment</li></ol></li><li>用户变量<ol><li>~/.bashrc</li><li>~/.bash_profile</li></ol></li></ul><h1>测试Linux环境变量加载顺序的方法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;echo --/etc/profile&quot; &gt;&gt;/etc/profile</span><br><span class="line">echo &quot;echo --/etc/profile.d/echo.sh&quot; &gt;&gt;/etc/profile.d/echo.sh</span><br><span class="line">echo &quot;echo --~/.bash_profile&quot; &gt;&gt;~/.bash_profile</span><br><span class="line">echo &quot;echo --~/.bashrc&quot; &gt;&gt;~/.bashrc</span><br><span class="line">echo &quot;echo --/etc/bashrc&quot; &gt;&gt;/etc/bashrc</span><br></pre></td></tr></table></figure><p>然后ssh登陆到本机就会按序输出,这里没有写environment,但毋庸置疑的是environment是第一个加载的,但我不知道怎么表现<br>我的输出结果是</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--<span class="regexp">/etc/</span>profile.d/echo.sh</span><br><span class="line">--<span class="regexp">/etc/</span>profile</span><br><span class="line">--<span class="regexp">/etc/</span>bashrc</span><br><span class="line">--~/.bashrc</span><br><span class="line">--~/.bash_profile</span><br></pre></td></tr></table></figure><h1>环境变量加载顺序</h1><p>系统环境变量 -&gt; 用户自定义环境变量</p><ol><li>/etc/environment<br>是系统在登陆时读取的第一个文件，设置整个系统的环境变量。系统使用此文件并不执行此文件中的命令，而是根据Key=Value模式的代码</li><li>/etc/profile<br>此文件是系统登陆执行的第二个文件，为系统的每个用户设置环境信息。当用户第一次登陆时，该文件执行，并从/etc/profile.d目录中的配置文件搜索shell的设置</li><li>/etc/profile.d/*.sh</li><li>/etc/bashrc<br>这个文件是针对所有用户的bash初始化文件，在此设定中的环境信息将应用与所有用户的shell中，此文件会在用户每次打开shell时执行一次</li><li>~/.bash_profile<br>是交互式login方式进入 bash 运行的</li><li>~/.bashrc<br>该文件用于bash shell的bash信息，当登录时以及每次打开新的shell时，该文件被读取</li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>limits.conf配置</title>
      <link href="/posts/a53b52db.html"/>
      <url>/posts/a53b52db.html</url>
      
        <content type="html"><![CDATA[<h1>limits.conf是什么文件?</h1><blockquote><p>limits.conf - configuration file for the pam_limits module,The pam_limits.so module applies ulimit limits, nice priority and number of simultaneous login sessions limit to user login sessions. This description of the configuration file syntax applies to the /etc/security/limits.conf file and *.conf files in the /etc/security/limits.d directory</p></blockquote><ol><li>limits.conf是限制用户进程可用的各种系统资源的数量,限制着用户可以使用的最大文件数,最大线程,最大内存等资源使用量,但是这个文件不能删除的哦!删除了系统就崩了</li></ol><h1>查看官方文档的解释</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man limits.conf</span><br></pre></td></tr></table></figure><h1>相关名词解释</h1><ul><li>软限制<br>对进程的资源数的限制的当前值(当前系统生效的设置值,警告值),小于等于硬限制,软限制对进程并不是真正的限制,soft不能比hard高</li><li>硬限制<br>进程的资源数的限制的最大值,进程增长资源数不会超过硬限制</li></ul><h1>limits.conf文件组成</h1><p>文件内容由四列组成,如下解释</p><h2 id="domain">domain</h2><ul><li>用户名</li><li>具有@group的组名</li><li>通配符*,用于默认条目</li><li>通配符%,也可以与 %group 语法一起使用，用于 maxlogin 限制</li></ul><h2 id="type">type</h2><ul><li>soft软限制</li><li>hard硬限制</li><li>短杠-</li></ul><h2 id="item">item</h2><h3 id="core">core</h3><p>limits the core file size (KB) : 限制内核文件的大小</p><p>如果其值为 0，则阻止创建核心文件。默认软限制为 0，硬限制为无限制，这意味着允许用户在需要时创建核心转储</p><p>也是在内核include/asm-generic/resource.h中被定义的</p><h3 id="data">data</h3><p>max data size (KB) : 最大数据大小</p><h3 id="fsize">fsize</h3><p>maximum filesize (KB) : 最大文件大小</p><h3 id="memlock">memlock</h3><p>max locked-in-memory address space (KB) : 最大锁定内存地址空间</p><p>是内核include/uapi/linux/resource.h里面定义的,Memlock,进程可以使用mlock锁定内存的最大字节长度,本身在内核中定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * GPG2 wants 64kB of mlocked memory, to make sure pass phrases</span></span><br><span class="line"><span class="comment"> * and other sensitive information are never written to disk.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOCK_LIMIT((PAGE_SIZE &gt; 64*1024) ? PAGE_SIZE : 64*1024)</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u010692693/article/details/103270378">memlock的一篇分析</a></p><p>这个参数得配合 <code>/proc/pid/status</code>里面的VmLck来看</p><h3 id="nofile">nofile</h3><p>max number of open file descriptors : 最大打开的文件数(以文件描叙符)</p><p>nofile是设置<code>打开的文件描述符的最大数量</code>的参数,在include/uapi/linux/fs.h定义的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INR_OPEN_CUR 1024 <span class="comment">/* Initial setting for nfile rlimits */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INR_OPEN_MAX 4096 <span class="comment">/* Hard limit for nfile rlimits */</span></span></span><br></pre></td></tr></table></figure><p>可以看出nofile硬限制为4096，软限制为1024。软限制是默认值，允许用户增加此值，直到达到硬限制</p><h4 id="注意">注意</h4><p>如果给定系统的工作负载需要增加这些限制，请注意，它本身可以受到两个内核限制的限制</p><ul><li>fs.file-max : 它确定整个系统的最大文件句柄数。默认值为内核启动时可用内存页的最大值 8192 或可用内存页的十分之一</li><li>fs.nr_open : 这表示进程可以分配的最大文件句柄数。默认值为 1024*1024 （1048576）。在某些情况下，不能超过此值</li></ul><h3 id="rss">rss</h3><p>max resident set size (KB) : 最大持久设置大小</p><h3 id="stack">stack</h3><p>max stack size (KB) : 最大栈大小</p><p>stack是堆栈的意思,限制最大堆栈大小,也是内核include/uapi/linux/resource.h里面定义的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Limit the stack by to some sane default: root can always</span></span><br><span class="line"><span class="comment"> * increase this limit if needed..  8MB seems reasonable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STK_LIM(8*1024*1024)</span></span><br></pre></td></tr></table></figure><h3 id="cpu">cpu</h3><p>max CPU time (MIN) : 最多CPU占用时间，单位为MIN分钟</p><h3 id="nproc">nproc</h3><p>max number of processes : 进程的最大数目<br>nproc是限制每个用户创建进程数的,根的默认值总是变化的，取决于内核,内核的默认值取决于内存<br>此值是在kernel/fork.c定义的(内核源码…)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init_task.signal-&gt;rlim[RLIMIT_NPROC].rlim_cur = max_threads/<span class="number">2</span>;</span><br><span class="line">init_task.signal-&gt;rlim[RLIMIT_NPROC].rlim_max = max_threads/<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>也有更简便的计算 一般root显示的就是这个值,而非root用户是limits.conf和xx-nproc.conf定义的大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(($(cat /proc/sys/kernel/threads-max)/2))</span><br></pre></td></tr></table></figure><p>在rhel6和7上面,这个参数默认对root没有限制,他是从内核继承的,对于其他用户来说就4096,是根据下面的文件设定的</p><ul><li>CentOS6中limits.d下面是90-nproc.conf</li><li>CentOS7中limits.d下面是20-nproc.conf</li><li>CentOS8之后的都没有这个文件了,并且用户的默认值继承自内核</li></ul><h4 id="注意-2">注意</h4><p>limits.conf和xx-npoc.conf都有对nproc的定义,其实是pam_limits这个模块会先读入/etc/security/limits.conf，然后读入/etc/security/limits.d/下面的文件,这是对非root来说的!</p><h3 id="as">as</h3><p>address space limit (KB) : 地址空间限制</p><h3 id="maxlogins">maxlogins</h3><p>max number of logins for this user : 此用户允许登录的最大数目</p><h3 id="maxsyslogins">maxsyslogins</h3><p>max number of logins on the system : 系统最大同时在线用户数</p><h3 id="priority">priority</h3><p>the priority to run user process with : 运行用户进程的优先级</p><h3 id="locks">locks</h3><p>max number of file locks the user can hold : 用户可以持有的文件锁的最大数量</p><h3 id="sigpending">sigpending</h3><p>max number of pending signals : 最大待处理信号数(进程可以排队的最大信号数)</p><h3 id="msgqueue">msgqueue</h3><p>max memory used by POSIX message queues (bytes) :  POSIX 消息队列使用的最大内存</p><p>在内核include/uapi/linux/mqueue.h中被定义800 KiBytes</p><h3 id="nice">nice</h3><p>max nice priority allowed to raise to values: [-20, 19] max : nice优先级允许提升到值</p><h3 id="rtprio">rtprio</h3><p>max realtime pr iority  : 最大实时效率</p><h2 id="value">value</h2><p>大小,数量</p>]]></content>
      
      
      <categories>
          
          <category> 配置解释 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置解释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之gdb</title>
      <link href="/posts/5ca85281.html"/>
      <url>/posts/5ca85281.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>调试的</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之lspci</title>
      <link href="/posts/39261f34.html"/>
      <url>/posts/39261f34.html</url>
      
        <content type="html"><![CDATA[<h1>PCI</h1><p>PCI是一种外设总线规范,lspci则是用来显示系统中所有PCI总线设备或连接到该总线上的所有设备的工具</p><h1>简单用法</h1><h2 id="输出所有的pci设备">输出所有的pci设备</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci </span><br></pre></td></tr></table></figure><p>结果就是</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">00</span>:<span class="number">00</span>.<span class="number">0</span> Host bridge: Intel Corporation <span class="number">440</span>BX/ZX/DX - <span class="number">82443</span>BX/ZX/DX Host bridge (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">01</span>.<span class="number">0</span> PCI bridge: Intel Corporation <span class="number">440</span>BX/ZX/DX - <span class="number">82443</span>BX/ZX/DX AGP bridge (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">07</span>.<span class="number">0</span> ISA bridge: Intel Corporation <span class="number">82371</span>AB/EB/MB PIIX4 ISA (rev <span class="number">08</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">07</span>.<span class="number">1</span> IDE interface: Intel Corporation <span class="number">82371</span>AB/EB/MB PIIX4 IDE (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">07</span>.<span class="number">3</span> Bridge: Intel Corporation <span class="number">82371</span>AB/EB/MB PIIX4 ACPI (rev <span class="number">08</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">07</span>.<span class="number">7</span> System peripheral: VMware Virtual Machine Communication Interface (rev <span class="number">10</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">0</span>f.<span class="number">0</span> VGA compatible controller: VMware SVGA II Adapter</span><br><span class="line"><span class="attribute">00</span>:<span class="number">10</span>.<span class="number">0</span> SCSI storage controller: LSI Logic / Symbios Logic <span class="number">53</span>c1030 PCI-X Fusion-MPT Dual Ultra320 SCSI (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">11</span>.<span class="number">0</span> PCI bridge: VMware PCI bridge (rev <span class="number">02</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">02</span>:<span class="number">00</span>.<span class="number">0</span> USB controller: VMware USB1.<span class="number">1</span> UHCI Controller</span><br><span class="line"><span class="attribute">02</span>:<span class="number">01</span>.<span class="number">0</span> Ethernet controller: Intel Corporation <span class="number">82545</span>EM Gigabit Ethernet Controller (Copper) (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">02</span>:<span class="number">02</span>.<span class="number">0</span> Ethernet controller: Intel Corporation <span class="number">82545</span>EM Gigabit Ethernet Controller (Copper) (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">02</span>:<span class="number">04</span>.<span class="number">0</span> USB controller: VMware USB2 EHCI Controller</span><br></pre></td></tr></table></figure><p>(想不到这么长,其实在服务器更长)</p><h2 id="这些都是什么意思的呢">这些都是什么意思的呢?</h2><p>要想知道得看看<code>/proc/iomem</code>这个文件, /proc/iomem描述了系统中所有的设备I/O在内存地址空间上的映射<br>比如我截取了如下一段</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">c0000000</span>-c0007fff : <span class="number">0000</span>:<span class="number">00</span>:<span class="number">0</span>f.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这是一个PCI设备，c0000000-c0007fff是它所映射的内存地址空间，占据了内存地址空间的1024 bytes的位置，而 0000:00:0f.0则是一个PCI外设的地址,它以冒号和逗号分隔为4个部分，第一个16位表示域，第二个8位表示一个总线编号，第三个5位表示一 个设备号，最后是3位，表示功能号<br>由此再来看lspci的结果就不难看出<code>第一列</code>其实就是pci的描述,第二列型号信息,这部分太深奥了,不如自己百度吧</p><h1>查看指定的设备</h1><p>一般来说这个章节就是判断驱动有没有,没有的话怎么查找驱动过程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nn | grep -i eth # -nn 显示文本和数字ID</span><br></pre></td></tr></table></figure><p>输入如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">02</span>:<span class="number">01</span>.<span class="number">0</span> Ethernet controller<span class="meta"> [0200]: Intel Corporation 82545EM Gigabit Ethernet Controller (Copper) [8086:100f] (rev 01)</span></span><br></pre></td></tr></table></figure><p>只要关注如下几个地方</p><ul><li>02:01.0</li><li>Intel Corporation 82545EM Gigabit Ethernet Controller</li><li>8086:100f</li></ul><h2 id="按pci号展示信息">按pci号展示信息</h2><p>这里的02:01.0就是-nn输出的第一列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nvs 02:01.0</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">02:01.0 0200:</span> <span class="number">8086</span><span class="string">:100f</span> <span class="string">(rev</span> <span class="number">01</span><span class="string">)</span></span><br><span class="line"><span class="attr">Subsystem:</span> <span class="string">15ad:0750</span></span><br><span class="line"><span class="attr">Physical Slot:</span> <span class="number">33</span></span><br><span class="line"><span class="attr">Flags:</span> <span class="string">bus</span> <span class="string">master,</span> <span class="string">66MHz,</span> <span class="string">medium</span> <span class="string">devsel,</span> <span class="string">latency</span> <span class="number">0</span><span class="string">,</span> <span class="string">IRQ</span> <span class="number">19</span></span><br><span class="line"><span class="string">Memory</span> <span class="string">at</span> <span class="string">fd5c0000</span> <span class="string">(64-bit,</span> <span class="string">non-prefetchable)</span> [<span class="string">size=128K</span>]</span><br><span class="line"><span class="string">Memory</span> <span class="string">at</span> <span class="string">fdff0000</span> <span class="string">(64-bit,</span> <span class="string">non-prefetchable)</span> [<span class="string">size=64K</span>]</span><br><span class="line"><span class="string">I/O</span> <span class="string">ports</span> <span class="string">at</span> <span class="number">2000</span> [<span class="string">size=64</span>]</span><br><span class="line">[<span class="string">virtual</span>] <span class="string">Expansion</span> <span class="string">ROM</span> <span class="string">at</span> <span class="string">fd500000</span> [<span class="string">disabled</span>] [<span class="string">size=64K</span>]</span><br><span class="line"><span class="attr">Capabilities:</span> [<span class="string">dc</span>] <span class="string">Power</span> <span class="string">Management</span> <span class="string">version</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Capabilities:</span> [<span class="string">e4</span>] <span class="string">PCI-X</span> <span class="string">non-bridge</span> <span class="string">device</span></span><br><span class="line"><span class="attr">Kernel driver in use:</span> <span class="string">e1000</span></span><br><span class="line"><span class="attr">Kernel modules:</span> <span class="string">e1000</span></span><br></pre></td></tr></table></figure><p>在这里就只要看1点</p><ul><li>Kernel driver in use<br>这就是代表驱动有没打上</li></ul><h2 id="假设硬件名没有显示">假设硬件名没有显示</h2><p>可以登陆如下小网站查询</p><blockquote><p><a href="https://devicehunt.com/">https://devicehunt.com/</a></p></blockquote><p>这里就要用到8086:100f这个参数,8086就是厂商id,100f就是设备id,通过这个设备id就能查到这个硬件是什么,知道硬件之后就去对应的官网下载src编译,尤其是用在显卡方面比较多,因为不是每个系统版本都能默认识别到硬件,所以要自己查</p><h1>以树形结构显示</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci –t</span><br></pre></td></tr></table></figure><h1>展示系统中所有某个厂商的设备</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lspci</span> -nn -d <span class="number">8086</span>:</span><br></pre></td></tr></table></figure><h1>更新数据库</h1><p>新设备和供应商总是在不断迭代。如果看到显示为 unknown 的设备，说明你的 PCI 设备 ID 数据库可能已过时。有两种方法可以检查更新</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -<span class="selector-tag">Q</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防火墙firewalld</title>
      <link href="/posts/4791db89.html"/>
      <url>/posts/4791db89.html</url>
      
        <content type="html"><![CDATA[<p>(谁用啊,你用吗?)<br>(我瞎说的   )</p>]]></content>
      
      
      <categories>
          
          <category> 防火墙 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>增加swap分区</title>
      <link href="/posts/1ee8998b.html"/>
      <url>/posts/1ee8998b.html</url>
      
        <content type="html"><![CDATA[<h1>swap是干啥的</h1><p>Linux内核为了提高读写效率与速度，会将文件在内存中进行缓存，这部分内存就是Cache Memory(缓存内存)。即使你的程序运行结束后，Cache Memory也不会自动释放。这就会导致你在Linux系统中程序频繁读写文件后，你会发现可用物理内存变少。当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap空间中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行Swap交换</p><h1>swap的主要功能</h1><p>其实上面基本已经将swap的主要功能说了，这里再来重述一下：</p><ol><li>当物理内存不足的时候，将某些在内存中所占用的程序暂时移动到swap当中，让物理内存可以被需要的程序来使用；</li><li>Linux会将内存中不常访问的数据保存到swap中，当系统需要再次调用的时候，就把它从swap加载到内存；</li><li>如果你的主机支持电源管理模式，也就是说，你的Linux主机系统可以进入&quot;休眠&quot;模式的话，那么，运行当中的程序状态则会被记录到swap中去，以作为&quot;唤醒&quot;主机状态的依据；</li><li>在某些程序运行时，本来就会利用swap特性来存放一些数据，比如在装Oracle11g的时候会检查swap size；</li></ol><h1>有没有必要用swap</h1><p>先说结论:看情况(这和没说没啥区别…)</p><ol><li>数据库系统一般都对响应延迟比较敏感，如果使用swap代替内存，数据库服务性能必然不可接受</li><li>但是swap空间到底用不用，取决于应用软件需不需要,如LibreOffice在启动的过程中会使用大量的内存，但这些内存很多时候只是在启动的时候用一下，后面的运行过程中很少再用到这些内存</li><li>比如ubuntu的休眠功能依赖于swap分区，当系统休眠的时候，会将内存中的数据保存到swap分区上，等下次系统启动的时候，再将数据加载到内存中，这样可以加快系统的启动速度，所以如果要使用休眠的功能，必须要配置swap分区</li><li>在某些情况下，物理内存有限，但又想运行耗内存的程序,可以通过配置足够的swap空间来达到目标，虽然慢一点，但至少可以运行</li><li>swap是存放在磁盘上的，磁盘的速度和内存比较起来慢了好几个数量级，如果不停的读写swap，那么对系统的性能肯定有影响，尤其是当系统内存很吃紧的时候，读写swap空间发生的频率会很高，导致系统运行很慢</li></ol><h1>swap大小如何确定</h1><p>我找了redhat的帖子</p><ul><li>2G物理内存<br>两倍于已安装的内存,如果允许休眠，则建议交换空间3倍于内存量</li><li>2G~8G物理内存<br>相同数量的内存,如果允许休眠，则建议交换空间2倍于内存量</li><li>8G~64G物理内存<br>至少4G,如果允许休眠，则建议交换空间1.5倍于内存量</li><li>64G以上物理内存<br>至少4G,如果允许休眠，不建议休眠</li><li>140个逻辑处理器或者3T ram<br>建议至少 100GB 的交换空间</li></ul><h1>如何创建swap</h1><p>一般来说在装系统阶段就已经设置好swap了,如果当时没设置只能进系统设置,如果有新的磁盘可以拿磁盘做,如果没有就只能dd,如果要实现开机就有的话需要加入fstab</p><h2 id="磁盘做">磁盘做</h2><ul><li>分区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure><ul><li>格式化</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sdb1</span><br></pre></td></tr></table></figure><ul><li>激活swap</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon  /dev/sdb1</span><br></pre></td></tr></table></figure><ul><li>写入fstab<br>这边要注意,使用的是追加,不是重定向,小心清空了fstab</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/dev/sdb1  swap  swap    defaults   0    0&quot; &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure><h2 id="dd做">dd做</h2><ul><li>创建一块文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero  of=/root/swapfile bs=1M count=16384</span><br></pre></td></tr></table></figure><ul><li>制作swap文件系统</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /root/swapfile</span><br></pre></td></tr></table></figure><ul><li>激活swap</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /root/swapfile</span><br></pre></td></tr></table></figure><h1>swap管理</h1><h2 id="查看swap分区">查看swap分区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure><h2 id="取消激活swap">取消激活swap</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff /root/swapfile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘测速</title>
      <link href="/posts/9785dd0.html"/>
      <url>/posts/9785dd0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.cnblogs.com/sylar5/p/6649009.html">Linux 中用 dd 命令来测试硬盘读写速度 - Cyril_Wu - 博客园 (cnblogs.com)</a></p></blockquote><h1>注意</h1><p>读取的时候清空缓存，保证读取是从设备读取，而不是从内存读取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &quot;sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches&quot;</span><br></pre></td></tr></table></figure><h1>基本用法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time dd if=/dev/zero  of=/dev/null bs=block_size count=number_of_blocks</span><br></pre></td></tr></table></figure><h1>参数选项</h1><ul><li>选项<ul><li>if=file  ：从 file 中读而不是标准输入</li><li>of=file ：写到 file 里去而不是标准输出</li><li>bs=bytes ：一次读和写  bytes 字节</li><li>ibs=bytes ：一次读 bytes 字节。默认是512</li><li>obs=bytes ：一次写 bytes 字节。默认是512</li><li>count=blocks ： 仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数</li><li>iflag=FLAGS   ：指定读的方式FLAGS</li><li>oflag=FLAGS  ：指定写的方式FLAGS</li></ul></li><li>FLAGS如下<ul><li>direct　　　读写数据采用直接IO方式；</li><li>directory　读写失败除非是directory；</li><li>dsync　　　读写数据采用同步IO；</li><li>sync　　　　同上，但是针对是元数据</li><li>fullblock　　堆积满block(iflag only)；</li><li>nonblock　读写数据采用非阻塞IO方式</li><li>noatime　　 读写数据不更新访问时间</li></ul></li></ul><h1>磁盘写能力测试</h1><p>/dev/zero是一个伪设备，只产生空字符流，不会产生IO，IO都会集中在of文件中，所以这个命令是测试磁盘的写能力。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=test bs=8k count=10000 oflag=direct</span><br></pre></td></tr></table></figure><h1>读取能力测试</h1><p>/dev/sdb是一个物理分区，对它的读取会产生IO，/dev/null是伪设备，是黑洞，of到该设备不会产生IO，所以，这个命令的IO只发生在/dev/sdb上，也相当于测试磁盘的读能力</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=test of=/dev/null bs=8k count=10000 iflag=direct</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁盘测速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fio测速</title>
      <link href="/posts/a448d86c.html"/>
      <url>/posts/a448d86c.html</url>
      
        <content type="html"><![CDATA[<h1>什么是fio</h1><p>磁盘IO是检查磁盘性能的重要指标,测试磁盘设备的性能的工具有很多,比如FIO,他是一个可以产生很多线程或进程并执行用户指定的特定类型I/O操作的工具，典型应用场景是编写和模拟的I/O负载匹配的作业文件</p><h1>fio用到的参数</h1><ul><li>filename=/dev/mapper/dbbak-dbdata<br>测试文件名称</li><li>direct=1<br>是否使用directIO，测试过程绕过OS自带的<code>buffer</code>,使测试磁盘的结果更真实。因为Linux读写的时候，内核维护了缓存，数据先写到缓存，后面再后台写到SSD。读的时候也优先读缓存里的数据。这样速度可以加快，但是一旦掉电缓存里的数据就没了。所以有一种模式叫做DirectIO，跳过缓存，直接读写SSD</li><li>rw=randwrite<br>测试随机写的I/O</li><li>rw=randrw<br>测试随机写和读的I/O</li><li>bs=16k<br>单次io的块文件大小为16k</li><li>bsrange=512-2048<br>同上，提定数据块的大小范围</li><li>size=5G<br>每个线程读写的数据量是5GB</li><li>numjobs=1<br>每个job（任务）开1个线程，这里用了几，后面每个用-name指定的任务就开几个线程测试。所以最终线程数=任务数（几个name=jobx）* numjobs。</li><li>name=test<br>一个任务的名字</li><li>thread<br>使用pthread_create创建线程，另一种是fork创建进程。进程的开销比线程要大，一般都采用thread测试。</li><li>runtime=1000<br>测试时间为1000秒，如果不写则一直将5g文件分4k每次写完为止。</li><li>ioengine=libaio<br>指定io引擎使用libaio方式<ul><li>libaio：Linux本地异步I/O</li><li>rbd:通过librbd直接访问CEPH Rados</li></ul></li><li>iodepth=16<br>队列深度为16,如果SSD执行读写如果发生了卡顿，那有可能系统会一直不停的发命令,这样一方面SSD扛不住,另一方面这么多命令会很占内存，系统也要挂掉了</li><li>Block Devices(RBD)<br>无需使用内核RBD驱动程序(rbd.ko)</li><li>rwmixwrite=30<br>在混合读写的模式下，写占30%</li><li>group_reporting<br>关于显示结果的，汇总每个进程的信息</li><li>lockmem=1g<br>只使用1g内存进行测试。</li><li>zero_buffers<br>用0初始化系统buffer。</li><li>nrfiles=8<br>每个进程生成文件的数量</li></ul><h1>2个用过的例子</h1><ul><li>测试随机读</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/mapper/dbbak-dbdata -direct=1 -iodepth=1 -rw=randread -ioengine=libaio -bs=32k -size=5G -numjobs=16 -group_reporting -name=test -output=hddrandreadtest</span><br></pre></td></tr></table></figure><ul><li>测试随机写</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/mapper/dbbak-dbdata -direct=1 -iodepth=1 -rw=randwrite -ioengine=libaio -bs=32k -size=5G -numjobs=16 -group_reporting -name=test -output=hddrandwritetest</span><br></pre></td></tr></table></figure><h1>fio结果解释</h1><p>(我也看不懂)</p>]]></content>
      
      
      <categories>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fio测速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户被锁定</title>
      <link href="/posts/10c41d09.html"/>
      <url>/posts/10c41d09.html</url>
      
        <content type="html"><![CDATA[<h1>问题阐述</h1><p>用户密码输错多次被锁定了账户</p><h1>产生原因</h1><p>在一些系统通过pam模块设定了登陆限制之后,由于输入错了密码次数过多导致的</p><h1>解决方法</h1><p>只能通过root或者whell组的拥有高级权限的账户进行解锁,如果root都被锁定了只能进入单用户解锁次数,时间要是被锁定了可以通过耐心的等待</p><h2 id="解锁次数">解锁次数</h2><ul><li>查看用户登陆失败次数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pam_tally2 --user=用户名 </span><br></pre></td></tr></table></figure><ul><li>重置用户登陆失败次数为0</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pam_tally2 --user=用户名  --reset </span><br></pre></td></tr></table></figure><h2 id="解锁时间">解锁时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faillock   --user   用户名    --reset</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之ps</title>
      <link href="/posts/9202f4ae.html"/>
      <url>/posts/9202f4ae.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之screen</title>
      <link href="/posts/c9d4ad81.html"/>
      <url>/posts/c9d4ad81.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序,但也有其他用处</p><h1>创建screen实例</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure><h1>离开实例</h1><p>在 screen 终端 下 按下 Ctrl+a d键</p><h1>显示实例</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -ls</span><br></pre></td></tr></table></figure><h1>重新链接某个实例</h1><p>连接 screen_id 为 2276 的 screen终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r 2276</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之netstat</title>
      <link href="/posts/af020bcb.html"/>
      <url>/posts/af020bcb.html</url>
      
        <content type="html"><![CDATA[<h1>TCP连接状态详解</h1><ul><li>LISTEN：     侦听来自远方的TCP端口的连接请求</li><li>SYN-SENT：   再发送连接请求后等待匹配的连接请求</li><li>SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认</li><li>ESTABLISHED：代表一个打开的连接</li><li>FIN-WAIT-1： 等待远程TCP连接中断请求，或先前的连接中断请求的确认</li><li>FIN-WAIT-2： 从远程TCP等待连接中断请求</li><li>CLOSE-WAIT： 等待从本地用户发来的连接中断请求</li><li>CLOSING：    等待远程TCP对连接中断的确认</li><li>LAST-ACK：   等待原来的发向远程TCP的连接中断请求的确认</li><li>TIME-WAIT：  等待足够的时间以确保远程TCP接收到连接中断请求的确认</li><li>CLOSED：     没有任何连接状态</li></ul><h1>命令选项</h1><ul><li>-a或–all：显示所有连线中的Socket；</li><li>-A&lt;网络类型&gt;或–&lt;网络类型&gt;：列出该网络类型连线中的相关地址；</li><li>-c或–continuous：持续列出网络状态；</li><li>-C或–cache：显示路由器配置的快取信息；</li><li>-e或–extend：显示网络其他相关信息；</li><li>-F或–fib：显示FIB；</li><li>-g或–groups：显示多重广播功能群组组员名单；</li><li>-h或–help：在线帮助；</li><li>-i或–interfaces：显示网络界面信息表单；</li><li>-l或–listening：显示监控中的服务器的Socket；</li><li>-M或–masquerade：显示伪装的网络连线；</li><li>-n或–numeric：直接使用ip地址，而不通过域名服务器；</li><li>-N或–netlink或–symbolic：显示网络硬件外围设备的符号连接名称；</li><li>-o或–timers：显示计时器；</li><li>-p或–programs：显示正在使用Socket的程序识别码和程序名称；</li><li>-r或–route：显示Routing Table；</li><li>-s或–statistice：显示网络工作信息统计表；</li><li>-t或–tcp：显示TCP传输协议的连线状况；</li><li>-u或–udp：显示UDP传输协议的连线状况；</li><li>-v或–verbose：显示指令执行过程；</li><li>-V或–version：显示版本信息；</li><li>-w或–raw：显示RAW传输协议的连线状况；</li><li>-x或–unix：此参数的效果和指定&quot;-A unix&quot;参数相同；</li><li>–ip或–inet：此参数的效果和指定&quot;-A inet&quot;参数相同。</li></ul><h1>使用方法</h1><ul><li>列出所有端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a</span><br></pre></td></tr></table></figure><ul><li>列出所有TCP或UDP端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -at</span><br><span class="line">netstat -au</span><br></pre></td></tr></table></figure><ul><li>列出所有监听状态的端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出所有</span></span><br><span class="line">netstat -l</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出TCP</span></span><br><span class="line">netstat -lt </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出UDP</span></span><br><span class="line">netstat -lu</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出监听UNIX端口</span></span><br><span class="line">netstat -lx</span><br></pre></td></tr></table></figure><ul><li>显示端口的统计信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示所有端口的统计信息</span></span><br><span class="line">netstat -s</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示TCP端口的统计信息</span></span><br><span class="line">netstat -st</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示UDP端口的统计信息</span></span><br><span class="line">netstat -su</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在netstat输出中显示 PID 和进程名称</span></span><br><span class="line">netstat -pt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在netstat输出中不显示主机，端口和用户名(host, port or user)</span></span><br><span class="line">netstat -an</span><br></pre></td></tr></table></figure><ul><li>持续输出netstat信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -c</span><br></pre></td></tr></table></figure><ul><li>显示核心路由信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure><ul><li>使用netstat -rn显示数字格式，不查询主机名称</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -rn</span><br></pre></td></tr></table></figure><ul><li>找出程序用的端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp | grep ssh</span><br></pre></td></tr></table></figure><ul><li>找出运行在指定端口的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep &quot;:80&quot;</span><br></pre></td></tr></table></figure><ul><li>通过端口找进程ID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp | grep 80 | awk &#x27;&#123;print $7&#125;&#x27; | cut -d/ -f1</span><br></pre></td></tr></table></figure><ul><li>显示网络接口列表</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -i</span><br></pre></td></tr></table></figure><ul><li>统计TCP各种状态列表</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &#x27;/^tcp/&#123;++S[$NF]&#125;END&#123;for(i in S) print i,S[i]&#125;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之lsof</title>
      <link href="/posts/97f67cbd.html"/>
      <url>/posts/97f67cbd.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>lsof是List Open Files(这个是man手册说的)的缩写,它主要用来获取被进程打开文件的信息,在Linux中,一切皆文件,lsof命令可以查看所有已经打开了的文件,文件含义如下</p><ol><li>普通文件</li><li>目录</li><li>网络文件系统的文件</li><li>字符或设备文件</li><li>(函数)共享库</li><li>管道,命名管道</li><li>符号链接</li><li>网络文件(例如:NFS file、网络socket,unix域名socket)</li><li>还有其它类型的文件,等等</li></ol><h1>lsof每一列解释</h1><ul><li>COMMAND : 进程名</li><li>PID : 进程ID</li><li>TID : 任务ID</li><li>USER : 所属用户</li><li>FD : 文件描述符<ul><li>cwd : 应用程序当前工作目录,这是该应用程序启动的目录,除非它本身对这个目录进行更改</li><li>txt : 该类型的文件是程序代码,如应用程序二进制文件本身或共享库,如上列表中显示的 /sbin/init 程序</li><li>lnn : 库引用（AIX）</li><li>err : FD 信息错误</li><li>jld : 监狱目录（FreeBSD）</li><li>ltx : 共享库文本（代码和数据）</li><li>mxx : 十六进制内存映射类型号 xx</li><li>m86 : DOS合并映射文件</li><li>mem : 内存映射文件</li><li>mmap : 内存映射设备</li><li>pd : 父目录</li><li>rtd : 根目录</li><li>tr : 内核跟踪文件（OpenBSD）</li><li>v86 : VP/ix 映射文件</li><li>0 : 标准输出</li><li>1 : 标准输入</li><li>2 : 标准错误</li><li>r : 只读</li><li>w : 写入</li><li>u : 读写</li><li>空格 : 文件状态模式是unknow没锁定</li><li>短杠 : 文件状态模式是unknow且锁定</li></ul></li><li>TYPE : 文件类型,大致类型如下<ul><li>REG : 普通文件</li><li>DIR : 表示目录</li><li>CHR : 表示字符类型</li><li>BLK : 块设备类型</li><li>UNIX : UNIX 域套接字</li><li>FIFO : 先进先出队列</li><li>IPv4 : IPv4 套接字</li></ul></li><li>DEVICE : 磁盘名称</li><li>SIZE/OFF : 以字节为单位的文件的大小或文件偏移量</li><li>NODE : 索引节点</li><li>NAME : 打开文件的确切名称</li></ul><h1>用法</h1><h2 id="列出所有打开的文件">列出所有打开的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br></pre></td></tr></table></figure><h2 id="列出所有打开的文件分页显示">列出所有打开的文件分页显示</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof | more</span><br></pre></td></tr></table></figure><h2 id="查看某个特定的文件谁在用">查看某个特定的文件谁在用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /var/log/messages</span><br></pre></td></tr></table></figure><h2 id="显示指定进程打开的文件">显示指定进程打开的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsoc -c sshd</span><br></pre></td></tr></table></figure><h2 id="显示指定进程号打开的文件">显示指定进程号打开的文件</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -p <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="监听协议-端口等">监听协议,端口等</h2><p>lsof -i [46] [protocol] [@hostname] [:service|port]</p><ul><li>显示所有的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure><ul><li>显示所有tcp网络连接进程信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp</span><br></pre></td></tr></table></figure><ul><li>显示端口是80 的进程信息<br>其实这边是省略了指定协议,所以会输出所有tcp和udp的,一般用于检查端口占用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :80</span><br></pre></td></tr></table></figure><ul><li>列出端口是1-1024的文件</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -i :<span class="number">1</span>-<span class="number">1024</span></span><br></pre></td></tr></table></figure><ul><li>显示同时满足tcp且端口是22的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:22</span><br></pre></td></tr></table></figure><ul><li>显示指定用户使用的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -u root</span><br></pre></td></tr></table></figure><ul><li>显示除了某个用户之外其他用户打开的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -u ^root</span><br></pre></td></tr></table></figure><ul><li>显示所有socket文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -U</span><br></pre></td></tr></table></figure><ul><li>查看某个目录的文件信息<br>可以用于卸载磁盘时报&quot;device is busy&quot;</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /run/media/root/KylinSec</span><br></pre></td></tr></table></figure><ul><li>查看某个目录及子目录的文件信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof +D /root</span><br></pre></td></tr></table></figure><ul><li>找出打开着的但是已经被删除的文件</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof  grep deleted</span></span><br></pre></td></tr></table></figure><ul><li>列出ipv4/6的网络文件</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -i <span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE漏洞</title>
      <link href="/posts/1e0d49f9.html"/>
      <url>/posts/1e0d49f9.html</url>
      
        <content type="html"><![CDATA[<h1>CVE是什么</h1><p>CVE(Common Vulnerabilities and Exposures)的全称是公共漏洞和暴露，是公开的网络安全漏洞列表.<br>查阅CVE获取漏洞的详细信息，根据漏洞评分确定漏洞解决的优先级</p><h1>CVE号组成</h1><p>CVE编号是识别漏洞的唯一标识符,在CVE中，每个漏洞按CVE-1999-0067、CVE-2014-10001、CVE-2014-100001这样的形式编号,编号格式为&quot;CVE-年份-编号&quot;,可以在<a href="https://cve.mitre.org/">cve官网</a>找到,但不是所有漏洞都可以被录入CVE，主要根据如下规则判定是否为漏洞分配CVE编号：</p><ul><li>漏洞可独立修复，与其他漏洞没有耦合。</li><li>软件或硬件供应商承认此漏洞的存在或有书面公告。</li><li>漏洞只影响一个代码库，如果漏洞影响多个产品，则为每个产品独立分配CVE编号<br>如果可以分配编号则编写描述信息并发布到CVE网站。每个CVE条目主要包含以下信息：</li><li>描述：漏洞的来源、攻击方式等简要描述。</li><li>参考：漏洞的相关参考信息链接汇总，例如供应商的漏洞公告、紧急响应建议等。</li><li>发布的CNA：发布此CVE的CNA。</li><li>发布日期：此CVE的发布日期。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之rpm</title>
      <link href="/posts/f854f9de.html"/>
      <url>/posts/f854f9de.html</url>
      
        <content type="html"><![CDATA[<h1>安装</h1><h2 id="安装软件包">安装软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh xx.rpm</span><br></pre></td></tr></table></figure><h2 id="安装忽略依赖">安装忽略依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh xxx.rpm --nodeps </span><br></pre></td></tr></table></figure><h2 id="测试安装xx软件包">测试安装xx软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh --test xxx.rpm</span><br></pre></td></tr></table></figure><h1>卸载</h1><h2 id="卸载软件包">卸载软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e xxx</span><br></pre></td></tr></table></figure><h2 id="卸载软件包忽略依赖">卸载软件包忽略依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e xxx --nodeps</span><br></pre></td></tr></table></figure><h1>查询</h1><h2 id="查询一个软件是否安装">查询一个软件是否安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q openssh</span><br></pre></td></tr></table></figure><h2 id="查询软件包是否安装">查询软件包是否安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qpi telnet-0.17-48.kb2.ky3.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="查看已经安装的软件包">查看已经安装的软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa  </span><br></pre></td></tr></table></figure><h2 id="显示xxx功能、文件、目录是哪个软件包提供的">显示xxx功能、文件、目录是哪个软件包提供的</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf  &#x27;which ssh&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf  /opt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf /etc/ntp.conf</span><br></pre></td></tr></table></figure><h2 id="显示包的更改记录">显示包的更改记录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q --changelog ntp-4.2.8p15-28.ky3.kb5.x86_64</span><br></pre></td></tr></table></figure><h2 id="查询包的依赖关系">查询包的依赖关系</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qR ntp-4.2.8p15-28.ky3.kb5.x86_64</span><br></pre></td></tr></table></figure><h2 id="显示包的信息">显示包的信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -V pkg_name</span><br></pre></td></tr></table></figure><h2 id="查看包的详细信息">查看包的详细信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi pkg_name</span><br></pre></td></tr></table></figure><h2 id="查看包提供的文档">查看包提供的文档</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qd pkg_name</span><br></pre></td></tr></table></figure><h2 id="查看软件包的配置文件">查看软件包的配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qc pkg_name</span><br></pre></td></tr></table></figure><h2 id="查看一个软件包的安装的文件">查看一个软件包的安装的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql pkg_name</span><br></pre></td></tr></table></figure><h2 id="检查所有的rpm是否遗漏配置">检查所有的rpm是否遗漏配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Va</span><br></pre></td></tr></table></figure><h2 id="数字签名校验rpm包是否被篡改">数字签名校验rpm包是否被篡改</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">rpm</span> <span class="operator">-</span><span class="built_in">K</span> <span class="variable">xxx</span><span class="operator">.</span><span class="variable">rpm</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/LiuYanYGZ/p/9435708.html">https://www.cnblogs.com/LiuYanYGZ/p/9435708.html</a></p></blockquote><h1>升级降级</h1><h2 id="升级包">升级包</h2><p>删除旧包再装新包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh pkg_name</span><br></pre></td></tr></table></figure><h2 id="升级包-2">升级包</h2><p>在旧版本的基础上安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Fvh pkg_name</span><br></pre></td></tr></table></figure><h2 id="降级包">降级包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh pkg_name --oldpackage</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置yum源</title>
      <link href="/posts/288d0611.html"/>
      <url>/posts/288d0611.html</url>
      
        <content type="html"><![CDATA[<h1>前置要求</h1><p>配置好网络,因为软件源可以搭建本地的,也可以使用公网镜像站的,所以要求配置网络</p><h1>寻找加速站点</h1><p>默认的源指向的是centos的官网,在国内访问的速度并不是很可观,所以可以使用一些国内的镜像站作为加速,我有一篇帖子收集了一些国内的镜像站<br>这里以<a href="https://mirrors.ustc.edu.cn/">中国科学技术大学开源软件镜像站</a>为例子,是我经常用的站点</p><h1>配置基础源</h1><p>中国科学技术大学开源软件镜像站的<code>配置软件源</code>页面记录了大量软件源的配置方法,这里选到<a href="https://mirrors.ustc.edu.cn/help/centos.html">centos7配置页面</a>查看</p><h1>配置BASE源</h1><p>两种方法选一个就好了,推荐使用本地,因为大部分软件包在本地速度会快</p><ul><li>本地base<br>所谓的base就是iso文件里面的基础软件包,我们将iso挂载到机器,将baseurl指向iso挂载点即可<ul><li>挂载</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o loop xx.iso /mnt</span><br></pre></td></tr></table></figure><ul><li>修改repo</li></ul>  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Base]</span></span><br><span class="line"><span class="attr">name</span>=CentOS-<span class="variable">$releasever</span> - Base</span><br><span class="line"><span class="attr">baseurl</span>=file:///mnt</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li>网络base<br>所谓的网络base就是镜像站点已经将iso挂载到一个页面了,我们只需将base指向一个网络地址<ul><li>修改repo</li></ul>  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Base]</span></span><br><span class="line"><span class="attr">name</span>=CentOS-<span class="variable">$releasever</span> - Base</span><br><span class="line"><span class="attr">baseurl</span>=https://mirrors.ustc.edu.cn/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><h1>更新元数据</h1><ul><li>清空</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean <span class="keyword">all</span></span><br></pre></td></tr></table></figure><ul><li>缓存</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum makecache</span></span><br></pre></td></tr></table></figure><h1>配置epel源</h1><p>EPEL是由Fedora为企业Linux创建、维护和管理的一个高质量附加包集合</p><ul><li>安装epel-release<br>实质上主要就是提供了一个repo文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><ul><li>修改repo地址<br>利用sed命令替换其中的网址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;s|^metalink=|#metalink=|g&#x27; \</span><br><span class="line">         -e &#x27;s|^#baseurl=https\?://download.fedoraproject.org/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g&#x27; \</span><br><span class="line">         -e &#x27;s|^#baseurl=https\?://download.example/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g&#x27; \</span><br><span class="line">         -i.bak \</span><br><span class="line">         /etc/yum.repos.d/epel.repo</span><br></pre></td></tr></table></figure><ul><li>repo最后的内容</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[epel]</span></span><br><span class="line"><span class="attr">name</span>=Extra Packages for Enterprise Linux <span class="number">7</span> - <span class="variable">$basearch</span></span><br><span class="line"><span class="attr">baseurl</span>=https://mirrors.ustc.edu.cn/epel/<span class="number">7</span>/<span class="variable">$basearch</span></span><br><span class="line"><span class="attr">failovermethod</span>=priority</span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="section">[epel-debuginfo]</span></span><br><span class="line"><span class="attr">name</span>=Extra Packages for Enterprise Linux <span class="number">7</span> - <span class="variable">$basearch</span> - Debug</span><br><span class="line"><span class="attr">baseurl</span>=https://mirrors.ustc.edu.cn/epel/<span class="number">7</span>/<span class="variable">$basearch</span>/debug</span><br><span class="line"><span class="attr">failovermethod</span>=priority</span><br><span class="line"><span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-<span class="number">7</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="section">[epel-source]</span></span><br><span class="line"><span class="attr">name</span>=Extra Packages for Enterprise Linux <span class="number">7</span> - <span class="variable">$basearch</span> - Source</span><br><span class="line"><span class="attr">baseurl</span>=https://mirrors.ustc.edu.cn/epel/<span class="number">7</span>/SRPMS</span><br><span class="line"><span class="attr">failovermethod</span>=priority</span><br><span class="line"><span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-<span class="number">7</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>更新元数据<ul><li>清空</li></ul>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean <span class="keyword">all</span></span><br></pre></td></tr></table></figure><ul><li>缓存</li></ul>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum makecache</span></span><br></pre></td></tr></table></figure></li></ul><h1>总结</h1><p>大致的配置方法就这样,大多数站点的也就是前半段的地址不一样</p>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yum源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>镜像站合集</title>
      <link href="/posts/3789dae6.html"/>
      <url>/posts/3789dae6.html</url>
      
        <content type="html"><![CDATA[<h1>系统镜像站</h1><p>点击直达镜像站(排名无先后)<br><a href="https://www.centos.org/download/">centos.org官方站点</a><br><a href="https://vault.centos.org/">centos-valut站点</a><br><a href="https://mirrors.nju.edu.cn/">南京大学开源镜像站</a><br><a href="https://mirrors.ustc.edu.cn/">中国科学技术大学开源软件镜像站</a><br><a href="https://developer.aliyun.com/mirror/">阿里巴巴镜像站</a><br><a href="https://mirrors.huaweicloud.com/home">华为开源镜像站</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国内镜像站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之yum</title>
      <link href="/posts/8976e27a.html"/>
      <url>/posts/8976e27a.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>yum是包管理器,centos7以下都是用的yum,centos8以上都换成了dnf,由于yum的命令非常强大(学不会),这里只会简单的介绍基本用法</p><h1>前置要求</h1><blockquote><p>在使用yum命令之前需要配置yum源,yum源可以简单的理解为软件源</p></blockquote><h2 id="如何去学习这个命令的用法">如何去学习这个命令的用法</h2><p>看man手册或者使用–help(选项)查看相关资料</p><ul><li>使用man手册</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man yum</span><br></pre></td></tr></table></figure><ul><li>使用–help选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --help</span><br></pre></td></tr></table></figure><ul><li>使用yum的选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum help</span><br></pre></td></tr></table></figure><h2 id="yum的命令形式">yum的命令形式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package]</span><br></pre></td></tr></table></figure><h2 id="元数据">元数据</h2><p>玩yum之前需要先做好<code>元数据</code>,配置好repo文件之后就需要生成元数据,yum仓库的元数据由XML文件构成，包含了其他文件的校验（checksums）及所引用的包。</p><ul><li>清空yum缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure><ul><li>创建元数据缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h1>显示仓库</h1><p>用命令展示系统所配置的软件源</p><ul><li>显示所有源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist all</span><br></pre></td></tr></table></figure><ul><li>显示可用的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist enabled</span><br></pre></td></tr></table></figure><ul><li>显示禁止的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist disabled</span><br></pre></td></tr></table></figure><ul><li>显示当前激活的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist</span><br></pre></td></tr></table></figure><h1>列举软件包</h1><ul><li>显示源里面的所有的rpm包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list </span><br></pre></td></tr></table></figure><ul><li>列出本机安装的软件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed </span><br></pre></td></tr></table></figure><ul><li>列出yum源里面可以安装的包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list available</span><br></pre></td></tr></table></figure><ul><li>列出yum源里面可以更新的所有包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list updates</span><br></pre></td></tr></table></figure><h1>查询软件包</h1><p>search查询的结果是含有查询关键词的包名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search httpd</span><br></pre></td></tr></table></figure><h1>查询软件包的文件</h1><p>使用provides(或whatprovides)查询命令或者文件在哪个rpm包,很适合用于查询库文件或者单个命令所属包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum provides nginx</span><br></pre></td></tr></table></figure><h1>查看软件包组</h1><p>groups是软件包组,系统内集成了很多软件包组例如开发工具组,桌面组,可以实现一键安装某个组的所有软件</p><ul><li>列举groups软件组<br>用于显示软件包组,例如开发工具组,桌面组等</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groups list</span><br></pre></td></tr></table></figure><ul><li>查询group软件组的信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groups info &quot;Server with GUI&quot;</span><br></pre></td></tr></table></figure><h1>依赖问题</h1><p>rpm包之间的依赖是很头疼的</p><ul><li>列举bash软件包的依赖<br>会显示依赖什么文件,并且这些依赖在什么包里面,如果依赖都已经安装了,那么就可以单独安装该软件包,如果依赖缺失,就必须先安装依赖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum deplist bash</span><br></pre></td></tr></table></figure><h1>安装软件包</h1><ul><li>安装单个软件包<br>包名可以用search查询出来</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install 包名</span><br></pre></td></tr></table></figure><ul><li>安装软件组<br>例如直接安装开发工具,里面包括make,gcc,g++等</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groups install &quot;Development Tools&quot;</span><br></pre></td></tr></table></figure><h1>下载软件包</h1><p>在有些环境复杂的地方可能不能使用网络,所以需要将安装包下载导入到机器,可以使用yum的仅下载的选项或者yumdownloader命令实现,但需要解决好软件包的<code>依赖关系</code></p><ul><li>yum实现<ul><li>downloadonly是仅下载选项</li><li>downloaddir是指定下载位置</li><li>ansible是软件包的名字</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install --downloadonly --downloaddir=/root/ansible_rpms ansible -y</span><br></pre></td></tr></table></figure><ul><li>yumdownloader实现<ul><li>resolve是自动解决依赖</li><li>destdir是下载位置</li><li>ansible是软件包名</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumdownloader --resolve --destdir=/root/mypackages/ ansible</span><br></pre></td></tr></table></figure><h1>卸载软件包</h1><p>例如卸载openjdk 1.6版本,他会自动解决依赖关系,但是卸载的时候需要先看下哪些依赖被删除了</p><ul><li>remove</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove httpd</span><br></pre></td></tr></table></figure><ul><li>erase</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove httpd</span><br></pre></td></tr></table></figure><h1>查看yum操作历史记录</h1><p>查看 yum 事务信息，yum 是独占模式的进程，所以有时候查看事务信息还是有用的(有点高级没用会)</p><ul><li>查看 Yum 事务完整的历史记录<br>可以看见所有的yum操作历史</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum history </span><br></pre></td></tr></table></figure><ul><li>查看单独软件包的历史</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="built_in">history</span> info [事务<span class="built_in">id</span>或者包名]</span><br></pre></td></tr></table></figure><p>查看安装ansible的历史,可以看出:事务id,安装的包,作为依赖安装的包等</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> history <span class="literal">info</span> ansible</span><br></pre></td></tr></table></figure><ul><li>history子命令<br>history的子命令可以让我们撤销/重做/回滚事务<ul><li>undo:会撤销一个指定的事务</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum history undo 1</span><br></pre></td></tr></table></figure><ul><li>redo:重复一次指定的事务</li></ul>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> redo <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>rollback:撤销指定事务之后的所有事务</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum rollback 1</span><br></pre></td></tr></table></figure></li></ul><h1>更新</h1><ul><li>update<br>更新系统中的一个或多个软件包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h1>降级</h1><ul><li>downgrade<br>当包没有任何依赖关系时，降级是非常简单的,当使用这个命令产生了依赖关系的时候必须先降级依赖的版本</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> downgrade 包名</span><br></pre></td></tr></table></figure><h1>yum源属性配置</h1><p>可以用参数指定下载的源</p><ul><li>直接禁止仓库(直接)<ul><li>禁止仓库</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --disable epel</span><br></pre></td></tr></table></figure><ul><li>开启仓库</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --enable  epel </span><br></pre></td></tr></table></figure></li><li>使用选项指定  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd --enablerepo=base --disablerepo=yun</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装nvida显卡驱动</title>
      <link href="/posts/4ab62fe4.html"/>
      <url>/posts/4ab62fe4.html</url>
      
        <content type="html"><![CDATA[<h1>1.获取驱动文件</h1><ul><li>从英伟达官网下载对应显卡的驱动文件</li></ul><p><a href="http://www.nvidia.com">http://www.nvidia.com</a></p><h1>2.编辑Grub2将nouveau列入黑名单</h1><ul><li><p>编辑/etc/default/grub并将以下内容添加到grub_CMDLINE_LINUX行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe.blacklist=nouveau</span><br></pre></td></tr></table></figure></li><li><p>判断你的引导方式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -d  /sys/firmware/efi  ]  &amp;&amp;  echo UEFI  ||  echo  BIOS</span><br></pre></td></tr></table></figure><ul><li><p>重建grub配置并重新启动系统</p><ul><li><p>在BIOS-based的机器上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure></li><li><p>在UEFI-based的机器上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/efi/EFI/名字/grub.cfg</span><br></pre></td></tr></table></figure></li></ul></li><li><p>重启系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></li><li><p>重启验证nouveau是否存在,如果没东西输出才是对的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep -i nouveau</span><br></pre></td></tr></table></figure></li></ul><h1>3.安装显卡驱动</h1><ul><li><p>确保开发工具已经安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc make kernel-headers kernel-devel acpid libglvnd-glx libglvnd-</span><br><span class="line">opengl libglvnd-devel pkgconfig</span><br></pre></td></tr></table></figure></li><li><p>在X server服务运行的时候是无法成功安装驱动的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 3</span><br></pre></td></tr></table></figure></li><li><p>安装显卡驱动，遇到yes选yes就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh nvida.run</span><br></pre></td></tr></table></figure></li></ul><h1>4. 重建initramfs</h1><ul><li><p>备份当前的initramfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r)-nouveau.img</span><br></pre></td></tr></table></figure></li><li><p>重建一个新的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dracut /boot/initramfs-$(uname -r).img $(uname -r)</span><br></pre></td></tr></table></figure></li></ul><h1>5.重启系统验证</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 显卡驱动安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inode节点爆满处理</title>
      <link href="/posts/e5a0e4e9.html"/>
      <url>/posts/e5a0e4e9.html</url>
      
        <content type="html"><![CDATA[<h1>问题阐述</h1><p>磁盘容量没有满但是不能创建文件</p><h1>产生原因</h1><p>inode资源耗尽</p><h1>解决方法</h1><p>##查看inode节点状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -i</span><br></pre></td></tr></table></figure><p>可以看出根目录的inode占用率是100%,此时已经无法创建新的文件</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Filesystem Inodes  IUsed   IFree  IUse% Mounted on </span><br><span class="line">root       4964352 4964352  0     100%  /</span><br></pre></td></tr></table></figure><h2 id="删除无用的临时文件，释放inode">删除无用的临时文件，释放inode</h2><ul><li>find检查<br>使用find遍历将大小是0的文件列出来,为了防止误删,建议先查看文件是否需要</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp -type f -size 0</span><br></pre></td></tr></table></figure><p>如果确认某个目录下的文件不需要了可以加入exec一次删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp/log -type f -size 0 -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><ul><li>for循环<br>使用for循环查看某个目录下的文件数量,当定位到某个路径之后继续深挖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in /var/*; do echo $i; find $i | wc -l; done </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之df</title>
      <link href="/posts/d171c710.html"/>
      <url>/posts/d171c710.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>来自于英文词组&quot;Disk Free&quot;的缩写，其功能是用于显示系统上磁盘空间的使用量情况。</p><h1>选项</h1><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-a, --<span class="built_in">all</span>             显示所有系统文件</span><br><span class="line">-B, --<span class="keyword">block</span>-<span class="built_in">size</span>=<span class="built_in">SIZE</span> 指定显示时的块大小</span><br><span class="line">    --<span class="keyword">direct</span>          show statistics for a <span class="keyword">file</span> instead of mount point</span><br><span class="line">    --total           produce a grand total</span><br><span class="line">-h, --human-readable  以容易阅读的方式显示<span class="number">1024</span></span><br><span class="line">-H, --si              以容易阅读的方式显示<span class="number">1000</span></span><br><span class="line">-i, --inodes      显示inode 信息而非块使用量</span><br><span class="line">-k      即--<span class="keyword">block</span>-<span class="built_in">size</span>=<span class="number">1</span>K,指定块大小为<span class="number">1</span>KB</span><br><span class="line">-l, --<span class="keyword">local</span>           只显示本机的文件系统</span><br><span class="line">    --no-<span class="built_in">sync</span>      取得使用量数据前不进行同步动作(默认)</span><br><span class="line">    --output[=FIELD_LIST]  <span class="keyword">use</span> the output <span class="keyword">format</span> defined by FIELD_LIST,</span><br><span class="line">                             or <span class="built_in">print</span> <span class="built_in">all</span> fields <span class="keyword">if</span> FIELD_LIST is omitted.</span><br><span class="line">-P, --portability     <span class="keyword">use</span> the POSIX output <span class="keyword">format</span></span><br><span class="line">    --<span class="built_in">sync</span>            在取得磁盘使用信息前，先执行<span class="built_in">sync</span>命令</span><br><span class="line">-t, --<span class="keyword">type</span>=<span class="keyword">TYPE</span>       只显示指定类型的文件系统</span><br><span class="line">-T, --<span class="built_in">print</span>-<span class="keyword">type</span>      输出时显示文件系统类型</span><br><span class="line">-x, --exclude-<span class="keyword">type</span>=<span class="keyword">TYPE</span>   limit listing to <span class="keyword">file</span> systems not of <span class="keyword">type</span> <span class="keyword">TYPE</span></span><br><span class="line">-v                    (ignored)</span><br><span class="line">--help              显示此帮助信息并退出</span><br><span class="line">--version      显示版本信息并退出</span><br></pre></td></tr></table></figure><h1>用法</h1><h2 id="查看与挂载点有关的信息">查看与挂载点有关的信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -Th  # h是1024换算的</span><br></pre></td></tr></table></figure><h2 id="查看与挂载点有关的信息-2">查看与挂载点有关的信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -TH  # h是1000换算的</span><br></pre></td></tr></table></figure><h2 id="显示单个挂载点的信息">显示单个挂载点的信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -Th /</span><br></pre></td></tr></table></figure><h2 id="显示ext4的文件系统">显示ext4的文件系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h -t ext4</span><br></pre></td></tr></table></figure><h2 id="查看inode节点信息">查看inode节点信息</h2><blockquote><p>如果inode节点满了将无法继续创建文件,但可能此时磁盘还没有占满,所以需要更多关注inode节点相关信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之crontab</title>
      <link href="/posts/9191c4a8.html"/>
      <url>/posts/9191c4a8.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>周期性定时任务</p><h1>crontab语法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   #每（分时日月周）执行</span><br><span class="line">[a-b] #在a到b的时间段执行</span><br><span class="line">*/n #每n(分时日月周)执行一次</span><br><span class="line">[a,b,c] #第(分时日月周)执行</span><br></pre></td></tr></table></figure><h1>案例</h1><p>只要收录了一些时间用法，具体的执行的内容都用A代替</p><ul><li>每一分钟执行一次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*****A</span><br></pre></td></tr></table></figure><ul><li>在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span><span class="number">6</span>-<span class="number">12</span>/<span class="number">3</span>*<span class="number">12</span>*A</span><br></pre></td></tr></table></figure><ul><li>周一到周五每天下午 5:00 执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span><span class="number">17</span>**<span class="number">1</span>-<span class="number">5</span>A</span><br></pre></td></tr></table></figure><ul><li>每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分…执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">20</span><span class="number">0</span>-<span class="number">24</span>/<span class="number">2</span>***A</span><br></pre></td></tr></table></figure><ul><li>每两个小时执行</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span><span class="emphasis">*/2*</span>**  A</span><br></pre></td></tr></table></figure><ul><li>每天7：50执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">50</span><span class="number">7</span>***A</span><br></pre></td></tr></table></figure><ul><li>每天22：50执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">50</span><span class="number">22</span>***A</span><br></pre></td></tr></table></figure><ul><li>每月1号和15号执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span><span class="number">0</span><span class="number">1</span>,<span class="number">15</span>**A</span><br></pre></td></tr></table></figure><ul><li>每小时的第一分执行</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>**** <span class="selector-tag">A</span></span><br></pre></td></tr></table></figure><ul><li>每月的1、11、21、31日是的6：30执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">30</span><span class="number">6</span>*/<span class="number">10</span>**A</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
