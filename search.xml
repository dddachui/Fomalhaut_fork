<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>三剑客-sed</title>
      <link href="/posts/c9de9d82.html"/>
      <url>/posts/c9de9d82.html</url>
      
        <content type="html"><![CDATA[<h1>替换</h1><p>在Linux系统中，可以使用sed命令来替换文件中的文本内容。要将所有的“kylin”替换为“ikun”，可以使用以下命令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sed</span> -i <span class="string">&#x27;s/kun/ikun/g&#x27;</span> filename</span><br></pre></td></tr></table></figure><p>将上面的 <code>filename</code> 替换为实际的文件名，这个命令将直接修改这个文件，将其中所有的“kylin”替换为“ikun”。</p><p>解释一下命令中的选项和参数：</p><ul><li><code>-i</code>：表示直接修改文件内容，而不是输出到终端或另一个文件中。</li><li><code>s/kun/ikun/g</code>：这是一个正则表达式，表示将“kylin”替换为“ikun”。其中，<code>s</code>表示替换操作，<code>/</code>是分隔符，<code>g</code>表示全局替换，即将每个匹配的“kun”都替换为“ikun”。</li></ul><p>请注意，在使用sed命令修改文件内容时，建议先备份原文件，以防止意外修改导致数据丢失。</p><h1>增加</h1><p>在Linux系统中，可以使用sed命令来修改GRUB引导参数，以添加 <code>net.ifnames=1 biosdevname</code> 选项。要在quiet选项后增加这个选项，可以使用以下命令：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i <span class="string">&#x27;s/quiet/quiet net.ifnames=1 biosdevname/g&#x27;</span> <span class="regexp">/etc/</span><span class="keyword">default</span>/grub</span><br></pre></td></tr></table></figure><p>这个命令将修改 <code>/etc/default/grub</code> 文件，将其中的 <code>quiet</code> 选项替换为 <code>quiet net.ifnames=1 biosdevname</code>，并保存修改后的文件。</p><p>解释一下命令中的选项和参数：</p><ul><li><code>sudo</code>：表示使用管理员权限来执行命令。</li><li><code>-i</code>：表示直接修改文件内容，而不是输出到终端或另一个文件中。</li><li><code>s/quiet/quiet net.ifnames=1 biosdevname/g</code>：这是一个正则表达式，表示将 <code>quiet</code> 替换为 <code>quiet net.ifnames=1 biosdevname</code>。其中，<code>s</code>表示替换操作，<code>/</code>是分隔符，<code>g</code>表示全局替换，即将每个匹配的 <code>quiet</code> 都替换为 <code>quiet net.ifnames=1 biosdevname</code>。</li><li><code>/etc/default/grub</code>：指定要修改的GRUB配置文件的路径。</li></ul><h1>删除</h1><p>在Linux系统中，可以使用sed命令来删除文件中的特定文本行。要删除文件中的 <code>modprobe.blacklist=nouveau</code> 行，可以使用以下命令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sed</span> -i <span class="string">&#x27;/modprobe.blacklist=nouveau/d&#x27;</span> filename</span><br></pre></td></tr></table></figure><p>将上面的 <code>filename</code> 替换为实际的文件名，这个命令将直接修改这个文件，将其中所有包含 <code>modprobe.blacklist=nouveau</code> 的行删除。</p><p>解释一下命令中的选项和参数：</p><ul><li><code>-i</code>：表示直接修改文件内容，而不是输出到终端或另一个文件中。</li><li><code>/modprobe.blacklist=nouveau/d</code>：这是一个正则表达式，表示删除所有包含 <code>modprobe.blacklist=nouveau</code> 的行。其中，<code>/</code>是分隔符，<code>d</code>表示删除匹配的行。</li></ul><p>请注意，在使用sed命令修改文件内容时，建议先备份原文件，以防止意外修改导致数据丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暂存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之wall</title>
      <link href="/posts/c4b461e0.html"/>
      <url>/posts/c4b461e0.html</url>
      
        <content type="html"><![CDATA[<h1>使用方式</h1><ul><li>向所有终端广播</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wall &quot;hello&quot;</span><br></pre></td></tr></table></figure><ul><li>排除邮件前面的头条文本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wall -n &quot;hello&quot;</span><br></pre></td></tr></table></figure><ul><li>给组发信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wall -g <span class="built_in">test</span> <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos修改网卡名</title>
      <link href="/posts/63943f11.html"/>
      <url>/posts/63943f11.html</url>
      
        <content type="html"><![CDATA[<h1>需求</h1><p>centos6系统使用的网卡名都是eth开头的，而centos7以上都是以设备类型来划分的，如果使用不习惯或者有其他xp兴趣可以根据自己的喜好来修改</p><h1>参数解释</h1><h2 id="net-ifnames">net.ifnames</h2><p>用于控制Linux系统中网络接口的命名规则，在不同发行版上有不同的命名方式，该参数有三种选项</p><ul><li>0：使用传统的命名，一般来说安装系统的时候使用这个参数就可以了，但难免会碰到一样的机器网卡物理位置一样但实际每台机器顺序可能不一样的问题</li><li>1：使用基于连接的命名方式</li><li>2：使用基于路径的命名方式</li></ul><h3 id="biosdevname">biosdevname</h3><p><code>biosdevname</code> 参数是用于控制Linux系统中网络接口命名的一种机制。当该参数启用时，Linux系统会在命名网络接口时使用BIOS提供的设备名称，而不是使用传统的基于总线、插槽和端口的命名方式。</p><p>启用<code>biosdevname</code>参数的主要作用是简化网络接口的管理和配置，特别是在具有多个网络接口的系统中。使用BIOS提供的设备名称可以使网络管理员更容易识别和区分不同的网络接口，并更容易地配置和管理网络接口。</p><p>请注意，启用<code>biosdevname</code>参数可能会导致Linux系统中网络接口的命名方式发生变化，因此在启用该参数之前，建议备份网络接口的配置文件。此外，该参数需要BIOS支持，因此不是所有的系统都支持该参数</p><h1>centos6修改</h1><h2 id="移除优先级高的udev规则">移除优先级高的udev规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /lib/udev/rules.d/75-persistent-net-generator.rules  /tmp</span><br></pre></td></tr></table></figure><h2 id="修改udev规则">修改udev规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/udev/rules.d/70-persistent-net.rules</span><br></pre></td></tr></table></figure><p>修改内容如下,其中ATTR除是mac地址，NAME是你要修改的网卡名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACTION==&quot;add&quot;, SUBSYSTEM==&quot;net&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:2c:ad:8e&quot;, NAME=&quot;eth1&quot;</span><br></pre></td></tr></table></figure><h1>centos7 修改</h1><h2 id="修改引导">修改引导</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>在GRUB_CMDLINE_LINUX除加入<code>net.ifnames=1 bisodevname=0</code>选项并用<code>grub2-mkconfig</code>重新生成grub</p><h2 id="修改udev规则-2">修改udev规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/udev/rules.d/70-persistent-net.rules</span><br></pre></td></tr></table></figure><p>修改内容如下,其中ATTR除是mac地址，NAME是你要修改的网卡名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACTION==&quot;add&quot;, SUBSYSTEM==&quot;net&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:2c:ad:8e&quot;, NAME=&quot;eth1&quot;</span><br></pre></td></tr></table></figure><h2 id="修改配置文件">修改配置文件</h2><p>根据使用的网络管理器（NetworkManager或者Network）来修改配置文件，将网卡名替换掉</p><h2 id="重启验证">重启验证</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之auditctl</title>
      <link href="/posts/ee30c79.html"/>
      <url>/posts/ee30c79.html</url>
      
        <content type="html"><![CDATA[<ul><li>列出规则</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auditctl -l</span><br></pre></td></tr></table></figure><ul><li>写入规则</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auditctl -w 目录的绝对路径</span><br></pre></td></tr></table></figure><ul><li>删除规则</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">audictl -W 目录的绝对路径</span><br></pre></td></tr></table></figure><ul><li>审计状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auditctl -s</span><br></pre></td></tr></table></figure><ul><li>查看效果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ausearch -f 目录的绝对路径</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之devtoolset</title>
      <link href="/posts/d171c710.html"/>
      <url>/posts/d171c710.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>CentOS/RHEL Linux 发行版以稳定性著称，所有的软件都要尽可能 stable，导致的一个结果就是基础软件的版本非常的低，比如 CentOS 6.7（15年发布） 中 gcc 版本还是 4.4.7（12年的版本）。这对开发来说就不是很友好，比如我们想用 C++ 11 中的某个特性，就必须自己编译一个高版本的 gcc 出来，但是这会有另外一个问题，开发环境不好维护，如果自己有多台电脑或者多个人合作的项目，每台机器上都要自己编一份，维护起来就比较麻烦。</p><h1>解决办法</h1><p>devtoolset + scl<br>在centos7上默认gcc是4.8.5，如果需要gcc10可以安装devtoolset-10版本来支持，其他版本也如此</p><h1>devtoolset-7依赖关系</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先装这2两个依赖</span></span><br><span class="line">devtoolset-7-runtime-7.1-4.ky3.kb1.x86_64.rpm</span><br><span class="line">devtoolset-7-binutils-2.28-11.ky3.kb1.x86_64.rpm</span><br><span class="line">devtoolset-7-gcc-7.3.1-5.15.ky3.kb1.x86_64.rpm</span><br><span class="line">devtoolset-7-libstdc++-devel-7.3.1-5.15.ky3.kb1.x86_64.rpm</span><br><span class="line">devtoolset-7-gcc-c++-7.3.1-5.15.ky3.kb1.x86_64.rpm</span><br></pre></td></tr></table></figure><h1>切换</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scl enable devtoolset-10 bash </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之ethtool</title>
      <link href="/posts/c0d4357c.html"/>
      <url>/posts/c0d4357c.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>查看网口信息</p><h1>查看网卡信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool eth0</span><br></pre></td></tr></table></figure><ul><li>网卡信息如下<br>可以看出网卡的很多信息,包括网卡速率是百兆还是千兆</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Settings for enp2s0:</span><br><span class="line">        Supported ports: [ TP    MII ]</span><br><span class="line">        Supported link modes:   10baseT/Half 10baseT/Full</span><br><span class="line">                                100baseT/Half 100baseT/Full</span><br><span class="line">                                1000baseT/Half 1000baseT/Full</span><br><span class="line">        Supported pause frame use: Symmetric Receive-only</span><br><span class="line">        Supports auto-negotiation: Yes</span><br><span class="line">        Supported FEC modes: Not reported</span><br><span class="line">        Advertised link modes:  10baseT/Half 10baseT/Full</span><br><span class="line">                                100baseT/Half 100baseT/Full</span><br><span class="line">                                1000baseT/Half 1000baseT/Full</span><br><span class="line">        Advertised pause frame use: Symmetric Receive-only</span><br><span class="line">        Advertised auto-negotiation: Yes</span><br><span class="line">        Advertised FEC modes: Not reported</span><br><span class="line">        Link partner advertised link modes:  10baseT/Half 10baseT/Full</span><br><span class="line">                                             100baseT/Half 100baseT/Full</span><br><span class="line">                                             1000baseT/Full</span><br><span class="line">        Link partner advertised pause frame use: Symmetric</span><br><span class="line">        Link partner advertised auto-negotiation: Yes</span><br><span class="line">        Link partner advertised FEC modes: Not reported</span><br><span class="line">        Speed: 1000Mb/s  #当前速率</span><br><span class="line">        Duplex: Full     </span><br><span class="line">        Auto-negotiation: on</span><br><span class="line">        master-slave cfg: preferred slave</span><br><span class="line">        master-slave status: slave</span><br><span class="line">        Port: Twisted Pair</span><br><span class="line">        PHYAD: 0</span><br><span class="line">        Transceiver: external</span><br><span class="line">        MDI-X: Unknown</span><br><span class="line">        Supports Wake-on: pumbg</span><br><span class="line">        Wake-on: d</span><br><span class="line">        Link detected: yes  #是否连通物理网线</span><br></pre></td></tr></table></figure><h1>把网卡指示灯打开</h1><p>在网卡支持这种功能的前提下,使用此命令会使网卡的指示灯闪烁,但需要注意,有些系统会持续闪烁,但有些版本会闪烁几秒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -p eth0</span><br></pre></td></tr></table></figure><h1>查看网卡驱动程序信息</h1><p>查询指定的网络设备以获取相关的驱动程序信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -i eth0</span><br></pre></td></tr></table></figure><p>如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">driver: e1000</span><br><span class="line">version: 7.3.21-k8-NAPI</span><br><span class="line">firmware-version: </span><br><span class="line">expansion-rom-version: </span><br><span class="line">bus-info: 0000:02:01.0</span><br><span class="line">supports-statistics: yes</span><br><span class="line">supports-test: yes</span><br><span class="line">supports-eeprom-access: yes</span><br><span class="line">supports-register-dump: yes</span><br><span class="line">supports-priv-flags: no</span><br></pre></td></tr></table></figure><h1>列出网络接口统计信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -S eth0</span><br></pre></td></tr></table></figure><h1>设置网络接口速度</h1><p>eth0自适应100、1000，指定他是百兆</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -s eth0 speed 1000 duplex full autoneg off</span><br></pre></td></tr></table></figure><h1>重置网卡到自适应模式</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -r eth0</span><br></pre></td></tr></table></figure><h1>将ethtool的设置跟随网卡</h1><p>写在ifcfg-ethX配置里面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETHTOOL_OPTS=&quot;speed 100 deplex full autoneg off&quot;</span><br></pre></td></tr></table></figure><h1>查看错误信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -S eth0 | grep error</span><br></pre></td></tr></table></figure><p>同时，使用<code>ifconfig</code> 也可以看错误信息</p><h2 id="错误信息">错误信息</h2><ul><li>RX errors<br>表示总的收包的错误数量，这包括 too-long-frames 错误，Ring Buffer 溢出错误，crc 校验错误，帧同步错误，fifo overruns 以及 missed pkg 等等</li><li>RX dropped<br>表示数据包已经进入了 Ring Buffer，但是由于内存不够等系统原因，导致在拷贝到内存的过程中被丢弃</li><li>RX overruns<br>表示了 fifo 的 overruns，这是由于 Ring Buffer(aka Driver Queue) 传输的 IO 大于 kernel 能够处理的 IO 导致的，而 Ring Buffer 则是指在发起 IRQ 请求之前的那块 buffer。很明显，overruns 的增大意味着数据包没到 Ring Buffer 就被网卡物理层给丢弃了(就是ring buffer满之后先有drop收到的，再overrun没收的)，而 CPU 无法即使的处理中断是造成 Ring Buffer 满的原因之一</li><li>RX frame<br>表示 misaligned 的 frames</li></ul><h2 id="rx-crc-errors">rx_crc_errors</h2><p>在大多数情况下，增加rx_crc_errors的值意味着该问题出在网络模型的第1层，当在接口上接收到数据包时，它将经历数据完整性检查，这称为循环冗余检查。 如果数据包在该检查中失败，则将其标记为rx_crc_errors<br>1.更换电缆。<br>2.检查交换机配置。<br>3.更换网络接口卡。</p><h1>查看网卡</h1>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之expect</title>
      <link href="/posts/a5a7ce3.html"/>
      <url>/posts/a5a7ce3.html</url>
      
        <content type="html"><![CDATA[<h1>作用</h1><p>交互式自动输入</p><h1>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y expect</span><br></pre></td></tr></table></figure><h1>简单示例</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat expect.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/expec</span></span><br><span class="line">set timeout 20</span><br><span class="line">spawn ssh root@10.20.24.103</span><br><span class="line">expect &quot;root&quot;</span><br><span class="line">send &quot;paic1234\n&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之nmcli</title>
      <link href="/posts/6ad86d1e.html"/>
      <url>/posts/6ad86d1e.html</url>
      
        <content type="html"><![CDATA[<h1>NetworkManager</h1><ol><li>NetworkManager服务是管理和监控网络设置的守护进程,Centos7之前的版本都是通过network.service管理网络配置</li><li>到了Centos7就同时支持network.service和NetworkManager.service</li><li>在RHEL 8/Centos 8上已废弃network.service（默认不安装）,只能通过NetworkManager进行网络配置。</li><li>NetworkManager主要管理2个对象 <code>Connection</code>（网卡连接配置） 和 <code>Device</code>（网卡设备）,他们之间是多对一的关系,但是同一时刻只能有一个Connection对于Device才生效</li></ol><h1>启动方法</h1><p>启动+开机自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now NetworkManager</span><br></pre></td></tr></table></figure><h1>三种方法配置网络</h1><ol><li>通过nmcli connection add命令配置,会自动生成ifcfg文件</li><li>手动配置ifcfg文件,通过nmcli connection reload来加载生效</li><li>手动配置ifcfg文件,通过传统network.service来加载生效</li></ol><h1>nmcli基操</h1><p>NetworkManager在系统中的管理工具为nmcli,这个命令<code>嘎嘎好用</code></p><h2 id="查看所有连接">查看所有连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show </span><br></pre></td></tr></table></figure><h2 id="查看所有激活的连接">查看所有激活的连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show --active</span><br></pre></td></tr></table></figure><h2 id="查看指定的网口的连接">查看指定的网口的连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show eth0</span><br></pre></td></tr></table></figure><h2 id="关闭连接">关闭连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection down eth0</span><br></pre></td></tr></table></figure><h2 id="启用连接">启用连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up eth0</span><br></pre></td></tr></table></figure><h1>nmcli配置网络实例-dhcp</h1><h2 id="新增连接">新增连接</h2><ul><li>创建一个连接名<code>dachui</code>,使用ens33设备</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui type Ethernet ifname ens33</span><br></pre></td></tr></table></figure><h2 id="展示创建后的效果">展示创建后的效果</h2><p>(实在不想配图)<br>可以看出只有一个行<code>NAME</code>是ens33是激活的(因为激活的连接在终端显示绿色,或者用–active可以看出来)</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME    UUID                                  TYPE      DEVICE </span><br><span class="line">ens33   c96bc909-188e-ec64-3a96-6a90982b08ad  ethernet  ens33  </span><br><span class="line">dachui  4b27c0d3-17d5-434b-90d1-5ac57a0f6147  ethernet  --     </span><br><span class="line">ens34   94aea789-efb3-ef4c-81b0-e8b18ecc9797  ethernet  -- </span><br></pre></td></tr></table></figure><h2 id="查看dachui的配置">查看<code>dachui</code>的配置</h2><p>如果不加<code>grep</code>,他会显示很多信息,但我们只需要关注ipv4的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show dachui | grep ipv4</span><br></pre></td></tr></table></figure><h2 id="配置展示">配置展示</h2><p>可以看出第一行<code>ipv4.method</code>的是<code>auto</code>,他代表<code>dachui</code>这个连接是用<code>dhcp</code>的方式获取ip的</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ipv4.method:                            auto</span><br><span class="line">ipv4.dns:                               --</span><br><span class="line">ipv4.dns-search:                        --</span><br><span class="line">ipv4.dns-options:                       &quot;&quot;</span><br><span class="line">ipv4.dns-priority:                      0</span><br><span class="line">ipv4.addresses:                         --</span><br><span class="line">ipv4.gateway:                           --</span><br><span class="line">ipv4.routes:                            --</span><br><span class="line">ipv4.route-metric:                      -1</span><br><span class="line">ipv4.route-table:                       0 (unspec)</span><br><span class="line">ipv4.routing-rules:                     --</span><br><span class="line">ipv4.ignore-auto-routes:                否</span><br><span class="line">ipv4.ignore-auto-dns:                   否</span><br><span class="line">ipv4.dhcp-client-id:                    --</span><br><span class="line">ipv4.dhcp-timeout:                      0 (default)</span><br><span class="line">ipv4.dhcp-send-hostname:                是</span><br><span class="line">ipv4.dhcp-hostname:                     --</span><br><span class="line">ipv4.dhcp-fqdn:                         --</span><br><span class="line">ipv4.never-default:                     否</span><br><span class="line">ipv4.may-fail:                          是</span><br><span class="line">ipv4.dad-timeout:                       -1 (default)</span><br></pre></td></tr></table></figure><h2 id="激活dhcp">激活dhcp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con show ens33 | grep IP4</span><br></pre></td></tr></table></figure><ul><li>激活的结果<br>可以看出这边ipv4的地址已经自动获取了</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP4.ADDRESS[1]:                         192.168.42.135/24</span><br><span class="line">IP4.GATEWAY:                            192.168.42.2</span><br><span class="line">IP4.ROUTE[1]:                           dst = 0.0.0.0/0, nh = 192.168.42.2, mt = 102</span><br><span class="line">IP4.ROUTE[2]:                           dst = 192.168.42.0/24, nh = 0.0.0.0, mt = 102</span><br><span class="line">IP4.DNS[1]:                             192.168.42.2</span><br><span class="line">IP4.DOMAIN[1]:                          localdomain</span><br></pre></td></tr></table></figure><h1>nmcli配置网络实例-static</h1><p>刚才是展示的新增一个连接,使用默认的<code>dhcp</code>方式配置网络,但实际项目中需要使用静态ip的方式,配置静态的手段有很多,可以对现在有<code>连接</code>进行系iu改,也可以再创建一个<code>连接</code>并且同时指定他的ip地址</p><h2 id="一次性创建">一次性创建</h2><p>乍一看命令<code>嘎嘎</code>长,其实很简单</p><ul><li><code>嘎嘎</code>长的命令,其实可以更长</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui-static type ethernet ifname ens33 ipv4.method manual ipv4.address 192.168.42.5/24 ipv4.gateway 192.168.42.2</span><br></pre></td></tr></table></figure><blockquote><p>我拆开两部分分析</p></blockquote><ol><li>创建连接,指定模式<br>这边就是创建了<code>dahcui-static</code>的连接,使用<code>type</code>指定此连接为<code>ethernet</code>(以太网),并且设备是<code>ens33</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui-static type ethernet ifname ens33</span><br></pre></td></tr></table></figure><ol start="2"><li>配置网络要素<br>一个ip地址至少需要指定一个<code>ip</code>和<code>子网掩码</code>才可以生效,网关也是需要配置的,还有指定是手动</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ipv4</span>.method manual ipv4.address <span class="number">192.168.42.5</span>/<span class="number">24</span> ipv4.gateway <span class="number">192.168.42.2</span></span><br></pre></td></tr></table></figure><ul><li>激活连接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static | grep IP4</span><br></pre></td></tr></table></figure><blockquote><p>输出为下面的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP4.ADDRESS[1]:                         192.168.42.5/24</span><br><span class="line">IP4.GATEWAY:                            192.168.42.2</span><br><span class="line">IP4.ROUTE[1]:                           dst = 0.0.0.0/0, nh = 192.168.42.2, mt = 102</span><br><span class="line">IP4.ROUTE[2]:                           dst = 192.168.42.0/24, nh = 0.0.0.0, mt = 102</span><br><span class="line">IP4.DNS[1]:                             192.168.42.2</span><br><span class="line">IP4.DOMAIN[1]:                          localdomain</span><br></pre></td></tr></table></figure><h2 id="编辑连接">编辑连接</h2><p>如果之前是创建好了多个连接,但是需要修改,可以通过modify的方法</p><ul><li>提示一点<br>如果要修改,请看好原先的<code>连接</code>是<code>自动获取</code>还是<code>手动获取</code>,如果是自动,需要改模式</li></ul><blockquote><p>可以一并加入修改的,我只是拆开提示一下,遇到过一次改了半天没生效,一看连接方式是dhcp</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static ipv4.method manual </span><br></pre></td></tr></table></figure><ul><li>修改ip<br>也可以修改其他的,在输入<code>dachui-static</code>之后按<code>tap</code>会列举出所有的<code>配置项</code>,然后根据语法修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static ipv4.address 192.168.42.200/24</span><br></pre></td></tr></table></figure><ul><li>重启网卡<br>修改之后需要激活一下才能生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static</span><br></pre></td></tr></table></figure><blockquote><p>这样一个基本的nmlci创建连接就结束了</p></blockquote><h1>其他基操</h1><h2 id="增加路由">增加路由</h2><p>内网环境下,机器可能有多个网段,那么加路由肯定是必须的,比如我这需要访问<code>10.10.10.0/24</code>的机器,那么通过如下方法进行配置</p><ul><li>加路由</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static +ipv4.routes &quot;10.10.10.0/24 192.168.42.2&quot;</span><br></pre></td></tr></table></figure><ul><li>激活看信息</li></ul><ol><li>配置信息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP4.ROUTE[5]:                           dst = 10.10.10.0/24, nh = 192.168.42.2, mt = 102</span><br></pre></td></tr></table></figure><ol start="2"><li>路由信息</li></ol><ul><li>route展示</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><ul><li>输出结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.42.2    0.0.0.0         UG    102    0        0 ens33</span><br><span class="line">10.10.10.0      192.168.42.2    255.255.255.0   UG    102    0        0 ens33</span><br></pre></td></tr></table></figure><h2 id="删除路由">删除路由</h2><p>学会增加,也要学会删除</p><ul><li><code>乍一看</code>是不是一样的?其实将<code>+</code>改成<code>-</code>,然后<code>重新激活</code>就可以了</li></ul><blockquote><p>所以修改的逻辑很简单的,<code>+</code>就增加,<code>-</code>就是删除,<code>什么都不加</code>就是修改</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static -ipv4.routes &quot;10.10.10.0/24 192.168.42.2&quot;</span><br></pre></td></tr></table></figure><h2 id="增加ip">增加ip</h2><p>有时候需要在一个连接上加多个ip地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static +ipv4.addresses 2.2.2.2/16</span><br></pre></td></tr></table></figure><h2 id="删除连接">删除连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection delete dachui-static</span><br></pre></td></tr></table></figure><h2 id="网卡开机自启动">网卡开机自启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static autoconnect yes</span><br></pre></td></tr></table></figure><h1>nmtui</h1><p>其实nmcli的玩法有很多,但其实还有一个工具<code>nmtui</code>,他是<code>NetworkManager-tui</code>的一个工具,通过字符图形化配置网络</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之systemctl</title>
      <link href="/posts/5154c07a.html"/>
      <url>/posts/5154c07a.html</url>
      
        <content type="html"><![CDATA[<h1>systemd</h1><p>是一个用于linux的系统与服务管理器，内核启动后拉起的第一个进程，即init进程（用户空间1号进程），启动和维护各种用户开机的服务</p><h2 id="查看系统systemd的service情况">查看系统systemd的service情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type service</span><br></pre></td></tr></table></figure><h2 id="解析systemd启动过程中的性能数据">解析systemd启动过程中的性能数据</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemd-analyze #系统启动时间总览</span><br><span class="line">systemd-analyze plot &gt; p.svg#生成plot图</span><br><span class="line">systemd-analyze critical-chain  xxx.service #某服务依赖关系中耗时最长的链条</span><br></pre></td></tr></table></figure><h1>systemctl</h1><h2 id="查看系统单元">查看系统单元</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl</span><br><span class="line">systemctl  list-units</span><br></pre></td></tr></table></figure><h2 id="查看运行失败的单元">查看运行失败的单元</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl --failed</span><br></pre></td></tr></table></figure><h2 id="查看系统中安装的服务">查看系统中安装的服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files</span><br></pre></td></tr></table></figure><h2 id="启停查">启停查</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start httpd</span><br><span class="line">systemctl stop httpd</span><br><span class="line">systemctl status httpd</span><br></pre></td></tr></table></figure><h2 id="设置启动模式-图形-命令行">设置启动模式(图形/命令行)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl get-default</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开机启动图形界面</span></span><br><span class="line">systemctl set-default graphical.target</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">字符界面模式</span></span><br><span class="line">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell编程</title>
      <link href="/posts/e5954c2f.html"/>
      <url>/posts/e5954c2f.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-终端打印">1.终端打印</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.输出特殊符号需要转义</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.使用<span class="built_in">printf</span>带格式输出</span></span><br><span class="line">printf &quot;%-5s %-10s %-4s\n&quot; No Name Mark</span><br><span class="line">printf &quot;%-5s %-10s %-4.2f\n&quot; 1 Sarath 80.3456</span><br><span class="line">printf &quot;%-5s %-10s %-4.2f\n&quot; 2 James 90.9989</span><br><span class="line">printf &quot;%-5s %-10s %-4.2f\n&quot; 3 Jeff 77.564</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.输出颜色</span></span><br><span class="line">字体颜色:重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝</span><br><span class="line">色=34，洋红=35，青色=36，白色=37</span><br><span class="line">底色:重置=0，黑色=40，红色=41，绿色=42，黄色=43，</span><br><span class="line">蓝色=44，洋红=45，青色=46，白色=47</span><br><span class="line">echo -e &quot;\e[1;31m This is red text \e[0m&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.查看这个进程的变量</span></span><br><span class="line">cat /proc/$(pgrep java)/environ | tr &#x27;\0&#x27; &#x27;\n&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pgrep java     查看java进程的pid</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">tr</span> <span class="string">&#x27;\0&#x27;</span> <span class="string">&#x27;\n&#x27;</span>   格式化输出</span></span><br></pre></td></tr></table></figure><h2 id="2-环境变量">2.环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var=value ##变量赋值，没有空格</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.输出变量</span></span><br><span class="line">echo $(var)  #$()这个可以省略，但为了更好的显示建议加</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.变量长度</span></span><br><span class="line"><span class="meta prompt_">echo$</span><span class="language-bash">&#123;<span class="comment">#var&#125;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.输出当前用的哪种shell</span></span><br><span class="line">echo $SHELL</span><br><span class="line">echo $0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.检查是否是超户</span></span><br><span class="line">if [ $UID -ne 0 ]; then</span><br><span class="line">echo Non root user. Please run as root.</span><br><span class="line">else</span><br><span class="line">echo Root user</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="3-使用函数添加变量">3.使用函数添加变量</h2><h2 id="4-shell的数学运算">4.shell的数学运算</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">法1：定义的是字符串，使用<span class="built_in">let</span>直接计算</span></span><br><span class="line">no1=4</span><br><span class="line">no2=5</span><br><span class="line">let result=no1+no2</span><br><span class="line">echo $result</span><br><span class="line">let no1++</span><br><span class="line">let no1--</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">法2：操作符[]</span></span><br><span class="line">result=$[ no1 + no2 ]</span><br><span class="line">result=$[ $no1 + no2 ]</span><br></pre></td></tr></table></figure><h2 id="5-文件描述符和重定向">5.文件描述符和重定向</h2><p>0 —— stdin（标准输入）<br>1 —— stdout（标准输出）<br>2 —— stderr（标准错误）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将错误和正确分别写进文件</span></span><br><span class="line">cat a1   2&gt; stderr.txt   1&gt; stdout.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将命令的报错丢弃</span></span><br><span class="line">cat 1 2&gt;/dev/null</span><br></pre></td></tr></table></figure><h2 id="6-别名alias">6.别名alias</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias ifconfig=&#x27;ip a | grep ens&#x27;</span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><h2 id="7-时间">7.时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">date --date &quot;Jan 20 2001&quot; +%A</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">星期</span> </span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">a（例如：Sat）</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">A（例如：Saturday</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">月</span> </span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">b（例如：Nov）</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">B（例如：November）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">日</span>       </span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">d（例如：31）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">固定格式日期（mm/dd/yy）</span>   </span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">D（例如：10/18/10）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">年</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">y（例如：10）</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Y（例如：2010）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">小时</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">I或%H（例如：08）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分钟</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">M（例如：33）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">秒</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">S（例如：10）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">纳秒</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">N（例如：695208515）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Unix纪元时（以秒为单位）</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">s（例如：1290049486）</span></span><br></pre></td></tr></table></figure><h2 id="8-shell的调试">8.shell的调试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.使用vscode远程调试</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.bash -x a.sh</span></span><br></pre></td></tr></table></figure><h2 id="9-函数">9.函数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.1定义方式a</span></span><br><span class="line">function fname()</span><br><span class="line">&#123;</span><br><span class="line">statements;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.2.定义方式b</span></span><br><span class="line">fname()</span><br><span class="line">&#123;</span><br><span class="line">statements;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.使用方式</span></span><br><span class="line">fname #只需要使用函数名</span><br><span class="line">fname argv1 argv2 #传参数</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.函数返回值</span></span><br><span class="line">echo $? #输出函数返回值</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.1实例a</span></span><br><span class="line">fname()</span><br><span class="line">&#123;</span><br><span class="line">echo $1, $2; #访问参数1和参数2  $n就是第n个参数</span><br><span class="line">echo &quot;$@&quot;;#所有参数</span><br><span class="line">echo &quot;$*&quot;; #类似于$@，但是参数被作为单个实体</span><br><span class="line">return 0; #返回值</span><br><span class="line">&#125;</span><br><span class="line">fname 1 2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.2实例b</span></span><br><span class="line">CMD=&quot;ifconfig&quot; #command指代你要检测退出状态的目标命令</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CMD &gt; /dev/null</span></span><br><span class="line">if [ $? -eq 0 ];</span><br><span class="line">then</span><br><span class="line">echo &quot;$CMD executed successfully&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;$CMD terminated unsuccessfully&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="10-将命令序列的输出读入变量">10.将命令序列的输出读入变量</h2><h2 id="11-read读入输入值">11.read读入输入值</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;Enter input:&quot; var #显示提示信息</span><br><span class="line">read -s var   #用无回显的方式读取密码</span><br></pre></td></tr></table></figure><h2 id="12-字段分隔符和迭代器">12.字段分隔符和迭代器</h2><h2 id="13-if…else">13.if…else</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#1.if..else</span></span></span><br><span class="line">if condition;</span><br><span class="line">then</span><br><span class="line">commands;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#1.if..else if..else</span></span></span><br><span class="line">if condition;</span><br><span class="line">then</span><br><span class="line">commands;</span><br><span class="line">else if condition; then</span><br><span class="line">commands;</span><br><span class="line">else</span><br><span class="line">commands;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="14-比较测试">14.比较测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.计算条件</span></span><br><span class="line">[ $var -eq 0 ] #当 $var 等于 0 时，返回真</span><br><span class="line">[ $var -ne 0 ] #当 $var 为非 0 时，返回真</span><br><span class="line">-eq：等于</span><br><span class="line">-ne：不等于</span><br><span class="line">-gt：大于</span><br><span class="line">-lt：小于</span><br><span class="line">-ge：大于或等于</span><br><span class="line">-le：小于或等于</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.文件系统条件</span></span><br><span class="line">fpath=&quot;/etc/passwd&quot;</span><br><span class="line">if [ -e $fpath ]; then</span><br><span class="line">echo File exists;</span><br><span class="line">else</span><br><span class="line">echo Does not exist;</span><br><span class="line">fi</span><br><span class="line">[ -f $var ]：如果给定的变量包含正常的文件路径或文件名，则返回真。</span><br><span class="line">[ -x $var ]：如果给定的变量包含的文件可执行，则返回真。</span><br><span class="line">[ -d $var ]：如果给定的变量包含的是目录，则返回真。</span><br><span class="line">[ -e $var ]：如果给定的变量包含的文件存在，则返回真。</span><br><span class="line">[ -c $var ]：如果给定的变量包含的是一个字符设备文件的路径，则返回真。</span><br><span class="line">[ -b $var ]：如果给定的变量包含的是一个块设备文件的路径，则返回真。</span><br><span class="line">[ -w $var ]：如果给定的变量包含的文件可写，则返回真。</span><br><span class="line">[ -r $var ]：如果给定的变量包含的文件可读，则返回真。</span><br><span class="line">[ -L $var ]：如果给定的变量包含的是一个符号链接，则返回真。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.字符串比较</span></span><br><span class="line">[[ $str1 = $str2 ]]</span><br><span class="line">[[ $str1 == $str2 ]]</span><br><span class="line">[[ $str1 != $str2 ]]</span><br><span class="line">[[ $str1 &gt; $str2 ]] #如果str1的字母序比str2大，则返回真</span><br><span class="line">[[ -z $str1 ]]：如果str1包含的是空字符串，则返回真。</span><br><span class="line">[[ -n $str1 ]]：如果str1包含的是非空字符串，则返回真。</span><br></pre></td></tr></table></figure><h2 id="15-命令">15.命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.<span class="built_in">cat</span></span> </span><br><span class="line">cat -n a.txt #显示行号</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.xargs</span></span><br><span class="line">command | xargs#接收到的数据重新格式化</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.<span class="built_in">tr</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.<span class="built_in">md5sum</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5.加密指令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6.排序</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7.临时文件名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8.分隔文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9.批量重命名</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">10.生成文件</span></span><br><span class="line">dd if=/dev/zero of=junk.data bs=1M count=1#bs代表以字节为单位的块大小（block size），count代表需要被</span><br><span class="line">复制的块数</span><br><span class="line">https://www.cnblogs.com/licheng/archive/2008/03/21/1116492.htm</span><br></pre></td></tr></table></figure><h2 id="16-文本文件的交集与差集">16.文本文件的交集与差集</h2><h2 id="17-查找并删除重复文件">17.查找并删除重复文件</h2><h2 id="18-文件权限、所有权和粘滞位">18.文件权限、所有权和粘滞位</h2><h2 id="19-创建不可修改的文件">19.创建不可修改的文件</h2><h2 id="20-批量生成空白文件">20.批量生成空白文件</h2><h2 id="21-查找符号链接及其指向目标">21.查找符号链接及其指向目标</h2><h2 id="22-列举文件类型统计信息">22.列举文件类型统计信息</h2><h2 id="23-使用环回文件">23.使用环回文件</h2><h2 id="24-生成-ISO-文件及混合型-ISO">24.生成 ISO 文件及混合型 ISO</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.制作iso</span></span><br><span class="line">cat /dev/cdrom &gt; image.iso     #不好</span><br><span class="line">dd if=/dev/cdrom of=image.iso  #最好的方法</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mkisofs命令用于创建ISO文件系统。可以用cdrecord之类的工具将mkisofs的输出文件直接刻录到CD-ROM或DVD-ROM上</span></span><br><span class="line">mkisofs -V &quot;Label&quot; -o image.iso source_dir/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.isohybrid</span></span><br><span class="line">isohybrid image.iso</span><br><span class="line">dd if=image.iso of=/dev/sdb1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.用命令行刻录ISO</span></span><br><span class="line">cdrecord -v dev=/dev/cdrom image.iso -speed 8</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.操作光驱器</span></span><br><span class="line">eject  #弹开</span><br><span class="line">eject -t ##合上</span><br></pre></td></tr></table></figure><h1>25.统计文件的行数、单词数和字符数</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.统计行数</span></span><br><span class="line">wc -l file</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.统计单词数</span></span><br><span class="line">wc -w file</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.统计字符数</span></span><br><span class="line">wc -c file</span><br><span class="line">echo -n 1234 | wc -c #-n用于避免echo添加额外的换行符</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.不加参数</span></span><br><span class="line">wc file #文件的行数、单词数和字符数</span><br></pre></td></tr></table></figure><h1>26.tree目录</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.输出符合类型的文件</span></span><br><span class="line">tree /opt -P &quot;*.sh&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.打印目录树和大小</span></span><br><span class="line">tree -h</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tree命令可以生成HTML输出</span></span><br><span class="line">tree PATH -H http://localhost -o out.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>perl过滤mac地址</title>
      <link href="/posts/56f58a69.html"/>
      <url>/posts/56f58a69.html</url>
      
        <content type="html"><![CDATA[<ul><li>下载包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cpan.metacpan.org/authors/id/A/AB/ABIGAIL/Regexp-Common-2017060201.tar.gz</span><br></pre></td></tr></table></figure><ul><li>安装包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar xf Regexp-Common-2017060201.tar.gz </span><br><span class="line">cd Regexp-Common-2017060201/</span><br><span class="line">perl Makefile.PL</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>过滤指定网口mac地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 |perl -MRegexp::Common=net -lnE &#x27;say $&amp; if /$RE&#123;net&#125;&#123;MAC&#125;/g&#x27;</span><br></pre></td></tr></table></figure><ul><li>过滤指定网卡IPv4</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth1 |perl -MRegexp::Common=net -lnE &#x27;say $&amp; if /$RE&#123;net&#125;&#123;IPv4&#125;/g&#x27;</span><br></pre></td></tr></table></figure><ul><li>过滤指定网卡IPv6</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth1 |perl -MRegexp::Common=net -lnE &#x27;say $&amp; if /$RE&#123;net&#125;&#123;IPv6&#125;/g&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基操 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nfs搭建</title>
      <link href="/posts/941a0cef.html"/>
      <url>/posts/941a0cef.html</url>
      
        <content type="html"><![CDATA[<h1>环境</h1><ul><li>节点server,充当nfs服务端,ip是192.168.42.141</li><li>节点client,充当nfs客户端,ip是192.168.42.0/24下的，可以ping通</li><li>机器均关闭selinux（我不用）</li><li>机器均关闭firewalld （我也不用）</li></ul><h1>服务端配置</h1><ul><li>安装软件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils rpcbind</span><br></pre></td></tr></table></figure><ul><li>创建服务端nfs目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/nfs-server</span><br><span class="line">chmod 777 /mnt/nfs-server</span><br></pre></td></tr></table></figure><ul><li>配置/etc/exports文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面是放开192.168.42.0/24网段</span></span><br><span class="line">/mnt/nfs-server 192.168.42.0/24(rw,sync,no_root_squash)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">也可以放开所有的网段，写法如下</span></span><br><span class="line">/mnt/nfs-server *(ro)</span><br></pre></td></tr></table></figure><ul><li>查看服务端NFS共享目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showmount -e</span><br></pre></td></tr></table></figure><ul><li>设置服务端自启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nfs-server rpcbind</span><br><span class="line">systemctl start nfs-server rpcbind</span><br></pre></td></tr></table></figure><ul><li>检测nfs端口是否正常</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:111</span><br></pre></td></tr></table></figure><ul><li>防火墙配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭防火墙，</span></span><br><span class="line">systemctl disable --now firewalld</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不关闭防火墙的就自己配置吧</span></span><br></pre></td></tr></table></figure><h1>客户端配置</h1><ul><li>安装软件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br></pre></td></tr></table></figure><ul><li>设置nfs挂载目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/nfs-data</span><br></pre></td></tr></table></figure><ul><li>检查server的nfs共享目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showmount -e 192.168.42.141</span><br></pre></td></tr></table></figure><ul><li>手动挂载</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount 192.168.42.141:/home/nfs-server  /mnt/nfs-data</span><br></pre></td></tr></table></figure><ul><li>查看挂载</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -Th</span><br></pre></td></tr></table></figure><ul><li>写入fstab</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">写入fstab设置开机自动挂载</span></span><br><span class="line">/mnt/nfs-server /mnt/nfs-data  nfs defaults,_netdev 0 0 </span><br></pre></td></tr></table></figure><ul><li>测试fstab</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先卸载手动挂载的</span></span><br><span class="line">umount /mnt/nfs-data</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行mount -a</span></span><br><span class="line">mount -a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看挂载</span></span><br><span class="line">df -Th</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安装部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux快速查找库文件位置</title>
      <link href="/posts/3a97f081.html"/>
      <url>/posts/3a97f081.html</url>
      
        <content type="html"><![CDATA[<p>ldconfig -p | grep lib_name</p><p>ldconfig -p 会打印出当前系统已经安装的动态库信息，然后使用 grep 找你的 lib 即可<br><a href="https://blog.csdn.net/bjbz_cxy/article/details/108517003">https://blog.csdn.net/bjbz_cxy/article/details/108517003</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 库文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GRUB了解</title>
      <link href="/posts/1be27d0f.html"/>
      <url>/posts/1be27d0f.html</url>
      
        <content type="html"><![CDATA[<h1>什么是GRUB</h1><ol><li>一个来自GNU的多操作系统启动程序</li><li>计算机读取到第一个扇区的512字节找到gurb之后，由用户选择哪个系统</li></ol><h1>boot下文件</h1><ol><li>vmlinux文件</li><li>initramfs虚拟文件系统<br>linux内核启动前，GRUB会将虚拟文件系统加载到内存，内核启动时，会在访问真正的根文件系统之前先访问该内存中的虚拟文件系统，虚拟文件系统的目的是为访问真正的根文件扫清障碍，最主要的目的是加载根文件系统存储介质的驱动模块</li></ol><h1>GRUB用法</h1><ul><li>安装GRUB</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-install /dev/sda</span><br></pre></td></tr></table></figure><ul><li>生成配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><ul><li>常用命令</li></ul><ol><li>insmod 插入模块</li><li>lsmod 显示已经加载的</li><li>set</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set root=(hd0,msdos1) #设置根目录</span><br><span class="line">set default=0 #设置默认菜单</span><br><span class="line">set timout=5 #设置超时</span><br><span class="line">set prefix=(hd0,msdos1)/EFI/grub</span><br></pre></td></tr></table></figure><ol start="4"><li>linux  加载linux内核</li><li>initrd 加载初始化RAM数据模块</li><li>boot</li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grub的相关操作</title>
      <link href="/posts/b72ca0dc.html"/>
      <url>/posts/b72ca0dc.html</url>
      
        <content type="html"><![CDATA[<h1>grubby操作</h1><ul><li>查看默认引导内核</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grubby --default-kernel</span><br></pre></td></tr></table></figure><ul><li>查看所有内核</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grubby --info=ALL</span><br></pre></td></tr></table></figure><ul><li>修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grubby --set-default /boot/vmlinuz-4.18.0-80.11.2.el8_0.x86_64\</span><br></pre></td></tr></table></figure><h1>查看可引导的内核数量</h1><ul><li>UEFI</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F\&#x27; &#x27;$1==&quot;menuentry &quot; &#123;print $2&#125;&#x27; /boot/efi/EFI/kylin/grub.cfg</span><br></pre></td></tr></table></figure><ul><li>LEGACY</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /boot/grub2/grub.cfg |grep menuentry</span><br></pre></td></tr></table></figure><h1>修改引导顺序</h1><ul><li>使用命令修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-set-default &#x27;KylinSec OS Linux (6.2.0-rc1) 3 (Core)&#x27;</span><br></pre></td></tr></table></figure><ul><li>使用数字修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-set-default 0</span><br></pre></td></tr></table></figure><ul><li>查看修改启动项的结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-editenv list</span><br></pre></td></tr></table></figure><ul><li>生成grub.cfg</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">uefi</span></span><br><span class="line">grub2-mkconfig -o /boot/efi/EFI/kylin/grub.cfg </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bios</span></span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><h1>查看vmlinux参数</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grubby --info=/boot/vmlinuz-6.2.0-rc1</span><br></pre></td></tr></table></figure><h1>centos6的修改</h1><ol><li>查看/etc/grub.conf文件，确认系统内核的情况，如下图所示系统存在2个内核的现象。从上往下内核版本依次是2.6.32-573.18.1.el6.x86_64和2.6.32-431.23.3.el6.x86_64。</li><li>在grub.conf文件中决定开机使用哪个内核版本做启动的参数是default，默认值为0，代表从最新的内核启动。代表启动的内核版本从上往下依次是0、1、2等。</li><li>如果要选择从旧版内核，即系统最开始的内核启动，则把default值改为1 ，然后重启服务器从新的内核进行引导</li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux统计实时网速的方法</title>
      <link href="/posts/a9e5246.html"/>
      <url>/posts/a9e5246.html</url>
      
        <content type="html"><![CDATA[<h1>noload</h1><p>通过nload命令来统计网速<br>-t 刷新时间间隔 500ms<br>-u b/k/m/g 网速单位 依次字节/KB/MB/GB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nload eth0 -u g -m </span><br></pre></td></tr></table></figure><h1>sar</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -n DEV 1 100</span><br></pre></td></tr></table></figure><h1>ifconfig</h1><p>RX: 接收流量<br>TX: 发送流量<br>计算方法：(<strong>KB</strong> = 数值/1000) (<strong>MB</strong> = 数值/100000)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 ifconfig </span><br></pre></td></tr></table></figure><h1>iftop</h1>]]></content>
      
      
      <categories>
          
          <category> 网络管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络连接数量查看</title>
      <link href="/posts/acb02ade.html"/>
      <url>/posts/acb02ade.html</url>
      
        <content type="html"><![CDATA[<h2 id="查看哪些IP连接本机">查看哪些IP连接本机</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><h2 id="查看TCP连接数">查看TCP连接数</h2><ul><li>统计80端口连接数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat|grep -i &quot;80&quot;|wc -l</span><br></pre></td></tr></table></figure><ul><li>统计httpd协议连接数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep httpd|wc -l</span><br></pre></td></tr></table></figure><ul><li>统计已连接上的，状态为“established</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -na|grep ESTABLISHED|wc -l</span><br></pre></td></tr></table></figure><ul><li>查出哪个IP地址连接最多,将其封了</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -na|grep ESTABLISHED|awk &#123;print $5&#125;|awk -F: &#123;print $1&#125;|sort|uniq -c|sort -r +0n</span><br><span class="line">netstat -na|grep SYN|awk &#123;print $5&#125;|awk -F: &#123;print $1&#125;|sort|uniq -c|sort -r +0n</span><br></pre></td></tr></table></figure><ul><li>查看apache前并发访问数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep ESTABLISHED | wc -l</span><br></pre></td></tr></table></figure><ul><li>查看有多少个进程数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep httpd|wc -l</span><br></pre></td></tr></table></figure><h1>字段解释</h1><p>TIME_WAIT 8947 等待足够的时间以确保远程TCP接收到连接中断请求的确认<br>FIN_WAIT1 15 等待远程TCP连接中断请求，或先前的连接中断请求的确认<br>FIN_WAIT2 1 从远程TCP等待连接中断请求<br>ESTABLISHED 55 代表一个打开的连接<br>SYN_RECV 21 再收到和发送一个连接请求后等待对方对连接请求的确认<br>CLOSING 2 没有任何连接状态<br>LAST_ACK 4 等待原来的发向远程TCP的连接中断请求的确认</p><h1>TCP连接状态详解</h1><p>LISTEN： 侦听来自远方的TCP端口的连接请求<br>SYN-SENT： 再发送连接请求后等待匹配的连接请求<br>SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认<br>ESTABLISHED： 代表一个打开的连接<br>FIN-WAIT-1： 等待远程TCP连接中断请求，或先前的连接中断请求的确认<br>FIN-WAIT-2： 从远程TCP等待连接中断请求<br>CLOSE-WAIT： 等待从本地用户发来的连接中断请求<br>CLOSING： 等待远程TCP对连接中断的确认<br>LAST-ACK： 等待原来的发向远程TCP的连接中断请求的确认<br>TIME-WAIT： 等待足够的时间以确保远程TCP接收到连接中断请求的确认<br>CLOSED： 没有任何连接状态</p>]]></content>
      
      
      <categories>
          
          <category> 网络管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络连接数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网卡改名脚本使用</title>
      <link href="/posts/74b3b75a.html"/>
      <url>/posts/74b3b75a.html</url>
      
        <content type="html"><![CDATA[<h1>问题</h1><ul><li>网卡名要按照客户需求改</li></ul><h1>解决</h1><h2 id="1-修改grub">1.修改grub</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure><ul><li>添加 net.ifnames=1 biosdevname=0 如下图所示</li></ul><p><img src="images/%E5%9B%BE%E5%BA%93/image-20220331170233957.png" alt="image-20220331170233957"></p><h2 id="2-重建">2.重建</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><p><img src="images/%E5%9B%BE%E5%BA%93/image-20220331170404356.png" alt="image-20220331170404356"></p><h2 id="3-执行脚本">3.执行脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ifcfg_cluster_manage create /var/log/ifcfg_cluster_manage.log</span><br></pre></td></tr></table></figure><ul><li>在/etc/udev/rules.d/会生成70-persistent-net.rules配置，修改网卡名和/etc/sysconfig/network-scripts/下面的配置一致就可以了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网卡改名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网卡多队列</title>
      <link href="/posts/2e0e8049.html"/>
      <url>/posts/2e0e8049.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bbsmax.com/A/6pdDbDgkJw/">https://www.bbsmax.com/A/6pdDbDgkJw/</a><br><a href="https://www.cnblogs.com/mauricewei/p/10502300.html">https://www.cnblogs.com/mauricewei/p/10502300.html</a></p><h1>什么是网卡多队列</h1><p>如果在多核 CPU 的服务器上，网卡内部会有多个 Ring Buffer，NIC 负责将传进来的数据分配给不同的 Ring Buffer，同时触发的 IRQ 也可以分配到多个 CPU 上，这样存在多个 Ring Buffer 的情况下 Ring Buffer 缓存的数据也同时被多个 CPU 处理，就能提高数据的并行处理能力</p><p>通常情况下，一张网卡会有一个队列用来接发收网络数据包，我们所说的一个队列你也可以理解成一个处理数据包的进程。</p><p>但是随着时代的发展，网卡支持的流量带宽越来越大，如果还是使用一个队列来接收网络数据包，必然容易造成数据包阻塞和单cpu处理不过来。于是出现了一批高端的智能网卡，这些网卡可以支持使用多个队列来接发收数据包。比如1822网卡</p><p>队列个数也可以根据情况设置，一个队列可以理解是一个处理数据包的进程，多个队列对应多个进程，这些进程可以分散到不同的cpu去处理，这样就缓解了单cpu的执行压力。</p><p>哪么网卡收到数据包后交给哪个队列处理呢？网卡驱动会根据数据包的源目的IP等五元组信息计算一个hash值，然后交由对应的队列处理。</p><h1>查看网卡是否支持</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -l eth0</span><br></pre></td></tr></table></figure><ul><li>如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@localhost ~]# ethtool -l eth0</span><br><span class="line">Channel parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX: 0</span><br><span class="line">TX: 0</span><br><span class="line">Other: 0</span><br><span class="line">Combined: 2  #大于1  表示支持多队列</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX: 0</span><br><span class="line">TX: 0</span><br><span class="line">Other: 0</span><br><span class="line">Combined: 2  #当前的多队列数量，大于1标识开启了</span><br></pre></td></tr></table></figure><h1>调整</h1><ul><li><h3 id="调整-Ring-Buffer-队列数量">调整 Ring Buffer 队列数量</h3></li></ul><p>注意，设置的队列数的前提是网卡首先要支持多队列，且不能超过网卡支持的最大的队列数。当网卡驱动比较老旧的时候，也有可能会设置失败，建议将网卡驱动先升级至最新版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -L eth1-combined 16</span><br></pre></td></tr></table></figure><ul><li><h3 id="调整-Ring-Buffer-队列大小">调整 Ring Buffer 队列大小</h3></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ethtool -G eth0 rx 4096</span><br><span class="line">````</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网卡收到的数据包统计</span></span><br><span class="line">- ### 网卡收到的数据包统计</span><br><span class="line">```shell</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">RX 就是收到数据，TX 是发出数据</span></span><br><span class="line">ethtool -S em1 | more</span><br></pre></td></tr></table></figure><ul><li><h3 id="带有-drop-字样的统计和-fifo-errors-的统计">带有 drop 字样的统计和 fifo_errors 的统计</h3></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">发送队列和接收队列 drop 的数据包数量显示在这里。并且所有 queue_drops 加起来等于 rx_fifo_errors。所以总体上能通过 rx_fifo_errors 看到 Ring Buffer 上是否有丢包。如果有的话一方面是看是否需要调整一下每个队列数据的分配，或者是否要加大 Ring Buffer 的大小</span></span><br><span class="line">ethtool -S em1 | grep -iE &quot;error|drop&quot;</span><br></pre></td></tr></table></figure><ul><li>查看ring buf大小</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">RX 和 TX 最大是 4096，当前值为 256 。队列越大丢包的可能越小，但数据延迟会增加</span></span><br><span class="line">ethtool -g eth0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结果如下</span></span><br><span class="line">Ring parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX: 2048</span><br><span class="line">RX Mini: 0</span><br><span class="line">RX Jumbo: 0</span><br><span class="line">TX: 2048</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX: 2048</span><br><span class="line">RX Mini: 0</span><br><span class="line">RX Jumbo: 0</span><br><span class="line">TX: 2048</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口转发</title>
      <link href="/posts/c0e91c93.html"/>
      <url>/posts/c0e91c93.html</url>
      
        <content type="html"><![CDATA[<p>有时，两个主机A、C之间网络并不互通，但A和B互通，B和C互通，这种情况下，我们可以利用B主机做一个端口转发，使得主机A可以访问主机C上的网络服务。</p><p>能够实现端口转发的软件有很多，如iptables、socat、portmap、rinetd等，而ssh也是常见的一个，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh本地端口转发，在A机器上执行，会在A机开启2001端口，并将此端口数据发到B机，B机又转发到C机的80端口</span></span><br><span class="line">ssh -fgN -L2001:host_c:80 work@host_b</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh远端端口转发，在B机器上执行，在A机开启22333端口(由A机sshd服务打开)，将A机22333端口流量通过B机(中转机)转到C机的80端口上</span></span><br><span class="line">ssh -fgN -R 22333:host_c:80 work@host_a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh远端动态端口转发，在B机器上执行，会在A机开启2222端口开放socks代理服务，被代理的数据会发到B机，B机又转发到任何B机能访问的网络服务上</span></span><br><span class="line">ssh -fgN -R 2222 work@host_a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh本地动态端口转发，在A机器上执行，会在A机开启2222端口开放socks代理服务，被代理的数据会发到B机，B机又转发到任何B机能访问的网络服务上</span></span><br><span class="line">ssh -Nfg -D 2222 work@host_b</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A机通过本机socks代理，登录到C机</span></span><br><span class="line">ssh -o ProxyCommand=&#x27;ncat --proxy 127.0.0.1:2222 --proxy-type socks5 %h %p&#x27; work@host_c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A机通过B机ssh登录C机，其实就是两次ssh登录过程</span></span><br><span class="line">ssh -t work@host_b &#x27;ssh work@host_c&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 端口转发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志分割</title>
      <link href="/posts/59127654.html"/>
      <url>/posts/59127654.html</url>
      
        <content type="html"><![CDATA[<h1>memory日志太大了</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.2系统</span></span><br><span class="line">vim /etc/logrotate.d/memory</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rotate设置小一点</span></span><br><span class="line">service crond restart</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.3</span></span><br><span class="line">systemctl  stop   kylin-memory-monitor.service</span><br><span class="line">systemctl  disable   kylin-memory-monitor.service</span><br></pre></td></tr></table></figure><h1>创建一个日志测试logrotate</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.创建一个10M日志文件</span></span><br><span class="line">touch /var/log/test-log</span><br><span class="line">head -c 10M &lt; /dev/urandom &gt; /var/log/test-log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.创建日志管理文件</span></span><br><span class="line">vim /etc/logrotate.d/test-log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内容如下</span></span><br><span class="line">/var/log/test-log &#123;</span><br><span class="line">    weekly  #每周转储</span><br><span class="line">    rotate 10 #保留10个备份，对于第11个归档，时间最久的会被删除</span><br><span class="line">    compress #gzip压缩转储的备份文件</span><br><span class="line">    delaycompress #转储的日志文件到下一次转储时才压缩</span><br><span class="line">    missingok #任何错误将被忽略,例如“文件无法找到</span><br><span class="line">    notifempty #日志为空不轮询</span><br><span class="line">    create 644 root root</span><br><span class="line">    postrotate #在所有其它指令完成后，postrotate和endscript里面指定的命令将被执行</span><br><span class="line">        /usr/bin/killall -HUP rsyslogd</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.手动运行logrotate</span></span><br><span class="line">logrotate /etc/logrotate.d/test-log</span><br><span class="line">grep &#x27;test-log&#x27; /var/lib/logrotate/logrotate.status  #查看轮训的操作</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lvm分区-缩小</title>
      <link href="/posts/47785311.html"/>
      <url>/posts/47785311.html</url>
      
        <content type="html"><![CDATA[<h1>删除lv给其他分区扩容</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看卷组名</span></span><br><span class="line">df -h </span><br><span class="line">umount /dev/mapper/删除的卷组</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改fstab</span></span><br><span class="line">vim /etc/fstab  </span><br><span class="line">lvremove /dev/mapper/删除的卷组 </span><br><span class="line">lvextend -l +100%FREE /dev/mapper/扩容的卷组</span><br><span class="line">resize2fs /dev/mapper/扩容的卷组      </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果不能umount</span> </span><br><span class="line">fuser -m /home/d5000/hg/var</span><br><span class="line">ps -aux | grep pid</span><br><span class="line">kill -9 pid</span><br><span class="line">fuser -mkvi /home/d5000/hg/var</span><br></pre></td></tr></table></figure><h1>缩减某个分区给其他扩容</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">umount  **** #要缩减分区的挂载点</span><br><span class="line">e2fsck -f /dev/mapper/VolGroup-LogVol02  #检查需要被缩减的</span><br><span class="line">resize2fs -p /dev/mapper/VolGroup-LogVol02 250G #减少文件系统最大到250G</span><br><span class="line">lvreduce -L -250G /dev/mapper/VolGroup-LogVol02   #减少250G</span><br><span class="line">vgdisplay</span><br><span class="line">lvextend -l +100%FREE /dev/mapper/VolGroup-LogVol00  #给需要扩容的分区拉升</span><br><span class="line">e2fsck -f /dev/mapper/VolGroup-LogVol00</span><br><span class="line">resize2fs /dev/mapper/VolGroup-LogVol00</span><br><span class="line">mount -a</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lvm分区-删除</title>
      <link href="/posts/c2f93c19.html"/>
      <url>/posts/c2f93c19.html</url>
      
        <content type="html"><![CDATA[<h1>卸载需要删除的分区</h1><ul><li>删除磁盘前需要确认已经umount，否则会失败</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看分区和挂载点信息</span></span><br><span class="line">df -h</span><br></pre></td></tr></table></figure><ul><li>挂载点信息如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件系统                        容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/kylinsec-root        26G  7.1G   18G   30% /</span><br><span class="line">/dev/sda1                       976M  198M  712M   22% /boot</span><br><span class="line">/dev/mapper/test_vg-home_kylin  380M  2.3M  354M    1% /home/kylin</span><br></pre></td></tr></table></figure><ul><li>首先需要卸载<code>/home/kylin</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /home/kylin</span><br></pre></td></tr></table></figure><h1>查看逻辑卷信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvdisplay</span><br></pre></td></tr></table></figure><ul><li>只截取了home_kylin的信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--- Logical volume ---</span><br><span class="line">LV Path                /dev/test_vg/home_kylin</span><br><span class="line">LV Name                home_kylin</span><br><span class="line">VG Name                test_vg</span><br><span class="line">LV UUID                bA2Rjo-YS01-vTAd-Ze1f-DdwP-lvaf-ugZt7N</span><br><span class="line">LV Write Access        read/write</span><br><span class="line">LV Creation host, time ceshi, 2022-05-31 10:08:19 +0800</span><br><span class="line">LV Status              available</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">open                 1</span></span><br><span class="line">LV Size                400.00 MiB</span><br><span class="line">Current LE             100</span><br><span class="line">Segments               1</span><br><span class="line">Allocation             inherit</span><br><span class="line">Read ahead sectors     auto</span><br><span class="line">- currently set to     8192</span><br><span class="line">Block device           253:2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用lvremove删除此分区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lvremove 后面接的是LV Path对应的名字</span></span><br><span class="line">lvremove  /dev/test_vg/home_kylin</span><br></pre></td></tr></table></figure><ul><li>确认/etc/fstab是否有相关的信息,将与这块磁盘的信息删除</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/fstab</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lvm分区-扩容</title>
      <link href="/posts/fe1e1d04.html"/>
      <url>/posts/fe1e1d04.html</url>
      
        <content type="html"><![CDATA[<h1>利用剩余空闲扩容</h1><ul><li>查看空闲空间</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgdisplay</span><br></pre></td></tr></table></figure><ul><li>内容如下<br>可以看出Free PE有3839块，其中一块pe是4m，那么Free Pe的大小就是3839*4=15356m</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--- Volume group ---</span><br><span class="line"> VG Name               vg_test</span><br><span class="line"> System ID             </span><br><span class="line"> Format                lvm2</span><br><span class="line"> Metadata Areas        1</span><br><span class="line"> Metadata Sequence No  2</span><br><span class="line"> VG Access             read/write</span><br><span class="line"> VG Status             resizable</span><br><span class="line"> MAX LV                0</span><br><span class="line"> Cur LV                1</span><br><span class="line"> Open LV               1</span><br><span class="line"> Max PV                0</span><br><span class="line"> Cur PV                1</span><br><span class="line"> Act PV                1</span><br><span class="line"> VG Size               &lt;20.00 GiB</span><br><span class="line"> PE Size               4.00 MiB</span><br><span class="line"> Total PE              5119</span><br><span class="line"> Alloc PE / Size       1280 / 5.00 GiB</span><br><span class="line"> Free  PE / Size       3839 / &lt;15.00 GiB</span><br><span class="line"> VG UUID               GDHYHs-f1Yd-vmop-dLWR-VlRQ-h8ju-S5Tkr4</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给vg卷组扩容</span></span><br><span class="line">vgextend vg_name /dev/sdb</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给具体分区扩容,具体分区可以<span class="built_in">df</span> -Th看出来</span></span><br><span class="line">lvextend -L +200M /dev/mapper/vg_home</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lvextend -l +100%FREE /dev/mapper/vg_home</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lvm分区-创建</title>
      <link href="/posts/b174c19e.html"/>
      <url>/posts/b174c19e.html</url>
      
        <content type="html"><![CDATA[<h1>创建lvm分区</h1><ul><li>系统中加入了一块新的磁盘，利用新的磁盘创建分区</li></ul><h2 id="1-查看磁盘">1.查看磁盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><ul><li>可以看到如下,其中sdb是新插入的磁盘</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME              MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda                 8:0    0   30G  0 disk </span><br><span class="line">├─sda1              8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2              8:2    0   29G  0 part </span><br><span class="line">  ├─kylinsec-root 253:0    0   26G  0 lvm  /</span><br><span class="line">  └─kylinsec-swap 253:1    0    3G  0 lvm  <span class="section">[SWAP]</span></span><br><span class="line">sdb                 8:16   0    1G  0 disk </span><br><span class="line">sr0                11:0    1 1024M  0 rom  </span><br></pre></td></tr></table></figure><h2 id="2-创建物理卷">2.创建物理卷</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/sdb</span><br></pre></td></tr></table></figure><h2 id="3-创建卷组">3.创建卷组</h2><p>使用sdb硬盘,创建出一块名为<code>test_vg</code>的卷组设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgcreate test_vg /dev/sdb</span><br></pre></td></tr></table></figure><h2 id="4-创建逻辑卷">4.创建逻辑卷</h2><p>在已有的卷组中（test_vg）创建一个逻辑卷（home_nice），大小为400G</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvcreate  -n  home_kylin -L 400G  test_vg</span><br></pre></td></tr></table></figure><p>如果需要使用所有的空间可以这么写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvcreate  -n  home_kylin -l +100%FREE  test_vg</span><br></pre></td></tr></table></figure><h2 id="5-格式化逻辑卷">5.格式化逻辑卷</h2><p>首先需要获取逻辑卷的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -p</span><br></pre></td></tr></table></figure><ul><li>其中<code>/dev/mapper/test_vg-home_kylin</code>是刚创建的逻辑卷</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lsblk -p的信息</span> </span><br><span class="line">NAME                            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">/dev/sda                          8:0    0   30G  0 disk </span><br><span class="line">├─/dev/sda1                       8:1    0    1G  0 part /boot</span><br><span class="line">└─/dev/sda2                       8:2    0   29G  0 part </span><br><span class="line">  ├─/dev/mapper/kylinsec-root   253:0    0   26G  0 lvm  /</span><br><span class="line">  └─/dev/mapper/kylinsec-swap   253:1    0    3G  0 lvm  [SWAP]</span><br><span class="line">/dev/sdb                          8:16   0    1G  0 disk </span><br><span class="line">└─/dev/mapper/test_vg-home_kylin 253:2    0  400M  0 lvm  </span><br><span class="line">/dev/sr0                         11:0    1 1024M  0 rom  </span><br></pre></td></tr></table></figure><ul><li>使用mkfs进行格式化</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">示例中使用的是ext4文件系统,还可以选择xfs等其他文件系统</span></span><br><span class="line">mkfs.ext4 /dev/mapper/test_vg-home_kylin</span><br></pre></td></tr></table></figure><h2 id="6-挂载磁盘到系统">6.挂载磁盘到系统</h2><p>提供了2种方式,6.1是临时挂载,6.2是永久挂载,推荐使用<code>永久挂载</code>方式</p><h2 id="6-1临时挂载磁盘">6.1临时挂载磁盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个临时的目录</span></span><br><span class="line">mkdir /home/kylin</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">挂载逻辑卷</span></span><br><span class="line">mount /dev/mapper/test_vg-home_kylin  /home/kylin</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看挂载信息</span></span><br><span class="line">df -Th</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">挂载的信息如下</span></span><br><span class="line">文件系统                       容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/kylinsec-root       26G  7.0G   18G   29% /</span><br><span class="line">devtmpfs                       1.9G     0  1.9G    0% /dev</span><br><span class="line">tmpfs                          2.0G     0  2.0G    0% /dev/shm</span><br><span class="line">tmpfs                          2.0G   13M  2.0G    1% /run</span><br><span class="line">tmpfs                          2.0G     0  2.0G    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                      976M  198M  712M   22% /boot</span><br><span class="line">tmpfs                          393M   28K  393M    1% /run/user/0</span><br><span class="line">/dev/mapper/test_vg-home_kylin  380M  2.3M  354M    1% /home/data</span><br></pre></td></tr></table></figure><h2 id="6-2将磁盘永久挂载到系统">6.2将磁盘永久挂载到系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需要修改/etc/fstab文件</span></span><br><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure><ul><li>方法1：使用路径挂载</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在/etc/fstab最后加入,其中ext4是文件系统类型,需要和格式化(mkfs)时的保持一致</span></span><br><span class="line">/dev/mapper/test_vg-home_kyin   /home/kylin        ext4    defaults        1 1</span><br></pre></td></tr></table></figure><ul><li>方法2：使用UUID挂载</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用blkid查看磁盘的UUID</span></span><br><span class="line">blkid</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结果如下（只截取了需要的内容）</span></span><br><span class="line">/dev/mapper/test_vg-home_kylin: UUID=&quot;e98054f6-b74b-49fb-9c9d-04fd53c831b0&quot; TYPE=&quot;ext4&quot; </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将/dev/mapper/test_vg-home_kylin的UUID值加入就可以了</span></span><br><span class="line">UUID=e98054f6-b74b-49fb-9c9d-04fd53c831b0   /        ext4    defaults        1 1</span><br></pre></td></tr></table></figure><p>验证fstab修改是否正确,如果已经临时挂载了,需要先将挂载的磁盘umount,才能验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lvm缩减分区给其他分区扩容</title>
      <link href="/posts/f1dd7c95.html"/>
      <url>/posts/f1dd7c95.html</url>
      
        <content type="html"><![CDATA[<h1>缩减某个分区给其他扩容</h1><ul><li>缩减</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">umount  /home/test #取消挂载</span><br><span class="line">e2fsck -f /dev/mapper/VolGroup-LogVol02  #检查需要被缩减的文件系统</span><br><span class="line">resize2fs -p /dev/mapper/VolGroup-LogVol02 200G  #缩小到文件系统的200G</span><br><span class="line">lvreduce -L 200G /dev/mapper/VolGroup-LogVol02   #减少到200G</span><br></pre></td></tr></table></figure><ul><li>扩容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vgdisplay  #查看vg</span><br><span class="line">lvextend -l +100%FREE /dev/mapper/VolGroup-LogVol00  #给需要扩容的分区扩容</span><br><span class="line">e2fsck -f /dev/mapper/VolGroup-LogVol00  #检查需要被缩减的文件系统</span><br><span class="line">resize2fs /dev/mapper/VolGroup-LogVol00  #扩大文件系统的大小</span><br><span class="line">mount -a  #挂载文件系统</span><br><span class="line">df -h    #检查分区</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘调度算法更改</title>
      <link href="/posts/11e6e6a1.html"/>
      <url>/posts/11e6e6a1.html</url>
      
        <content type="html"><![CDATA[<h1>修改磁盘调度算法为deadline</h1><ul><li>修改grub.conf配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/grub.conf</span><br></pre></td></tr></table></figure><ul><li>在quiet后添加参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elevator=deadline</span><br></pre></td></tr></table></figure><ul><li>重启生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><ul><li>校验是否生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i scheduler</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/block/sda/queue/scheduler</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁盘管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Kernel编译的基本步骤</title>
      <link href="/posts/e0dd0b18.html"/>
      <url>/posts/e0dd0b18.html</url>
      
        <content type="html"><![CDATA[<h1>下载源码包</h1><p>主页 <a href="https://www.kernel.org/">https://www.kernel.org/</a><br>各种版本 <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/">https://mirrors.edge.kernel.org/pub/linux/kernel/</a><br>以你发行版的常规通用内核启动系统，然后把所有日常使用中涉及到的程序、游戏、图形界面、视频硬解码全部跑一遍，包括KVM虚拟机、PCI显卡直通，并且插上所有的硬件（包括鼠标、键盘、外接显示器、USB、移动硬盘、摄像头、蓝牙、WiFi等）</p><h1>解压内核源码包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf linux-4.19.90.tar.xz -C /usr/src/kernels/</span><br><span class="line">cd /usr/src/kernels/linux-4.19.90</span><br></pre></td></tr></table></figure><h1>配置内核</h1><h2 id="手动配置">手动配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">默认第一种</span></span><br><span class="line">make menuconfig #终端图形化配置内核</span><br><span class="line">make xconfig #页面图形化配置</span><br><span class="line">make gconfig #gtk图形化配置内核</span><br></pre></td></tr></table></figure><h2 id="自动配置">自动配置</h2><p>让机器自动化配置驱动，跳出的提示中不确定的建议选Y，免得漏掉驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make localyesconfig</span><br></pre></td></tr></table></figure><h1>优化参数(可以选，需要自己斟酌)</h1><ol><li>cd进入内核源码目录,禁用kernel debug</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;/select DEBUG_KERNEL/d&#x27; ./init/Kconfig</span><br></pre></td></tr></table></figure><ol start="2"><li>以Clang启动内核配置界面<br>使用Clang（LLVM）编译器编译</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make LLVM=1 LLVM_IAS=1 menuconfig</span><br></pre></td></tr></table></figure><h1>编译</h1><ul><li>普通编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j num</span><br></pre></td></tr></table></figure><ul><li>clang优化</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make LLVM=1 LLVM_IAS=1 -jN </span><br></pre></td></tr></table></figure><h1>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装内核模块</span></span><br><span class="line">make modules_install</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装内核</span></span><br><span class="line">make install </span><br></pre></td></tr></table></figure><h1>配置引导</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h1>打成RPM和DEB包</h1><ul><li>make的选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make help </span><br></pre></td></tr></table></figure><ul><li>RPM</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j12  rpm-pkg</span><br></pre></td></tr></table></figure><ul><li>DEB</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j12 deb-pkg</span><br></pre></td></tr></table></figure><h1>翻阅教程</h1><p><a href="https://www.iyunw.cn/archives/centos-nei-he-bian-yi-sheng-ji/">https://www.iyunw.cn/archives/centos-nei-he-bian-yi-sheng-ji/</a><br><a href="https://blog.51cto.com/tiankefeng/1393082">https://blog.51cto.com/tiankefeng/1393082</a><br><a href="https://xugaoxiang.com/2020/05/25/how-to-build-linux-kernel/">https://xugaoxiang.com/2020/05/25/how-to-build-linux-kernel/</a><br><a href="https://zhuanlan.zhihu.com/p/603301187">https://zhuanlan.zhihu.com/p/603301187</a></p>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言相关，编译等知识</title>
      <link href="/posts/506189b5.html"/>
      <url>/posts/506189b5.html</url>
      
        <content type="html"><![CDATA[<h1>Hello World</h1><ul><li>创建helloworld.c文件</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译（一步到位）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc helloworld.c -o  helloworld </span><br></pre></td></tr></table></figure><ul><li>执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./helloworld</span><br></pre></td></tr></table></figure><ul><li>使用makefile编译</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:</span></span><br><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><h1>编译的流程</h1><ol><li>【编译】将源文件©变成目标文件(o)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">会生成hello.o文件</span></span><br><span class="line">gcc -c  hello.c</span><br></pre></td></tr></table></figure><ol start="2"><li>【链接】将目标文件(o)变成可执行文件(二进制)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成可执行文件hello</span></span><br><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure><h1>头文件</h1><h2 id="作用">作用</h2><p>在include的地方，把里的内容原封不动的复制到引用该头文件的地方，头文件里一般包括宏定义， 全局变量， 函数原型声明。</p><ul><li>引用方式</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">或</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="常见报错">常见报错</h2><p>编译的时候常见xxx.h没有找到，一般都是代码里面引用了该头文件，但系统里面没有安装</p><ul><li>文件在哪里</li></ul><ol><li>存放在xxx-devel包里面</li><li>内核里面kernel-headers里面</li><li>等等。。</li></ol><h1>静态链接和动态链接</h1><h2 id="对比">对比</h2><ol><li>静态链接在链接的时候，就把所依赖的第三方库函数都打包到了一起，导致最终的可执行文件非常大，动态链接在链接的时候并不将那些库文件直接拿过来，而是在运行时，发现用到某些库中的某些函数时，再从这些第三方库中读取自己所需的方法。</li><li>编译后但是还未链接的二进制机器码文件目标文件Object File，例如别人写的第三方库，这些库里面包含了一些函数，直接调用而不用自己写，在编译构建自己的可执行文件时，使用静态链接的方式，其实就是将所需的静态库与目标文件打包到一起。最终的可执行文件除了有自己的程序外，还包含了这些第三方的静态库，可执行文件比较臃肿。</li><li>动态链接不将所有的第三方库都打包到最终的可执行文件上，而是只记录用到了哪些动态链接库，在运行时才将那些第三方库装载（Load）进来。装载是指将磁盘上的程序和数据加载到内存上。</li></ol><h1>动态链接库</h1><h2 id="库文件">库文件</h2><pre><code>不同操作系统的动态链接库文件格式稍有不同Linux称之为共享目标文件（Shared Object），后缀是so，Windows的动态链接库（Dynamic Link Library）文件后缀为`.dll`</code></pre><h2 id="案例">案例</h2><p>将这几个文件编译成一个动态库：<a href="http://libtest.so">libtest.so</a></p><ul><li>so_test.h</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SO_TEST_H_ </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SO_TEST_H_ </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_a</span><span class="params">()</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">test_b</span><span class="params">()</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">test_c</span><span class="params">()</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _SO_TEST_H_ */</span></span></span><br></pre></td></tr></table></figure><ul><li>test_a.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;so_test.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_a</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is in test_a \n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>test_b.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;so_test.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_b</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;this is in test_b \n&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><ul><li>编译so</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-fPIC是位置无关码，-shared是按照共享库的方式来链接</span></span><br><span class="line">gcc test_a.c test_b.c -fPIC -shared -o libtest.so</span><br></pre></td></tr></table></figure><ul><li>生成主程序main.c<br>将main.c与动态库libtest.so链接生成执行文件main</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;so_test.h&quot;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123; test_a(); test_c(); test_b(); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><ul><li>编译主程序</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-L参数：指明要链接的so库所在路径（如-L. 表示当前路径， -L../so 表示当前路径的上一层目录的so子文件夹中）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-l参数：指明要连接的库的名字，如-ltest 表示要链接libtest.so库</span></span><br><span class="line">gcc main.c -L. -ltest -o main</span><br></pre></td></tr></table></figure><ul><li>运行主程序<br>错误原因：<a href="http://xn--mainlibtest-mx9qw7n9vkjpeyqr05rc3m8ugumndrgu8nj30fmgo7yutw8ftw9c.so">在执行main程序的时候发现它动态链接了libtest.so</a>，<a href="http://xn--libaston-i20mf9brxu9mdx2ovjqfzbx5x2l2a400e588d5jp.so">于是会去固定目录尝试加载libaston.so</a>，如果加载失败则会打印以上错误信息。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error while loading shared libraries: libaston.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><ul><li>解决找不到so的问题</li></ul><ol><li>解决方法一：<br>将libtest.so放到固定目录下就可以了，这个固定目录一般是/usr/lib目录。（cp <a href="http://libtest.so">libtest.so</a> /usr/lib即可）</li><li>解决方法二：<br>使用环境变量LD_LIBRARY_PATH。将libtest.so所在目录导出到LD_LIBRARY_PATH即可。<br>如：export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/mnt/hgfs/winshare/so_test</li></ol><h2 id="缺点">缺点</h2><pre><code>-   如果将一份目标文件移植到一个新的操作系统上，而新的操作系统缺少相应的共享库，程序将无法运行，必须在操作系统上安装好相应的库才行-   共享库必须按照一定的开发和升级规则升级，不能突然重构所有的接口，且新库文件直接覆盖老库文件，否则程序将无法运行。</code></pre><h2 id="查看可执行文件引用的库文件">查看可执行文件引用的库文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd a.out</span><br></pre></td></tr></table></figure><h2 id="命名">命名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#lib是前缀，这是一个约定俗成的规则。x为主版本号（Major Version），y为次版本号（Minor Version），z为发布版本号（Release Version）。</span><br><span class="line">libname.so.x.y.z</span><br><span class="line"><span class="number">1.</span>Major Version表示重大升级，不同Major Version之间的库是不兼容的。Major Version升级后，或者依赖旧Major Version的程序需要更新代码，重新编译，才可以在新的Major Version上运行；或者操作系统保留旧Major Version，使得老程序依然能运行。 </span><br><span class="line"><span class="number">2.</span>Minor Version表示增量更新，一般是增加了一些新接口，原来的接口不变。所以，在Major Version相同的情况下，Minor Version从高到低是兼容的。</span><br><span class="line"><span class="number">3.</span>Release Version表示库的一些bug修复，性能改进等，不添加任何新的接口，不改变原来的接口。</span><br></pre></td></tr></table></figure><h2 id="查找过程">查找过程</h2><ol><li>Linux的动态链接库绝大多数都在<code>/lib</code>和<code>/usr/lib</code>下，操作系统也会默认去这两个路径下搜索动态链接库。另外，<code>/etc/ld.so.conf</code>文件里可以配置路径，<code>/etc/ld.so.conf</code>文件会告诉操作系统去哪些路径下搜索动态链接库。这些位置的动态链接库很多，如果链接器每次都去这些路径遍历一遍，非常耗时，Linux提供了<code>ldconfig</code>工具，这个工具会对这些路径的动态链接库按照SONAME规则创建软连接，同时也会生成一个缓存Cache到<code>/etc/ld.so.cache</code>文件里，链接器根据缓存可以更快地查找到各个<code>.so</code>文件。每次在<code>/lib</code>和<code>/usr/lib</code>这些路径下安装了新的库，或者更改了<code>/etc/ld.so.conf</code>文件，都需要调用<code>ldconfig</code>命令来做一次更新，重新生成软连接和Cache。但是<code>/etc/ld.so.conf</code>文件和<code>ldconfig</code>命令最好使用root账户操作。非root用户可以在某个路径下安装库文件，并将这个路径添加到<code>/etc/ld.so.conf</code>文件下，再由root用户调用一下<code>ldconfig</code></li><li>对于非root用户，另一种方法是使用<code>LD_LIBRARY_PATH</code>环境变量。<code>LD_LIBRARY_PATH</code>存放着若干路径。链接器会去这些路径下查找库。非root可以将某个库安装在了一个非root权限的路径下，再将其添加到环境变量中</li><li>总结<ol><li><code>LD_LIBRARY_PATH</code>环境变量中的路径</li><li><code>/etc/ld.so.cache</code>缓存文件</li><li><code>/usr/lib</code>和<code>/lib</code></li></ol></li></ol><h2 id="关于软连接">关于软连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">例如ldd看到的libc.so.6</span></span><br><span class="line">libc.so.6 =&gt; /lib64/libc.so.6</span><br></pre></td></tr></table></figure><p>其实这里的<code>libc.so.6</code>是一个软链接，实际上链接到了/lib64/libc.so.6 -&gt; <a href="http://libc-2.17.so">libc-2.17.so</a><br>因为不同的Major Version之间不兼容，而Minor Version和Release Version都是向下兼容的，软连接会指向Major Version相同，Minor Version和Release Version最高的<code>.so</code>文件上。</p><h1>gcc编译选项</h1><ol><li>使用GCC编译链接时，有两个参数需要注意，一个是<code>-l</code>（小写的L），一个是<code>-L</code>（大写的L）</li><li>Linux有个约定速成的规则，假如库名是name，那么动态链接库文件名就是<code>libname.so</code></li><li>在使用GCC编译链接时，<code>-lname</code>来告诉GCC使用哪个库</li><li>链接时，GCC的链接器<code>ld</code>就会前往<code>LD_LIBRARY_PATH</code>环境变量、<code>/etc/ld.so.cache</code>缓存文件和<code>/usr/lib</code>和<code>/lib</code>目录下去查找<code>libname.so</code></li><li>我们也可以用<code>-L/path/to/library</code>的方式，让链接器<code>ld</code>去<code>/path/to/library</code>路径下去找库文件<br>如果动态链接库文件在<code>/path/to/library</code>，库名叫name，编译链接的方式如下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -L/path/to/library -lname myfile.c</span><br></pre></td></tr></table></figure><h1>编译遇到过的报错</h1><ul><li>未定义的引用<br><a href="http://xn--xx-qh5cy36e3w2ay7ppeh.so">编译时遇到xx.so</a>:对‘xxx’未定义的引用，C/C++编译为<code>obj</code>文件的时候并不需要函数的具体实现，只要有函数的原型即可。但是在链接为可执行文件的时候就必须要具体的实现了。如果错误是<code>未声明的引用</code>，那就是找不到函数的原型，通常是相关的头文件未包含，<code>缺少了函数的具体实现，那么就给它这个函数的实现就好了</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译等基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pam加固</title>
      <link href="/posts/6167a74.html"/>
      <url>/posts/6167a74.html</url>
      
        <content type="html"><![CDATA[<h1>加固内容</h1><ul><li>系统服务</li><li>文件权限</li><li>内核参数</li><li>授权认证</li><li>账号口令</li></ul><h1>账户口令加固</h1><h2 id="屏蔽帐户">屏蔽帐户</h2><ul><li>说明<br>除了用户帐户外，其他账号称为系统帐户。系统帐户仅系统内部使用，禁止用于登录系统或其他操作</li><li>实现<br>将系统帐户的Shell修改为/sbin/nologin</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -s /sbin/nologin systemaccountname</span><br></pre></td></tr></table></figure><h2 id="限制使用su命令的帐户">限制使用su命令的帐户</h2><ul><li>说明<br>su命令用于在不同帐户之间切换。为了增强系统安全性，有必要对su命令的使用权进行控制，只允许root和wheel群组的帐户使用su命令，限制其他帐户使用。</li><li>实现<br>su命令的使用控制通过修改/etc/pam.d/su文件实现</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth         required      pam_wheel.so use_uid</span><br></pre></td></tr></table></figure><blockquote><p>use_uid是基于当前帐户的uid</p></blockquote><h2 id="设置口令复杂度">设置口令复杂度</h2><ul><li>说明<br>密码复杂度</li><li>实现<br>/etc/pam.d/password-auth和/etc/pam.d/system-auth文件中的pam_pwquality.so和pam_pwhistory.so模块实现</li><li>设置举例</li></ul><ol><li>口令长度至少8个字符。</li><li>口令必须包含如下至少3种字符的组合：<ul><li>至少一个小写字母</li><li>至少一个大写字母</li><li>至少一个数字</li><li>至少一个特殊字符：`~!@#$%^&amp;*()-_=+|[{}];:'&quot;,&lt;.&gt;/?和空格</li></ul></li><li>口令不能和帐号或者帐号的倒写一样。</li><li>不能修改为过去5次使用过的旧口令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">password    requisite     pam_pwquality.so minlen=8 minclass=3 enforce_for_root try_first_pass local_users_only retry=3 dcredit=0 ucredit=0 lcredit=0 ocredit=0 </span><br><span class="line">password    required      pam_pwhistory.so use_authtok remember=5 enforce_for_root</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>配置项说明<br>pam_pwquality.so说明</li></ul><ol><li>minlen=8 口令长度至少包含8个字符</li><li>minclass=3 口令至少包含大写字母、小写字母、数字和特殊字符中的任意3种</li><li>ucredit=0 口令包含任意个大写字母</li><li>lcredit=0 口令包含任意个小写字母</li><li>dcredit=0 口令包含任意个数字</li><li>ocredit=0 口令包含任意个特殊字符</li><li>retry=3 每次修改最多可以尝试3次</li><li>enforce_for_root 本设置对root帐户同样有效<br>pam_pwhistory.so说明</li><li>remember=5 口令不能修改为过去5次使用过的旧口令</li><li>enforce_for_root 本设置对root帐户同样有效</li></ol><h2 id="设置口令有效期">设置口令有效期</h2><ul><li>说明<br>出于系统安全性考虑，建议设置口令有效期限，且口令到期前通知用户更改口令，login.defs是设置用户帐号限制的文件，可配置口令的最大过期天数、最大长度约束等。该文件里的配置对root用户无效，如果/etc/shadow文件里有相同的选项，则以/etc/shadow配置为准，即/etc/shadow的配置优先级高于/etc/login.defs。口令过期后用户重新登录时，提示口令过期并强制要求修改，不修改则无法进入系统</li><li>实现</li></ul><p>口令有效期的设置通过修改/etc/login.defs文件实现</p><table><thead><tr><th><strong>加固项</strong></th><th><strong>加固项说明</strong></th><th>建议加固</th></tr></thead><tbody><tr><td>PASS_MAX_DAYS</td><td>口令最大有效期</td><td>90</td></tr><tr><td>PASS_MIN_DAYS</td><td>两次修改口令的最小间隔时间</td><td>0</td></tr><tr><td>PASS_WARN_AGE</td><td>口令过期前开始提示天数</td><td>7</td></tr></tbody></table><h2 id="设置口令的加密算法">设置口令的加密算法</h2><ul><li>说明</li></ul><p>出于系统安全考虑，口令不允许明文存储在系统中，应该加密保护。在不需要还原口令的场景，必须使用不可逆算法加密。设置口令的加密算法为sha512，通过上述设置可以有效防范口令泄露，保证口令安全。</p><ul><li>实现</li></ul><p>口令的加密算法设置通过修改/etc/pam.d/password-auth和/etc/pam.d/system-auth文件实现，添加如下配置：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password    sufficient    pam_unix.so <span class="keyword">sha512 </span><span class="keyword">shadow </span>nullok try_first_pass use_authtok</span><br></pre></td></tr></table></figure><h2 id="登录失败超过三次后锁定">登录失败超过三次后锁定</h2><ul><li>说明</li></ul><p>为了保障用户系统的安全，建议用户设置口令出错次数的阈值（建议3次），以及由于口令尝试被锁定用户的自动解锁时间（建议300秒）。</p><p>用户锁定期间，任何输入被判定为无效，锁定时间不因用户的再次输入而重新计时；解锁后，用户的错误输入记录被清空。通过上述设置可以有效防范口令被暴力破解，增强系统的安全性。</p><ul><li>实现</li></ul><p>口令复杂度的设置通过修改/etc/pam.d/password-auth和/etc/pam.d/system-auth文件实现，设置口令最大的出错次数3次，系统锁定后的解锁时间为300秒的配置如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auth        required      pam_faillock.so preauth audit <span class="attribute">deny</span>=3 even_deny_root <span class="attribute">unlock_time</span>=300</span><br><span class="line">auth        [<span class="attribute">default</span>=die] pam_faillock.so authfail audit <span class="attribute">deny</span>=3 even_deny_root <span class="attribute">unlock_time</span>=300</span><br><span class="line">auth        sufficient    pam_faillock.so authsucc audit <span class="attribute">deny</span>=3 even_deny_root <span class="attribute">unlock_time</span>=300</span><br></pre></td></tr></table></figure><p>pam_faillock.so说明</p><table><thead><tr><th>authfail</th><th>捕获用户登录失败的事件。</th></tr></thead><tbody><tr><td>deny=3</td><td>用户连续登录失败次数超过3次即被锁定。</td></tr><tr><td>unlock_time=300</td><td>普通用户自动解锁时间为300秒（即5分钟）。</td></tr><tr><td>even_deny_root</td><td>同样限制root帐户。</td></tr></tbody></table><h2 id="加固su命令">加固su命令</h2><ul><li>说明</li></ul><p>为了增强系统安全性，防止使用“su”切换用户时将当前用户环境变量带入其他环境</p><ul><li>实现</li></ul><p>通过修改/etc/login.defs实现，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_SET_PATH=yes</span><br></pre></td></tr></table></figure><h1>授权认证</h1><h2 id="设置网络远程登录的警告信息">设置网络远程登录的警告信息</h2><ul><li>说明</li></ul><p>设置网络远程登录的警告信息，用于在登录进入系统之前向用户提示警告信息，明示非法侵入系统可能受到的惩罚，吓阻潜在的攻击者。同时也可以隐藏系统架构及其他系统信息，避免招致对系统的目标性攻击。</p><ul><li>实现</li></ul><p>该设置可以通过修改/etc/issue.net文件的内容实现。将/etc/issue.net文件原有内容替换为如下信息</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fbi <span class="keyword">open</span> the <span class="keyword">door</span></span><br></pre></td></tr></table></figure><h2 id="禁止通过-Ctrl-Alt-Del-重启系统">禁止通过&quot;Ctrl+Alt+Del&quot;重启系统</h2><ul><li>说明</li></ul><p>操作系统默认能够通过“Ctrl+Alt+Del”进行重启，建议禁止该项特性，防止因为误操作而导致数据丢失。</p><ul><li>实现</li></ul><ol><li><p>删除两个ctrl-alt-del.target文件，参考命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -f /etc/systemd/system/ctrl-alt-del.target</span><br><span class="line">rm -f /usr/lib/systemd/system/ctrl-alt-del.target</span><br></pre></td></tr></table></figure></li><li><p>修改/etc/systemd/system.conf文件，将#CtrlAltDelBurstAction=reboot-force修改为CtrlAltDelBurstAction=none</p></li><li><p>重启systemd，使修改生效，参考命令如下</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reexec</span><br></pre></td></tr></table></figure><h2 id="设置终端的自动退出时间">设置终端的自动退出时间</h2><ul><li>说明</li></ul><p>无人看管的终端容易被侦听或被攻击，可能会危及系统安全。因此建议设置终端在停止运行一段时间后能够自动退出。</p><ul><li>实现</li></ul><p>自动退出时间由/etc/profile文件的TMOUT字段（单位为秒）控制，在/etc/profile的尾部添加如下配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">TMOUT</span>=300</span><br></pre></td></tr></table></figure><h2 id="设置用户的默认umask值为077">设置用户的默认umask值为077</h2><ul><li>说明</li></ul><p>umask值用于为用户新创建的文件和目录设置缺省权限。如果umask的值设置过小，会使群组用户或其他用户的权限过大，给系统带来安全威胁。因此设置所有用户默认的umask值为0077，即用户创建的目录默认权限为700，文件的默认权限为600。umask值代表的是权限的“补码”，umask值和权限的换算方法请参见<a href="https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E9%99%84%E5%BD%95.html">umask值含义</a>。</p><ul><li>实现</li></ul><ol><li><p>分别在/etc/bashrc文件和/etc/profile.d/目录下的所有文件中加入“umask 0077”</p></li><li><p>设置/etc/bashrc文件和/etc/profile.d/目录下所有文件的属主为root，群组为root</p></li></ol><h2 id="设置GRUB2加密口令">设置GRUB2加密口令</h2><ul><li>说明</li></ul><p>GRUB是GRand Unified Bootloader的缩写，它是一个操作系统启动管理器，用来引导不同系统（如Windows、Linux），GRUB2是GRUB的升级版。</p><p>系统启动时，可以通过GRUB2界面修改系统的启动参数。为了确保系统的启动参数不被任意修改，需要对GRUB2界面进行加密，仅在输入正确的GRUB2口令时才能修改启动参数。</p><ul><li>实现</li></ul><ol><li>使用grub2-mkpasswd-pbkdf2命令生成加密的口令</li></ol><p>口令一样但每次sha512的结果都是不一样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入口令：</span><br><span class="line">Reenter password: </span><br><span class="line">PBKDF2 hash of your password is grub.pbkdf2.sha512.10000.645FBE11264234D074717D8761ECF8A722086CFF45AAE026A50DBF0E0C7EA2A23BD791D0249123CDC9DD105BC2C63938D867F367C0D8E83744D8ADCED1A04766.CE644C471EB3FBEA46F85F6596490F2FF769129D53462A9035B9D399FD6ED83604BFBD775D890A08C3A00CA532A507172A44D1437B97F9711911B49E44760A43</span><br></pre></td></tr></table></figure><ol start="2"><li>使用vi工具打开grub.cfg的开始位置追加如下字段</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set superusers=&quot;root&quot;</span><br><span class="line">password_pbkdf2 root grub.pbkdf2.sha512.10000.5A45748D892672FDA02DD3B6F7AE390AC6E6D532A600D4AC477D25C7D087644697D8A0894DFED9D86DC2A27F4E01D925C46417A225FC099C12DBD3D7D49A7425.2BD2F5BF4907DCC389CC5D165DB85CC3E2C94C8F9A30B01DACAA9CD552B731BA1DD3B7CC2C765704D55B8CD962D2AEF19A753CBE9B8464E2B1EB39A3BB4EAB08</span><br></pre></td></tr></table></figure><blockquote><ul><li>不同模式下grub.cfg文件所在路径不同：x86架构的UEFI模式下路径为/boot/efi/EFI/版本/grub.cfg，legacy BIOS模式下路径为/boot/grub2/grub.cfg；aarch64架构下路径为/boot/efi/EFI/版本/grub.cfg。</li><li>superusers字段用于设置GRUB2的超级管理员的帐户名。</li><li>password_pbkdf2字段后的参数，第1个参数为GRUB2的帐户名，第2个为该帐户的加密口令</li></ul></blockquote><h2 id="安全单用户模式">安全单用户模式</h2><ul><li>说明</li></ul><p>单用户模式是以root权限进入系统，如不设置密码，将存在较大安全隐患。</p><ul><li>实现</li></ul><p>该设置可以通过修改/etc/sysconfig/init文件内容实现。将SINGLE选项配置为SINGLE=/sbin/sulogin。</p><h2 id="禁止交互式启动">禁止交互式启动</h2><ul><li>说明</li></ul><p>使用交互式引导，控制台用户可以禁用审计、防火墙或其他服务，削弱了系统安全性。用户可以禁止使用交互式引导，提升安全性。</p><ul><li>说明</li></ul><p>该设置可以通过修改/etc/sysconfig/init文件内容实现。将PROMPT选项配置为PROMPT=no。</p><h1>系统服务</h1><h2 id="加固ssh">加固ssh</h2><ul><li>说明</li></ul><p>SSH（Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性保障的协议</p><ul><li>实现</li></ul><p>加固操作如下：</p><ol><li>服务端配置文件/etc/ssh/sshd_config，在该文件中修改或添加对应加固项及其加固值并且重启服务</li><li>客户端配置文件/etc/ssh/ssh_config，在该文件中修改或添加对应加固项及其加固值并且重启服务</li></ol><h3 id="服务端加固项说明">服务端加固项说明</h3><table><thead><tr><th><strong>加固项</strong></th><th><strong>加固项说明</strong></th><th><strong>加固建议</strong></th></tr></thead><tbody><tr><td>Protocol</td><td>设置使用SSH协议的版本</td><td>2</td></tr><tr><td>SyslogFacility</td><td>设置SSH服务的日志类型。加固策略将其设置为“AUTH”，即认证类日志</td><td>AUTH</td></tr><tr><td>LogLevel</td><td>设置记录sshd日志消息的层次</td><td>VERBOSE</td></tr><tr><td>X11Forwarding</td><td>设置使用SSH登录后，能否使用图形化界面</td><td>no</td></tr><tr><td>MaxAuthTries</td><td>最大认证尝试次数</td><td>3</td></tr><tr><td>PubkeyAuthentication</td><td>设置是否允许公钥认证</td><td>yes</td></tr><tr><td>RSAAuthentication</td><td>设置是否允许只有RSA安全验证</td><td>yes</td></tr><tr><td>IgnoreRhosts</td><td>设置是否使用rhosts文件和shosts文件进行验证。rhosts文件和shosts文件用于记录可以访问远程计算机的计算机名及关联的登录名</td><td>yes</td></tr><tr><td>RhostsRSAAuthentication</td><td>设置是否使用基于rhosts的RSA算法安全验证。rhosts文件记录可以访问远程计算机的计算机名及关联的登录名</td><td>no</td></tr><tr><td>HostbasedAuthentication</td><td>设置是否使用基于主机的验证。基于主机的验证是指已信任客户机上的任何用户都可以使用SSH连接</td><td>no</td></tr><tr><td>PermitRootLogin</td><td>是否允许root帐户直接使用SSH登录系统</td><td>no</td></tr><tr><td>PermitEmptyPasswords</td><td>设置是否允许用口令为空的账号登录</td><td>no</td></tr><tr><td>PermitUserEnvironment</td><td>设置是否解析 ~/.ssh/environment和~/.ssh/authorized_keys中设定的环境变量</td><td>no</td></tr><tr><td>Ciphers</td><td>设置SSH数据传输的加密算法</td><td><a href="mailto:aes128-ctr,aes192-ctr,aes256-ctr,chacha20-poly1305@openssh.com">aes128-ctr,aes192-ctr,aes256-ctr,chacha20-poly1305@openssh.com</a><a href="mailto:,aes128-gcm@openssh.com">,aes128-gcm@openssh.com</a><a href="mailto:,aes256-gcm@openssh.com">,aes256-gcm@openssh.com</a></td></tr><tr><td>ClientAliveCountMax</td><td>设置超时次数。服务器发出请求后，客户端没有响应的次数达到一定值，连接自动断开</td><td>0</td></tr><tr><td>Banner</td><td>指定登录SSH前后显示的提示信息的文件</td><td>/etc/issue.net</td></tr><tr><td>MACs</td><td>设置SSH数据校验的哈希算法</td><td><a href="mailto:hmac-sha2-512,hmac-sha2-512-etm@openssh.com">hmac-sha2-512,hmac-sha2-512-etm@openssh.com</a><a href="mailto:,hmac-sha2-256,hmac-sha2-256-etm@openssh.com">,hmac-sha2-256,hmac-sha2-256-etm@openssh.com</a></td></tr><tr><td>StrictModes</td><td>设置SSH在接收登录请求之前是否检查用户HOME目录和rhosts文件的权限和所有权</td><td>yes</td></tr><tr><td>UsePAM</td><td>使用PAM登录认证</td><td>yes</td></tr><tr><td>AllowTcpForwarding</td><td>设置是否允许TCP转发</td><td>no</td></tr><tr><td>Subsystem sftp /usr/libexec/openssh/sftp-server</td><td>sftp日志记录级别，记录INFO级别以及认证日志。</td><td>-l INFO -f AUTH</td></tr><tr><td>AllowAgentForwarding</td><td>设置是否允许SSH Agent转发</td><td>no</td></tr><tr><td>GatewayPorts</td><td>设置是否允许连接到转发客户端端口</td><td>no</td></tr><tr><td>PermitTunnel</td><td>Tunnel设备是否允许使用</td><td>no</td></tr><tr><td>KexAlgorithms</td><td>设置SSH密钥交换算法</td><td><a href="mailto:curve25519-sha256,curve25519-sha256@libssh.org">curve25519-sha256,curve25519-sha256@libssh.org</a>,diffie-hellman-group-exchange-sha256</td></tr><tr><td>LoginGraceTime</td><td>限制用户必须在指定的时限内认证成功，0 表示无限制。默认值是 60 秒。</td><td>60</td></tr></tbody></table><h3 id="客户单加固项说明">客户单加固项说明</h3><table><thead><tr><th><strong>加固项</strong></th><th><strong>加固项说明</strong></th><th><strong>加固建议</strong></th></tr></thead><tbody><tr><td>KexAlgorithms</td><td>设置SSH密钥交换算法</td><td>ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256</td></tr><tr><td>VerifyHostKeyDNS</td><td>是否使用DNS或者SSHFP资源记录验证HostKey</td><td>ask</td></tr></tbody></table><h3 id="其他加固">其他加固</h3><ul><li>SSH服务仅侦听指定IP地址</li></ul><p>出于安全考虑，建议用户在使用SSH服务时，仅在必需的IP上进行绑定侦听，而不是侦听0.0.0.0，可修改/etc/ssh/sshd_config文件中的ListenAddress配置项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListenAddress 192.168.1.100</span><br></pre></td></tr></table></figure><ul><li>限制SFTP用户向上跨目录访问(有问题)</li></ul><p>SFTP是FTP over SSH的安全FTP协议，对于访问SFTP的用户建议使用专用账号，只能上传或下载文件，不能用于SSH登录，同时对SFTP可以访问的目录进行限定，防止目录遍历攻击，所以创建特殊账户sftpgroup为示例用户组，sftpuser为示例用户名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建SFTP用户组</span></span><br><span class="line">groupadd sftpgroup</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建SFTP根目录</span></span><br><span class="line">mkdir /sftp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改SFTP根目录属主和权限</span></span><br><span class="line">chown root:root /sftp</span><br><span class="line">chmod 755 /sftp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建SFTP用户</span></span><br><span class="line">useradd -g sftpgroup -s /sbin/nologin sftpuser</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置SFTP用户的口令</span></span><br><span class="line">passwd sftpuser</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建SFTP用户上传目录</span></span><br><span class="line">mkdir /sftp/sftpuser</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改SFTP用户上传目录属主和权限</span></span><br><span class="line">chown root:root /sftp/sftpuser</span><br><span class="line">chmod 777 /sftp/sftpuser</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建SFTP用户上传目录</span></span><br><span class="line">mkdir /sftp/sftpuser/sftpupload</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改SFTP用户上传目录的属主</span></span><br><span class="line">chown sftpuser:sftpgroup /sftp/sftpuser/sftpupload</span><br></pre></td></tr></table></figure><p>修改/sshd_config</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Subsystem sftp /usr/libexec/openssh/sftp-server -l INFO -f AUTH</span></span><br><span class="line">Subsystem sftp internal-sftp -l INFO -f AUTH</span><br><span class="line"></span><br><span class="line">  Match Group sftpgroup                    </span><br><span class="line">        ChrootDirectory /sftp/%u  </span><br><span class="line">        ForceCommand internal-sftp</span><br></pre></td></tr></table></figure><h1>文件权限</h1><h2 id="删除无主文件">删除无主文件</h2><ul><li>说明</li></ul><p>系统管理员在删除用户/群组时，存在着忘记删除该用户/该群组所拥有文件的问题。如果后续新创建的用户/群组与被删除的用户/群组同名，则新用户/新群组会拥有部分不属于其权限的文件，建议将此类文件删除。</p><ul><li>实现</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除用户ID不存在的文件</span></span><br><span class="line">find / -nouser</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除群组ID不存在的文件</span></span><br><span class="line">find / -nogroup</span><br></pre></td></tr></table></figure><h2 id="处理空链接文件">处理空链接文件</h2><ul><li>说明</li></ul><p>无指向的空链接文件，可能会被恶意用户利用，影响系统安全性。建议用户删除无效的空链接文件，提高系统安全性.需要用户根据实际情况处理空链接</p><ul><li>实现</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find dirname -type l -follow 2&gt;/dev/null</span><br></pre></td></tr></table></figure><h2 id="设置守护进程的umask值">设置守护进程的umask值</h2><ul><li>说明</li></ul><p>umask值用来为新创建的文件和目录设置缺省权限。如果没有设定umask值，则生成的文件具有全局可写权限，存在一定的风险。守护进程负责系统上某个服务，让系统可以接受来自用户或者是网络客户的要求。为了提高守护进程所创建文件和目录的安全性，建议设置其umask值为0027。umask值代表的是权限的“补码”，umask值和权限的换算方法请参见 “附录 &gt; umask值含义”</p><ul><li>实现</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在配置文件/etc/sysconfig/init中新增一行：umask 0027。</span><br></pre></td></tr></table></figure><h2 id="为全局可写目录添加粘滞位属性">为全局可写目录添加粘滞位属性</h2><ul><li>说明</li></ul><p>任意用户可以删除、修改全局可写目录中的文件和目录，为了确保全局可写目录中的文件和目录不会被任意删除，需要为全局可写目录添加粘滞位属性。</p><ul><li>实现</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">搜索全局可写目录。</span></span><br><span class="line">find / -type d -perm -0002 ! -perm -1000 -ls | grep -v proc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为全局可写目录添加粘滞位属性。<span class="built_in">dirname</span> 为实际查找到的目录名。</span></span><br><span class="line">chmod +t dirname</span><br></pre></td></tr></table></figure><h2 id="删除非授权文件的全局可写属性">删除非授权文件的全局可写属性</h2><ul><li>说明</li></ul><p>全局可写文件可被系统中的任意用户修改，影响系统完整性。</p><ul><li>实现</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列举系统中所有的全局可写文件。</span></span><br><span class="line">find / -type d ( -perm -o+w ) | grep -v proc</span><br><span class="line">find / -type f ( -perm -o+w ) | grep -v proc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看步骤1列举的所有文件(粘滞位位的文件和目录可以排除在外)，删除文件或去掉其全局可写权限。使用以下命令去掉权限，其中filename为对应文件名</span></span><br><span class="line">chmod o-w  filename</span><br></pre></td></tr></table></figure><h2 id="限制at命令的使用权限">限制at命令的使用权限</h2><ul><li>说明</li></ul><p>at命令用于创建在指定时间自动执行的任务。为避免任意用户通过at命令安排工作，造成系统易受攻击，需要指定可使用该命令的用户。</p><ul><li>实现</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除/etc/at.deny文件</span></span><br><span class="line">rm -f /etc/at.deny</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建/etc/at.allow文件</span></span><br><span class="line">touch /etc/at.allow</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将/etc/at.allow的文件属主改为root:root</span></span><br><span class="line">chown root:root /etc/at.allow</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">控制/etc/at.allow的文件权限，仅root可操作</span></span><br><span class="line">chmod og-rwx /etc/at.allow</span><br></pre></td></tr></table></figure><h2 id="限制cron命令的使用权限">限制cron命令的使用权限</h2><ul><li>说明</li></ul><p>cron命令用于创建例行性任务。为避免任意用户通过cron命令安排工作，造成系统易受攻击，需要指定可使用该命令的用户</p><ul><li>实现</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除/etc/cron.deny文件。</span></span><br><span class="line">rm -f /etc/cron.deny</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建/etc/cron.allow文件</span></span><br><span class="line">touch /etc/cron.allow</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将/etc/cron.allow的文件属主改为root:root。</span></span><br><span class="line">chown root:root /etc/cron.allow</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">控制/etc/cron.allow的文件权限，仅root可操作</span></span><br><span class="line">chmod og-rwx /etc/cron.allow</span><br></pre></td></tr></table></figure><h2 id="限制sudo命令的使用权限">限制sudo命令的使用权限</h2><ul><li>说明</li></ul><p>sudo命令用于普通用户以root权限执行命令。为了增强系统安全性，有必要对sudo命令的使用权进行控制，只允许root使用sudo命令，限制其他帐户使用</p><ul><li>实现</li></ul><p>sudo命令的使用控制通过修改/etc/sudoers文件实现，需要注释掉如下配置行：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%wheel <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>)       <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><h1>内核参数</h1><h2 id="加固内核参数">加固内核参数</h2><ul><li>说明</li></ul><p>内核参数决定配置和应用特权的状态。内核提供用户可配置的系统控制，这一系统控制可微调或配置，该功能特性可通过控制各种可配置的内核参数，来提高操作系统的安全特性。比如：通过微调或配置网络选项，可有效提高系统的安全性。</p><ul><li>实现</li></ul><p>加固项写入/etc/sysctl.conf文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1  </span><br><span class="line">net.ipv4.conf.all.rp_filter = 1  </span><br><span class="line">net.ipv4.conf.default.rp_filter = 1  </span><br></pre></td></tr></table></figure><ul><li>加固参数如下</li></ul><table><thead><tr><th style="text-align:left"><strong>加固项</strong></th><th style="text-align:left"><strong>加固项说明</strong></th><th style="text-align:left"><strong>加固建议</strong></th></tr></thead><tbody><tr><td style="text-align:left">net.ipv4.icmp_echo_ignore_broadcasts</td><td style="text-align:left">是否接受ICMP广播报文。加固策略为不接受。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">net.ipv4.conf.all.rp_filter</td><td style="text-align:left">验证数据包使用的实际源地址是否与路由表相关，以及使用该特定源IP地址的数据包是否通过接口获取其响应。加固策略为启用该项。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">net.ipv4.conf.default.rp_filter</td><td style="text-align:left">1</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">net.ipv4.ip_forward</td><td style="text-align:left">IP Forwarding可阻止未授权的IP数据包渗透至网络。加固策略为禁用该特性。</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">net.ipv4.conf.all.accept_source_route</td><td style="text-align:left">accept_source_route指允许数据包的发送者指定数据包的发送路径，以及返回给发送者的数据包所走的路径。加固策略为禁用该特性。</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">net.ipv4.conf.default.accept_source_route</td><td style="text-align:left">0</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">net.ipv4.conf.all.accept_redirects</td><td style="text-align:left">是否发送ICMP重定向报文。加固策略为禁止发送。</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">net.ipv4.conf.default.accept_redirects</td><td style="text-align:left">0</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">net.ipv6.conf.all.accept_redirects</td><td style="text-align:left">0</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">net.ipv6.conf.default.accept_redirects</td><td style="text-align:left">0</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">net.ipv4.conf.all.send_redirects</td><td style="text-align:left">是否将ICMP重定向报文发送至其他主机。只有当主机作为路由时，应启用该策略。加固策略为禁用该项。</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">net.ipv4.conf.default.send_redirects</td><td style="text-align:left">0</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">net.ipv4.icmp_ignore_bogus_error_responses</td><td style="text-align:left">忽略伪造的ICMP数据包，不会将其记录到日志，将节省大量的硬盘空间。加固策略为启用该项。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">net.ipv4.tcp_syncookies</td><td style="text-align:left">SYN Attack是一种通过占用系统资源迫使系统重启的DoS攻击。加固策略为开启TCP-SYN cookie保护。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">kernel.dmesg_restrict</td><td style="text-align:left">加固dmesg信息，仅允许管理员查看。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">kernel.sched_autogroup_enabled</td><td style="text-align:left">该选项决定内核是否对线程进行自动分组调度。开启后调度组之间互相竞争时间片，调度组内的线程再竞争调度组分配到的时间片。加固策略为不启用该项。</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">kernel.sysrq</td><td style="text-align:left">禁用魔术键。说明：建议禁用魔术键，避免由于直接发送命令到内核对系统造成影响，增强内核安全性。</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">net.ipv4.conf.all.secure_redirects</td><td style="text-align:left">设置系统是接收来自任何主机的ICMP重定向消息还是从默认网关列表中的网关处接收ICMP重定向消息。加固策略为采用前者。</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">net.ipv4.conf.default.secure_redirects</td><td style="text-align:left">0</td><td style="text-align:left">是</td></tr></tbody></table><h2 id="其他加固建议">其他加固建议</h2><ul><li><p>net.ipv4.icmp_echo_ignore_all：忽略ICMP请求。</p><p>出于安全考虑，建议开启此项（当前默认值为0，开启将值设为1）。</p><p>但开启后会忽略所有接收到的icmp echo请求的包(会导致机器无法ping通)，建议用户根据实际组网场景决定是否开启此项。</p></li><li><p>net.ipv4.conf.all.log_martians/net.ipv4.conf.default.log_martians：对于仿冒/源路由/重定向数据包开启日志记录。</p><p>出于安全考虑，建议开启此项（当前默认值为0，开启将值设为1）。</p><p>但是开启后会记录带有不允许的地址的数据到内核日志中，存在冲日志风险，建议用户根据实际使用场景决定是否开启此项。</p></li><li><p>net.ipv4.tcp_timestamps：关闭tcp_timestamps。</p><p>出于安全考虑，建议关闭tcp_timestamps（当前默认值为1，关闭将值设为0）。</p><p>但是关闭此项会影响TCP超时重发的性能，建议用户根据实际使用场景决定是否关闭此项。</p></li><li><p>net.ipv4.tcp_max_syn_backlog：决定了SYN_RECV状态队列的数量。</p><p>该参数决定了SYN_RECV状态队列的数量，超过这个数量，系统将不再接受新的TCP连接请求，一定程度上可以防止系统资源耗尽。建议由用户根据实际使用场景配置合适的值。</p></li></ul><h1>selinux配置</h1>]]></content>
      
      
      <categories>
          
          <category> 安全加固 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux显示框架</title>
      <link href="/posts/412cf25e.html"/>
      <url>/posts/412cf25e.html</url>
      
        <content type="html"><![CDATA[<h1>什么是窗口系统</h1><h2 id="窗口系统设计思路">窗口系统设计思路</h2><ol><li>采用cs架构，s是display server管理所有输入设备和输出的显示设备(<a href="http://xn--X-ch1b.org">如X.org</a> server)，c是client负责运算</li><li>应用程序作为dispaly server的一个client，在自己的窗口中运行，并绘制自己的GUI</li><li>client的绘图请求，都会提交给display server，display server响应且处理这些请求并以一定的规则混合叠加，在有限的输出资源上显示多个应用程序的GUI</li><li>display server protocol可以是基于网络的，甚至是网络透明（network transparent），例如X11,wayland,quartz</li></ol><h2 id="窗口系统组成">窗口系统组成</h2><p>窗口系统只提供实现GUI环境的基本框架，仅仅实现了点线面，其他的UI等基本元素则是第三方提供。这些应用程序主要包括窗口管理器（window manager）、GUI工具集（GUI widget toolkit）、桌面环境</p><ul><li>窗口管理器<br>负责控制应用程序窗口（application windows）的布局和外观，并将最终显示图形传递给X或者kernel</li><li>GUI工具集<br>在窗口之上的进一步封装，比如X，他通过xlib提供给应用程序的API，只能绘画出点线面，要组成复杂的应用程序，还有很多任务，在一些特定的操作系统，会在X的基础上，封装出一些便利的GUI接口，方便应用程序使用，比如GTK+和QT（xcb）</li><li>桌面环境<br>是应用程序级的封装，提供一系列界面一致操作一致的应用程序，比如GNOME,MATE,KDE,DDE,KIRAN,UKUI</li><li>构成图<br><img src="images/%E7%AA%97%E5%8F%A3%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""></li><li>X和wayland的架构区别</li></ul><ol><li>x server流程<br><img src="images/x%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt=""></li><li>wayland流程<br><img src="images/wayland%E6%B5%81%E7%A8%8B.png" alt=""></li></ol><h1>evdev</h1><h1>术语</h1><ul><li>Display<br>多屏工作站，有单个xserver驱动的一个或多个显示器组成，包含屏幕的x信息</li><li>crtc<br>screenCRCT处于DRM结构中的核心位置，将图显处理器中的时序控制部分抽象成CRCT，配置resolution，depth，polarity，porch，refresh rate等</li><li>monitor（output）<br>显示器</li><li>screen<br>显示框最小单位，一块物理屏幕分为若干screen或多个显示器为一个screen</li><li>marco<br>Marco是一个最小的X窗口管理器，使用GTK+绘制窗口框架。它面向非技术用户，旨在很好地集成MATE桌面。马可是一个普通的窗口经理，适合你的成年人；许多窗口管理器就像棉花糖-弗罗特循环，马可就像<br>干杯。它缺少一些传统UNIX或其他技术用户可能期望的功能；这些用户可能希望调查其他有用信息可与MATE一起使用或作为独立窗口管理器使用的窗口管理器。Marco支持一些高级但常见的功能，如窗口着色/向上滚动、窗口/边缘捕捉、垂直和水平最大化、，始终在顶部，倾斜/鼠标聚焦和提升，以及更多。。。嗯，不是很多，但更多。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux图形显示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平均负载</title>
      <link href="/posts/da482b46.html"/>
      <url>/posts/da482b46.html</url>
      
        <content type="html"><![CDATA[<h1>什么是平均负载</h1><p>平均负载（也称为平均系统负载）是一个重要的指标，指示 Linux 服务器上的队列中是否有多个任务。平均负载可以是高或低，具体取决于服务器拥有的内核数、集成到系统服务器的 CPU 数以及负载平均数本身。</p><h1>平均负载的作用</h1><p>刚开始系统管理的人经常将平均负载与 CPU 百分比混淆。但是，虽然 CPU 百分比是特定时间系统性能的主动度量，但负载平均值显示了系统性能在不同时间范围内如何演变。平均负载为我们提供了系统未来可能表现的图片。</p><h1>如何查看负载</h1><p>我们可以使用各种工具来监视平均负载，比如uptime，例如正常运行时间或顶部命令行。顾名思义，正常运行时间为我们提供了系统运行的时间长度，以及更多信息，例如过去 1、5 和 15 分钟的用户数量或负载平均值。</p><ul><li>uptime</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">09:48:45 up 186 days, 13:59, 2 users, load average: 0.01, 0.02, 0.05</span><br></pre></td></tr></table></figure><p>在这里我们可以看到服务器已经启动并运行了186天;有一个人在使用服务器;过去 1、5 和 15 分钟的平均负载分别为 0.01、0.02和 0.05。</p><ul><li>top<br>使用 top（进程表）命令，我们可以获取系统中当前正在运行的进程的列表以及 CPU 和内存中的资源利用率统计信息。</li></ul><h1>如何判断负载变高</h1><h2 id="简单分析">简单分析</h2><p>平均负载为 2.97，而当前服务器只有一个 CPU。我们可以通过使用 lscpu 获取服务器中的 CPU 数量，当负载平均值低于 Linux 服务器中的 CPU 数量时，平均负载被认为是理想的。例如，Linux 服务器中只有1个 CPU，最好是平均负载低于 1。过去 1、5 和 15 分钟的平均负载分别为 0.01、0.02和 0.05，因此我们无需担心</p><p>在系统负荷方面，多核CPU与多个CPU效果类似，所以考虑系统负荷的时候，必须考虑这台电脑有几个CPU、每个CPU有几个核心。然后，把系统负荷除以总的核心数，只要每个核心的负荷不超过1.0，就表明电脑正常运行</p><h2 id="单核负载注意">单核负载注意</h2><p>Load &lt; 0.7时：系统很闲，马路上没什么车，要考虑多部署一些服务<br>0.7 &lt; Load &lt; 1时：系统状态不错，马路可以轻松应对<br>Load == 1时：系统马上要处理不多来了，赶紧找一下原因<br>Load &gt; 1时：马路已经非常繁忙了，进入马路的每辆汽车都要无法很快的运行</p><h2 id="三个时间点负载如何看-单核">三个时间点负载如何看(单核)</h2><ul><li>观察<br>通常我们先看15分钟load，如果load很高，再看1分钟和5分钟负载，查看是否有下降趋势。<br>1分钟负载值 &gt; 1，那么我们不用担心，但是如果15分钟负载都超过1，我们要赶紧看看发生了什么事情。<br>如果只有1分钟的系统负荷大于1.0，其他两个时间段都小于1.0，这表明只是暂时现象，问题不大。<br>如果15分钟内，平均系统负荷大于1.0（调整CPU核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察&quot;15分钟系统负荷”，将它作为电脑正常运行的指标。</li><li>总结<br>1分钟Load&gt;1，5分钟Load&lt;1，15分钟Load&lt;1：短期内繁忙，中长期空闲，初步判断是一个“抖动”，或者是“拥塞前兆”<br>1分钟Load&gt;1，5分钟Load&gt;1，15分钟Load&lt;1：短期内繁忙，中期内紧张，很可能是一个“拥塞的开始”<br>1分钟Load&gt;1，5分钟Load&gt;1，15分钟Load&gt;1：短、中、长期都繁忙，系统“正在拥塞”<br>1分钟Load&lt;1，5分钟Load&gt;1，15分钟Load&gt;1：短期内空闲，中、长期繁忙，不用紧张，系统“拥塞正在好转”</li></ul><h1>分析负载变高的原因</h1><p>要解决高负载平均问题，我们需要了解其背后的原因。由于下面提到的三个原因，往往会发生高负载平均值。</p><h2 id="服务器中执行的线程数量较多">服务器中执行的线程数量较多</h2><p>服务器上可能有一个应用程序是使用并发模型（如 Akka 或 goroutines）实现的。一方面，这将提高应用程序的性能，因为它可以同时处理多个请求，但是，另一方面，这将导致系统中执行大量线程。为了解决这个问题，我们需要增加服务器中的 CPU 数量（尽管增加了成本）或优化正在运行的应用程序以减少线程数量</p><h2 id="缺少-RAM-迫使服务器使用交换内存">缺少 RAM 迫使服务器使用交换内存</h2><p>高负载平均背后的另一个可能原因是缺少 RAM。当系统检测到没有足够的内存用于运行进程时，它会转向使用交换内存。使用交换内存的问题在于，处理器队列中必然有多个进程要等待，这将导致高负载平均值。为了解决这个问题，我们必须找到优化服务器中运行的应用程序以节省内存的方法。如果这没有帮助，剩下的唯一解决方案就是向服务器添加更多 RAM</p><h2 id="大量-I-O-流量">大量 I/O 流量</h2><p>由于系统中有大量 I/O 请求，也可能会出现高平均负载。对于大量 I/O 请求，系统将不可避免地遇到高延迟，这反过来将导致高负载平均值。要查看这是否是高负载平均问题的根源，我们可以使用命令行工具 iostat 并确定具有过多 I/O 流量的分区。这将使我们能够安全地停止导致问题的进程</p><h1>参考链接</h1><p><a href="https://www.site24x7.com/blog/load-average-what-is-it-and-whats-the-best-load-average-for-your-linux-servers">https://www.site24x7.com/blog/load-average-what-is-it-and-whats-the-best-load-average-for-your-linux-servers</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置linux路由</title>
      <link href="/posts/7a4729e2.html"/>
      <url>/posts/7a4729e2.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 网络管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建iscsi</title>
      <link href="/posts/b511a9e8.html"/>
      <url>/posts/b511a9e8.html</url>
      
        <content type="html"><![CDATA[<h1>介绍</h1><p>iscsi技术在工作形势上分为服务端target和客户端initiator</p><h1>IP规划</h1><ul><li>iscsi服务端<br>192.168.110.10<br>192.168.120.10</li><li>iscsi客户端<br>192.168.110.20和192.168.110.21</li></ul><h1>服务器端搭建</h1><h2 id="添加磁盘">添加磁盘</h2><p>使用如下命令扫盘或者重启系统来使lsblk识别添加的磁盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;- - -&quot;&gt; /sys/class/scsi_host/host0/scan </span><br><span class="line">echo &quot;- - -&quot;&gt; /sys/class/scsi_host/host1/scan </span><br><span class="line">echo &quot;- - -&quot;&gt; /sys/class/scsi_host/host2/scan </span><br></pre></td></tr></table></figure><h2 id="设置网络">设置网络</h2><p>存储的虚拟机上设置2个ip</p><h2 id="安装包">安装包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y scsi-target-utils</span><br><span class="line">yum install -y targetcli</span><br></pre></td></tr></table></figure><h2 id="编辑配置">编辑配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iqn 名称：iSCSI Qualified Name（iSCSI 合格名称），是 iSCSI 中用于标识目标和逻辑单元的唯一名称。iSCSI 中的 iqn 名称格式为 iqn.&lt;year&gt;-&lt;month&gt;.&lt;domain&gt;:&lt;name&gt;，其中 &lt;year&gt; 和 &lt;month&gt; 表示 iSCSI 标准发布的年份和月份，&lt;domain&gt; 表示组织或者公司的域名，&lt;name&gt; 表示目标或逻辑单元的名称。</span><br></pre></td></tr></table></figure><p>编辑/etc/tgt/targets.conf文件，添加如下内容，/dev/sdb是新添加的用来共享的磁盘<code>,</code>为原生的未经过格式化的盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">有几个盘添加几块</span></span><br><span class="line">&lt;target iqn.202303.dev:server.sdb&gt;</span><br><span class="line">backing-store /dev/sdb</span><br><span class="line">&lt;/target&gt;</span><br></pre></td></tr></table></figure><h2 id="管理服务">管理服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动并自启动</span></span><br><span class="line">systemctl enable --now tgtd.service</span><br></pre></td></tr></table></figure><h1>客户端搭建</h1><h2 id="编辑配置文件">编辑配置文件</h2><p>编辑/etc/iscsi/initiatorname.iscsi添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InitiatorName=iqn.202303.dev:server.sdb</span><br></pre></td></tr></table></figure><h2 id="启动服务">启动服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now iscsi.service</span><br><span class="line">systemctl enable --now iscsid.service</span><br><span class="line">systemctl restart iscsi iscsid</span><br></pre></td></tr></table></figure><h1>测试</h1><h2 id="扫描磁盘">扫描磁盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">扫描存储虚拟机的2个ip</span></span><br><span class="line">iscsiadm -m discovery -t sendtargets -p 192.168.110.10</span><br><span class="line">iscsiadm -m discovery -t sendtargets -p 192.168.120.10</span><br></pre></td></tr></table></figure><h2 id="登录">登录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm -m node -T iqn.2023-03.test:server.sdb -l</span><br><span class="line">iscsiadm -m node -T iqn.202303.dev:server.sdc -l</span><br><span class="line">iscsiadm -m node -T iqn.202303.dev:server.sdd -l</span><br></pre></td></tr></table></figure><h2 id="查看">查看</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><h2 id="安装多路径">安装多路径</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">正常识别</span></span><br><span class="line">mulitpaht -ll</span><br><span class="line">pvcreate /dev/mapper/dbbak   </span><br><span class="line">pvcreate /dev/mapper/dbarch   </span><br><span class="line">pvcreate /dev/mapper/dbdata   </span><br><span class="line">vgcreate dbbak /dev/mapper/dbbak </span><br><span class="line">vgcreate dbarch /dev/mapper/dbarch </span><br><span class="line">vgcreate dbdata /dev/mapper/dbdata </span><br><span class="line">lvcreate dbarch /dev/mapper/dbarch  -n dbarch -l num</span><br><span class="line">lvcreate dbbak /dev/mapper/dbbak  -n dbbak  -l num</span><br><span class="line">lvcreate dbdata /dev/mapper/dbdata  -n dbdata -l num</span><br><span class="line">mkfs.ext4 /dev/mapper/dbdata-dbdata</span><br><span class="line">mkfs.ext4 /dev/mapper/dbarch-dbarch</span><br><span class="line">mkfs.ext4 /dev/mapper/dbbak-dbbak</span><br><span class="line">mkdir /dbarch /dbdata /dbbak</span><br><span class="line">mount /dev/mapper/dbdata-dbdata  /dbdata</span><br><span class="line">mount /dev/mapper/dbarch-dbarch  /dbarch</span><br><span class="line">mount /dev/mapper/dbbak-dbbak  /dbbak</span><br></pre></td></tr></table></figure><h1>删除</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm -m session -u</span><br><span class="line">iscsiadm -m node -o delete</span><br></pre></td></tr></table></figure><h1>targetcli配置服务端</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install targetd</span><br></pre></td></tr></table></figure><ul><li>交互式配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">targetcli </span><br><span class="line">cd iscsi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">create an iSCSI target 用create自动生成或者create name指定一个</span></span><br><span class="line">create</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Creating a block storage object</span></span><br><span class="line">cd /backstores/block </span><br><span class="line">create name=disk_b dev=/dev/sdb</span><br><span class="line">cd /iscsi/目标名/tpg1</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安装部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iscsi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将kickstart封装到iso镜像</title>
      <link href="/posts/83891c9e.html"/>
      <url>/posts/83891c9e.html</url>
      
        <content type="html"><![CDATA[<h1>获得一份镜像数据</h1><ul><li>挂载系统镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount centos.iso /mnt</span><br></pre></td></tr></table></figure><ul><li>拷贝到系统某个目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /iso</span><br><span class="line">cp -rp /mnt/*   /iso/</span><br></pre></td></tr></table></figure><h1>修改kickstart脚本</h1><ul><li>在/iso目录下创建一个文件夹来存放脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir kickstart</span><br></pre></td></tr></table></figure><ul><li>将ks脚本拷贝过来</li></ul><ol><li>可以用自己写的</li><li>可以拿已经安装的/root下的cfg文件</li></ol><h1>修改引导</h1><ul><li>修改isolinux/isolinux.cfg文件</li><li>添加引导</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cdrom</span></span><br><span class="line">label linux</span><br><span class="line">  menu label ^Install ikun system Standard(CDROM)</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img vga=0x314 lang=zh_CN ks=cdrom:/kickstart/test.cfg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">usb</span></span><br><span class="line">label linux</span><br><span class="line">  menu label ^Install ikun system Standard(USB)</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img vga=0x314 lang=zh_CN ks=hd:LABEL=Centos:/kickstart/test.cfg</span><br></pre></td></tr></table></figure><h1>封装镜像</h1><ul><li>封装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genisoimage -v -cache-inodes -joliet-long -R -J -T -V Centos  -o /opt/Centos-sp1.iso -c isolinux/boot.cat -b isolinux/isolinux.bin -no-emul-boot -boot-load-size 4 -boot-info-table -eltorito-alt-boot -b images/efiboot.img -no-emul-boot  /iso/  </span><br></pre></td></tr></table></figure><ul><li>校验</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implantisomd5   /opt/Centos-sp1.iso</span><br></pre></td></tr></table></figure><h1>测试</h1><p>虚拟机安装一下， 会发现自动加载了之前的配置，这样以后不同场景可以自己裁剪镜像来定制化</p>]]></content>
      
      
      <categories>
          
          <category> kickstart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kickstart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kickstart脚本</title>
      <link href="/posts/6534009d.html"/>
      <url>/posts/6534009d.html</url>
      
        <content type="html"><![CDATA[<h1>文件来源</h1><ol><li>自己写</li><li>从已经安装的系统的/root/anaconda-ks.cfg下获取</li><li>使用kickstart图形化工具编写</li></ol><h1>kickstart图形化工具</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install system-config-kickstart</span><br></pre></td></tr></table></figure><h1>示例</h1><p>centos7最小化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">version=DEVEL</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System authorization information</span></span><br><span class="line">auth --enableshadow --passalgo=sha512</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use CDROM installation media</span></span><br><span class="line">cdrom</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use graphical install</span></span><br><span class="line">graphical</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run the Setup Agent on first boot</span></span><br><span class="line">firstboot --enable</span><br><span class="line">ignoredisk --only-use=sda</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Keyboard layouts</span></span><br><span class="line">keyboard --vckeymap=us --xlayouts=&#x27;us&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System language</span></span><br><span class="line">lang en_US.UTF-8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Network information</span></span><br><span class="line">network  --bootproto=dhcp --device=ens33 --onboot=off --ipv6=auto --no-activate</span><br><span class="line">network  --bootproto=dhcp --device=ens34 --onboot=off --ipv6=auto</span><br><span class="line">network  --hostname=localhost.localdomain</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Root password</span></span><br><span class="line">rootpw --iscrypted $6$2c8X.xl1NNAt5jpm$S8bXrlWiazVianYF4xbPZrOnO0XMiFk7DlPWchNXW8ijqriiDV5UQ6Y6rtKDzpmxB53PUBsktkSs4HFZfHCG40</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System services</span></span><br><span class="line">services --enabled=&quot;chronyd&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System timezone</span></span><br><span class="line">timezone America/New_York --isUtc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System bootloader configuration</span></span><br><span class="line">bootloader --append=&quot; crashkernel=auto&quot; --location=mbr --boot-drive=sda</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Partition clearing information</span></span><br><span class="line">clearpart --none --initlabel</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Disk partitioning information</span></span><br><span class="line">part pv.156 --fstype=&quot;lvmpv&quot; --ondisk=sda --size=19455</span><br><span class="line">part /boot --fstype=&quot;xfs&quot; --ondisk=sda --size=1024</span><br><span class="line">volgroup centos --pesize=4096 pv.156</span><br><span class="line">logvol /  --fstype=&quot;xfs&quot; --grow --maxsize=51200 --size=1024 --name=root --vgname=centos</span><br><span class="line">logvol swap  --fstype=&quot;swap&quot; --size=2047 --name=swap --vgname=centos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">packages</span></span><br><span class="line">@^minimal</span><br><span class="line">@core</span><br><span class="line">chrony</span><br><span class="line">kexec-tools</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">end</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">addon com_redhat_kdump --<span class="built_in">enable</span> --reserve-mb=<span class="string">&#x27;auto&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">end</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">anaconda</span></span><br><span class="line">pwpolicy root --minlen=6 --minquality=1 --notstrict --nochanges --notempty</span><br><span class="line">pwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyok</span><br><span class="line">pwpolicy luks --minlen=6 --minquality=1 --notstrict --nochanges --notempty</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kickstart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kickstart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的软件</title>
      <link href="/posts/3df4b4e4.html"/>
      <url>/posts/3df4b4e4.html</url>
      
        <content type="html"><![CDATA[<h1>nice软件(持续更新)</h1><ul><li><a href="https://github.com/kingToolbox/WindTerm">windterm</a></li><li><a href="https://github.com/yang991178/fluent-reader">https://github.com/yang991178/fluent-reader</a></li><li><a href="https://github.com/rustdesk/rustdesk">rustdesk</a></li><li><a href="https://github.com/massCodeIO/massCode">massCode</a></li><li><a href="https://obsidian.md/">obsidian</a></li><li><a href="https://github.com/lyswhut/lx-music-desktop">lx-music-desktop</a></li><li><a href="https://github.com/charmbracelet/glow">glow</a></li><li><a href="https://input.kfsafe.cn/">卡饭</a></li><li><a href="https://github.com/alist-org/alist">alist</a></li><li><a href="https://github.com/purocean/yn">yank note</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客图片使用记录</title>
      <link href="/posts/6b240272.html"/>
      <url>/posts/6b240272.html</url>
      
        <content type="html"><![CDATA[<h1>使用记录</h1><h2 id="背景图">背景图</h2><ul><li>9</li><li>19</li><li>29</li><li>39</li></ul><h2 id="文章图">文章图</h2><ul><li>学习目标 1</li><li>好用的软件 2</li><li>crontab 3</li><li>博客图片使用记录 4</li><li>局域网ip冲突解决方法 5</li><li>linux的驱动问题 6</li><li>系统资源异常处理思路 7</li><li>用户被锁定 8</li><li>在Centos中检查RPM包的依赖性 10</li><li>git拉取总是需要密码 11</li><li>inode节点爆满处理 12</li><li>Linux好用命令之at 13</li><li>Linux好用命令之bizp2 14</li><li>Linux好用命令之dd 15</li><li>Linux好用命令之df 16</li><li>Linux好用命令之dnf 17</li><li>Linux好用命令之dos2unix 18</li><li>Linux好用命令之ethtool 20</li><li>Linux好用命令之free 21</li><li>Linux好用命令之gdb 22</li><li>Linux好用命令之git 23</li><li>Linux好用命令之gzip 24</li><li>Linux好用命令之iostat 25</li><li>Linux好用命令之lscpu 26</li><li>Linux好用命令之lsof 27</li><li>Linux好用命令之lspci 28</li><li>Linux好用命令之md5sum 30</li><li>Linux好用命令之netstat 31</li><li>Linux好用命令之nmcli 32</li><li>Linux好用命令之pidstat 33</li><li>Linux好用命令之ps 34</li><li>Linux好用命令之rpm 35</li><li>Linux好用命令之rsync 36</li><li>Linux好用命令之screen 37</li><li>Linux好用命令之strace 38</li><li>Linux好用命令之systemctl 40</li><li>Linux好用命令之tar 41</li><li>Linux好用命令之top 42</li><li>Linux好用命令之ulimit 43</li><li>Linux好用命令之xz 44</li><li>Linux好用命令之yum 45</li><li>Linux好用命令之zip 46</li><li>博客搭建 47</li><li>源码安装软件 48</li><li>centos7安装nvida显卡驱动 49</li><li>code-server搭建 50</li><li>mdadm制作raid测试 51</li><li>pxe+ks安装centos 52</li><li>配置linux路由 53</li><li>配置网络-nmcli 54</li><li>配置bond-network 55</li><li>cpuinfo 56</li><li>limits.conf配置 57</li><li>repo文件解释 58</li><li>查看centos系统引导方式 59</li><li>磁盘测速 60</li><li>多线程压缩与解压 61</li><li>防火墙firewalld 62</li><li>防止误删的操作 63</li><li>计算机容量换算 64</li><li>镜像站合集 65</li><li>配置yum源 66</li><li>增加swap分区 67</li><li>bash和csh的区别 68</li><li>CVE漏洞 69</li><li>dnf插件 70</li><li>fcitx码表 71</li><li>fio测速 72</li><li>linux环境变量 73</li><li>linux机器信息采集 74</li><li>lvm操作 75</li><li>RH442系统调优笔记 76</li><li>kickstart脚本 77</li><li>将kickstart封装到iso镜像 78</li><li>配置linux路由 79</li><li>inux好用命令之auditctl 80</li><li>Linux好用命令之ethtool 81</li><li>Linux好用命令之expect 82</li><li>Linux好用命令之nload 83</li><li>Linux好用命令之systemctl 84</li><li>平均负载 85</li><li>Linux显示框架 86</li><li>linux统计实时网速的方法 87</li><li>网络连接数量查看 88</li><li>网卡改名脚本使用 89</li><li>网卡多队列 90</li><li>端口转发 91</li><li>日志分割 92</li><li>lvm分区-缩小 93</li><li>lvm分区-删除 94</li><li>lvm分区-扩容 95</li><li>lvm分区-创建 96</li><li>lvm缩减分区给其他分区扩容 97</li><li>磁盘调度算法更改 98</li><li>Linux Kernel编译的基本步骤 99</li><li>c语言相关，编译等知识 100</li><li>pam加固 101</li><li>Linux显示框架 102</li><li>平均负载 103</li><li>搭建iscsi 104</li><li>grub的相关操作 105</li><li>GRUB了解 106</li><li>Linux快速查找库文件位置 107</li><li>Linux快速查找库文件位置 108</li><li>nfs搭建 109</li><li>perl过滤mac地址 110</li><li>shell编程 shell编程 111</li><li>centos修改网卡名 112</li><li>linux好用命令之wall 113</li><li>三剑客-sed 114</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023目标</title>
      <link href="/posts/7169e9ad.html"/>
      <url>/posts/7169e9ad.html</url>
      
        <content type="html"><![CDATA[<h1>博客目标</h1><ol><li>合并hexo和obsidian的文章，实现obsidian记录，优化之后上hexo</li><li>先把笔记俩者合二为一（结构上，再完善内容）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux启动流程</title>
      <link href="/posts/ae574090.html"/>
      <url>/posts/ae574090.html</url>
      
        <content type="html"><![CDATA[<h2 id="上电">上电</h2><h1>BIOS自检</h1><p>检查CPU、内存、主板、键盘，然后初始化，设置硬件参数，最后是引导程序，bios从硬盘扇区读取引导记录</p><h1>引导介质</h1><p>光盘、硬盘、网络引导，硬盘是否可以引导主要取决于mbr（硬盘前446个字节为主引导记录）分区，硬盘前512个字节包含硬盘分区表信息64字节+55aa标记，55aa用于证明引导扇区是否正确，如果前446个字节正确，前512字节有55aa标记，说明可引导，然后加载到内存中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/sda of=mbr2.bin bs=512 count=1</span><br><span class="line">hexdump -c mbr2.bin</span><br></pre></td></tr></table></figure><ol><li>grub2<br>目前使用最多的是grub2</li></ol><ul><li>boot.img<br>是grub启动的第一个img文件，被写入到MBR中，他的作用是读取属于core.img的第一扇区并跳转到他身上，将控制权交给扇区的img，由于体积大小的限制，boot.img无法理解文件系统的结构，因此grub2-install将会吧core.img的位置硬编码到boot.img中，这样一定可以找到core.img</li><li>core.img<br>core.img根据diskboot.img、kernel.img和一系列模块呗grub2-mkimage程序动态创建</li><li>diskboot.img<br>如果启动设备是硬盘，从硬盘启动开始，core.img中的第一个扇区的内容就是diskboot.img，用于读取core.img的剩余内容到内存，将控制权给kernel.img</li><li>kernel.img<br>包含grub的基本运行时环境，设备框架，文件句柄，环境变量，救援模式下的命令行解析器<br><img src="images/grub%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt=""></li></ul><h1>内核</h1><p>内核启动，进行系统初始化，加载驱动程序，初始化硬件，根文件系统保存在各种设备上，不能将所有驱动都编译进内核</p><ul><li>initrd：动态配置内核临时根文件系统<br>提示一个内压缩过的小型根目录，这个目录包含启动阶段中必须的驱动模块，可执行文件和启动脚本，也包含udevd。当系统启动的时候，BootLoader会把initd读取到内存，然后把initrd文件在内存中的起始地址和大小传给内核，内核在启动初始化的过程中解压initrd文件，然后将解压后的挂载为根目录，然后执行根目录的init脚本，可以在这个脚本中运行initrd文件系统中的udevd，让他自动加载真是文件系统存放设备的驱动程序，以及在/dev目录下建立必要的设备节点，在udevd自动加载磁盘驱动程序总指挥就可以mount到正真的根目录，并切换到这个根目录，利用initrd可以使内核在启动阶段顺利完成各种存储介质的驱动的加载和真实文件系统的挂载</li><li>initrd格式</li></ul><ol><li>image</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=initrd.img bs=4k count=1024</span><br><span class="line">mkfs.ext2 -F -m initrd.img </span><br><span class="line">mkdir /mnt/ramdisk</span><br><span class="line">mount -o loop initrd.img  /mnt/ramdisk</span><br><span class="line">cp -r /opt/filesystem   /mnt/ramdisk</span><br><span class="line">umount /mnt </span><br><span class="line">gzip -9 initrd.img</span><br></pre></td></tr></table></figure><ol><li>cpio</li></ol><h1>引导程序（init，systemd）</h1><h2 id="init">init</h2><p>内核初始化之后执行init进程，内核会在过去曾经使用init的几个地方找他，如果找不到就执行/bin/sh，如果运行失败，系统启动失败，启动成功之后init成为linux的父进程，启动会读取/etc/inittab找到运行级别，也可以在内核给他指定运行级别（single），接着在fstab找到分区信息挂载，然后init驱动/etc/rcx.d执行对应级别的脚本</p><h3 id="init进程的配置文件">init进程的配置文件</h3><ol><li>/etc/init.d/<br>服务启动脚本配置文件存放目录</li><li>/etc/inittab<br>运行级别</li><li>/etc/init/rcS.conf<br>系统初始化配置文件</li><li>/etc/init/rc.conf<br>各个运行级别初始化配置文件</li><li>/etc/init/rcS-sulogin.conf<br>单用户模式启动/sbin/sushell环境的配置文件</li><li>/etc/init/control-alt-delete.conf<br>按下ctrl+alt+delte的热键</li><li>/etc/sysconfig/init<br>tty终端配置文件</li><li>/etc/init/start-ttys.conf<br>配置tty中单开启数量，设备文件</li><li>/etc/init/tty.conf<br>控制tty终端的开启</li></ol><h2 id="systemd">systemd</h2><p>尽可能启动少的进程，尽可能并行启动，减少对shell脚本的依赖，使用target来处理引导和服务管理过程，target文件被分组用于不同的引导单元以及启动同步进程，systemd的执行第一个目标是default.target，是默认执行模板，实际上default.target是执行graphical.target的软链接，可以修改这个软链接改变启动级别，执行default那个之后就是进入递归的处理依赖关系</p><h3 id="systemd的配置文件">systemd的配置文件</h3><ol><li>/etc/systemd/system/default.target</li><li>/etc.systemd/server 系统执行过程中所产生的服务脚本所在目录</li><li>/etc/systemd/system 里面存着不同级别的开机自启服务</li><li>/usr/lib/systemd/system每个服务最主要的启动脚本</li></ol><h3 id="模式">模式</h3><ol><li>0 关机</li><li>1 救援</li><li>2 字符的多用户不可访问网络</li><li>3 字符</li><li>4 没用</li><li>5 图形</li><li>6 重启</li></ol><h2 id="区别">区别</h2><ul><li>init</li></ul><ol start="4"><li>init全是shell脚本完成</li><li>串行启动，只有前一个启动只才会启动后面的</li><li>启动脚本复杂，init进程只是执行启动脚本，不管其他事情，脚本需要自己处理各种情况</li><li>由内核加载运行，PID=1,是系统中第一个进程</li></ol><ul><li>systemd</li></ul><ol start="8"><li>是配置文件的方式，属于应用程序引导</li><li>按需启动，减少资源消耗</li><li>尽可能并行启动</li><li>由内核加载运行，PID=1,是系统中第一个进程，位于/usr/lib/systemd/systemd</li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基操 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pxe+ks安装centos</title>
      <link href="/posts/97d0e5b8.html"/>
      <url>/posts/97d0e5b8.html</url>
      
        <content type="html"><![CDATA[<h1>PXE概述</h1><p>PXE(Pre-boot Execution Environment)是由Intel设计的协议，它可以使计算机通过网络启动。工作在Client/Server模式，允许客户机通过网络从远程服务器下载引导镜像，并加载安装文件或者整个操作系统</p><h1>PXE优点</h1><p>1、规模化：可以同时装配多台服务器；<br>2、自动化：安装系统、配置各种服务；<br>3、远程实现：不需要光盘、U盘等介质进行安装</p><h1>实现PXE安装条件</h1><p>1、客户机的网卡需要支持PXE协议，且主板支持网络引导。一般服务器都支持，只需要进入BIOS设置允许从Network或LAN启动即可<br>2、网络中有一台DHCP服务器以便为客户机自动分配IP地址，指定引导文件位置。<br>3、服务器要通过（简单文件传输协议）服务来提供系统内核和引导镜像文件的下载。</p><h1>注意事项</h1><p>安装成功的最关键因素在于kS脚本的编写，其他nginx tftp dhcp只是辅助用于客户机访问ks，源，传输用的</p><h1>安装步骤</h1><h2 id="安装组件功能介绍">安装组件功能介绍</h2><p>Kickstart ： 将安装过程的参数写入到ks.cfg文件，实现自动安装配置达到无人值守自动安装<br>： 支持PXE 引导的网卡中从服务器端下载pxelinux.0文件、vmlinuz、initrd.img等内核引导文件<br>DHCP ： PXE引导过程中先获取IP地址，并提供pxelinux.0文件位置<br>HTTP ： 用于下载ks.cfg以及系统镜像文件</p><h2 id="配置nginx">配置nginx</h2><ul><li>安装nginx<br>可以源码编译安装，如果源里面有需要的版本可以yum安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx </span><br></pre></td></tr></table></figure><ul><li>挂载镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/centos/7/os/x86_64 -p</span><br></pre></td></tr></table></figure><p>将centos7最小化镜像挂载到目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount CentOS-7-x86_64-Minimal-2009.iso   /data/centos/7/os/x86_64</span><br></pre></td></tr></table></figure><ul><li>修改nginx配置<br>挂载/data目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /data;</span><br><span class="line">        index index.html index.php index.htm;</span><br><span class="line">        autoindex on;   # 允许显示目录</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动nginx</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now nginx</span><br></pre></td></tr></table></figure><ul><li>验证结果<br>访问http://192.168.42.132/centos/7/os/x86_64,最终实现可以访问到centos挂载的内容</li></ul><h2 id="配置dhcp服务">配置dhcp服务</h2><ul><li>安装软件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y dhcp</span><br></pre></td></tr></table></figure><ul><li>修改主机名</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl set-hostname pxe.com</span><br></pre></td></tr></table></figure><ul><li>修改配置<br>修改/etc/dhcp/dhcpd.conf,对自己的一张网卡设置ip地址为192.168.1.100(具体可以自定义)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置租约时间和最大租约时间</span></span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义域名</span></span><br><span class="line">option domain-name &quot;pxe.com&quot;;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义地址池的子网、掩码、网关和地址池范围，定义地址</span></span><br><span class="line">subnet 192.168.1.0 netmask 255.255.255.0 &#123;</span><br><span class="line">      range 192.168.1.10 192.168.1.20;</span><br><span class="line">      option routers 192.168.1.1;</span><br><span class="line">      next-server 192.168.1.100;</span><br><span class="line">      filename &quot;pxelinux.0&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动服务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now dhcpd</span><br></pre></td></tr></table></figure><h2 id="编写KS脚本">编写KS脚本</h2><p>每个系统安装完毕之后在/root下都有一个anaconda-ks.cfg文件，这其实就是当前系统安装时用的脚本，我们可以根据此文件进行修改，也可以自己重头来写，也可以安装system-config-kickstart此软件进行图形化编写，如果不会就先安装一遍系统然后根据系统的学习</p><ul><li>设置新系统root密码<br>这个密码需要替换到ks脚本里面的rootpw，作为新系统的密码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import crypt;print crypt.crypt(&quot;niubi.ks&quot;)&#x27;</span><br></pre></td></tr></table></figure><ul><li>存放ks脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/ksdir</span><br><span class="line">touch /data/ksdir/ks7-mini.cfg</span><br><span class="line">chmod +r /data/ksdir/ks7-mini.cfg</span><br></pre></td></tr></table></figure><ul><li>ks脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">version=DEVEL</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System authorization information</span></span><br><span class="line">auth --enableshadow --passalgo=sha512</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use pxe install</span> </span><br><span class="line">url --url=http://192.168.1.100/centos/7/os/x86_64</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use graphical install</span></span><br><span class="line">graphical</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run the Setup Agent on first boot</span></span><br><span class="line">firstboot --disable</span><br><span class="line">ignoredisk --only-use=sda</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Keyboard layouts</span></span><br><span class="line">keyboard --vckeymap=us --xlayouts=&#x27;us&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System language</span></span><br><span class="line">lang en_US.UTF-8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Network information</span></span><br><span class="line">network  --bootproto=dhcp --device=eth0 --onboot=off --ipv6=auto --no-activate</span><br><span class="line">network  --hostname=localhost.localdomain</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Root password</span></span><br><span class="line">rootpw --iscrypted $6$9SJ2mbfniIe1xZMv$vQGhIJeDNIX7MeIgAV36vew9ptH.F8VuHloW3eacdKAxwDFVAa8TViUZlN8SpZgu22EEySuyegRsPlRLRoftN1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System services</span></span><br><span class="line">services --enabled=&quot;chronyd&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System timezone</span></span><br><span class="line">timezone Asia/Shanghai --isUtc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System bootloader configuration</span></span><br><span class="line">bootloader --append=&quot; crashkernel=auto&quot; --location=mbr --boot-drive=sda</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Partition clearing information</span></span><br><span class="line">clearpart --none --initlabel</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Disk partitioning information</span></span><br><span class="line">part /boot/efi --fstype=&quot;efi&quot; --ondisk=sda --size=200 --fsoptions=&quot;umask=0077,shortname=winnt&quot;</span><br><span class="line">part pv.156 --fstype=&quot;lvmpv&quot; --ondisk=sda --size=49974</span><br><span class="line">part /boot --fstype=&quot;ext4&quot; --ondisk=sda --size=1024</span><br><span class="line">volgroup centos --pesize=4096 pv.156</span><br><span class="line">logvol swap  --fstype=&quot;swap&quot; --size=2048 --name=swap --vgname=centos</span><br><span class="line">logvol /  --fstype=&quot;ext4&quot; --grow --maxsize=51200 --size=1024 --name=root --vgname=centos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">packages</span></span><br><span class="line">@^minimal</span><br><span class="line">@core</span><br><span class="line">chrony</span><br><span class="line">kexec-tools</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">end</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">addon com_redhat_kdump --<span class="built_in">enable</span> --reserve-mb=<span class="string">&#x27;auto&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">end</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">anaconda</span></span><br><span class="line">pwpolicy root --minlen=6 --minquality=1 --notstrict --nochanges --notempty</span><br><span class="line">pwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyok</span><br><span class="line">pwpolicy luks --minlen=6 --minquality=1 --notstrict --nochanges --notempty</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">end</span></span><br></pre></td></tr></table></figure><h2 id="配置tftp">配置tftp</h2><ul><li>安装软件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y  tftp-server syslinux xinetd</span><br></pre></td></tr></table></figure><ul><li>修改tftp配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/xinetd.d/tftp </span><br></pre></td></tr></table></figure><p>修改如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">service </span><br><span class="line">&#123;</span><br><span class="line">socket_type= dgram</span><br><span class="line">protocol= udp</span><br><span class="line">wait= yes</span><br><span class="line">user= root</span><br><span class="line">server= /usr/sbin/in.d</span><br><span class="line">server_args= -s /var/lib/boot</span><br><span class="line">disable= no</span><br><span class="line">per_source= 11</span><br><span class="line">cps= 100 2</span><br><span class="line">flags= IPv4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>拷贝文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/tftpboot</span><br><span class="line">mkdir 7 pxelinux.cfg</span><br><span class="line">cp /usr/share/syslinux/&#123;pxelinux.0,menu.c32&#125;  .</span><br><span class="line">cp /data/centos/7/os/x86_64/isolinux/&#123;vmlinuz,initrd.img&#125; 7</span><br></pre></td></tr></table></figure><ul><li>修改pxe启动项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/tftpboot/pxelinux.cfg/default</span><br></pre></td></tr></table></figure><p>内容如下，请确保http://192.168.1.100/ksdir/ks7-mini.cfg可以访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果将值修改为正文mini标签的话，默认选择mini标签，不会让用户选择</span></span><br><span class="line">default menu.c32</span><br><span class="line">timeout 600</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">背景标题</span></span><br><span class="line">menu title ########## GXM-PXE Boot Menu ##########</span><br><span class="line">label mini7</span><br><span class="line">    menu label install centos mini 7</span><br><span class="line">    kernel 7/vmlinuz</span><br><span class="line">    append initrd=7/initrd.img ks=http://192.168.1.100/ksdir/ks7-mini.cfg</span><br><span class="line">label local</span><br><span class="line">    menu default</span><br><span class="line">    menu label ^Boot from local drive</span><br><span class="line">    localboot 0xffff</span><br></pre></td></tr></table></figure><ul><li>启动服务</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">enable</span> <span class="comment">--now xinetd tftp</span></span><br></pre></td></tr></table></figure><h2 id="客户端网络引导启动">客户端网络引导启动</h2><p>设置客户端系统为网络启动，查看开机引导画面测试</p>]]></content>
      
      
      <categories>
          
          <category> kickstart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kickstart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之dd</title>
      <link href="/posts/3f7fa63c.html"/>
      <url>/posts/3f7fa63c.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><blockquote><p><a href="https://www.cnblogs.com/sylar5/p/6649009.html">Linux 中用 dd 命令来测试硬盘读写速度 - Cyril_Wu - 博客园 (cnblogs.com)</a></p></blockquote><h1>基本用法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time dd if=/dev/zero  of=/dev/null bs=block_size count=number_of_blocks</span><br></pre></td></tr></table></figure><h1>参数选项</h1><ul><li>选项<ul><li>if=file  ：从 file 中读而不是标准输入</li><li>of=file ：写到 file 里去而不是标准输出</li><li>bs=bytes ：一次读和写  bytes 字节</li><li>ibs=bytes ：一次读 bytes 字节。默认是512</li><li>obs=bytes ：一次写 bytes 字节。默认是512</li><li>count=blocks ： 仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数</li><li>iflag=FLAGS   ：指定读的方式FLAGS</li><li>oflag=FLAGS  ：指定写的方式FLAGS</li></ul></li><li>FLAGS如下<ul><li>direct　　　读写数据采用直接IO方式；</li><li>directory　读写失败除非是directory；</li><li>dsync　　　读写数据采用同步IO；</li><li>sync　　　　同上，但是针对是元数据</li><li>fullblock　　堆积满block(iflag only)；</li><li>nonblock　读写数据采用非阻塞IO方式</li><li>noatime　　 读写数据不更新访问时间</li></ul></li></ul><h1>磁盘写能力测试</h1><p>/dev/zero是一个伪设备，只产生空字符流，不会产生IO，IO都会集中在of文件中，所以这个命令是测试磁盘的写能力。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=test bs=8k count=10000 oflag=direct</span><br></pre></td></tr></table></figure><h1>读取能力测试</h1><p>/dev/sdb是一个物理分区，对它的读取会产生IO，/dev/null是伪设备，是黑洞，of到该设备不会产生IO，所以，这个命令的IO只发生在/dev/sdb上，也相当于测试磁盘的读能力</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=test of=/dev/null bs=8k count=10000 iflag=direct</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之rsync</title>
      <link href="/posts/bc5c9a0b.html"/>
      <url>/posts/bc5c9a0b.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>同步的手段</p><h1>简单用法</h1><p>静态文件部署，一般会用到此命令，完整命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --progress -e &#x27;ssh -p 2022&#x27; --exclude=&#x27;testfile&#x27; --delete $&#123;WORKSPACE&#125;/  root@192.168.42.100:/data/</span><br></pre></td></tr></table></figure><h1>参数可用</h1><ul><li>-a：–archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD</li><li>-v：输出详细过程</li><li>-z：对正在备份的文件进行压缩处理</li><li>-r：对子目录以递归模式处理</li><li>-l：保留软连接</li><li>-p：保持文件权限</li><li>-t：保持文件时间信息</li><li>-g：保持文件属组信息</li><li>-o：保持文件属主信息</li><li>-D：保持设备文件信息</li><li>-e： –rsh=command 指定使用rsh、ssh方式进行数据同步，一般使用ssh</li><li>exclude: 排除某文件的同步，可以多个。</li><li>–delete：删除那些DST中SRC没有的文件。</li><li>–progress：显示每个文件传输的进度。知道是否有大型文件正在备份可能是有用的</li></ul><h1>几个坑</h1><ul><li><p>将dirA的所有文件同步到dirB内，并删除dirB内多余的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --delete dirA/ dirB/ </span><br></pre></td></tr></table></figure></li></ul><blockquote><p>源目录和目标目录结构一定要一致！！</p><p>不能是dirA/* dirB/ 或者dirA/ dirB/* 或者 dirA/* dirB/*，如果不遵守，那么就不会删除。</p></blockquote><ul><li><p>将dirA的所有文件同步到dirB，但是在dirB内除了fileB3.txt这个文件不删之外，其他的都删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --delete --exclude &quot;fileB3.txt&quot; dirA/ dirB/</span><br></pre></td></tr></table></figure></li><li><p>将dirA目录内的fileA1.txt和fileA2.txt不同步到dirB目录内</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude=&quot;fileA1.txt&quot; --exclude=&quot;fileA2.txt&quot; dirA/ dirB/</span><br></pre></td></tr></table></figure></li><li><p>将dirA目录内的fileA1.txt和fileA2.txt不同步到dirB目录内，并且在dirB目录内删除多余的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude=&quot;fileA1.txt&quot; --exclude=&quot;fileA2.txt&quot; --delete dirA/ dirB/</span><br></pre></td></tr></table></figure></li><li><p>将dirA目录内的fileA1.txt和fileA2.txt不同步到dirB目录内，并且在dirB目录内删除多余的文件，同时，如果dirB内有fileA2.txt和fileA1.txt这两个被排除同步的文件，仍然将其删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude=&quot;fileA1.txt&quot; --exclude=&quot;fileA2.txt&quot; --delete-excluded dirA/ dirB/</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Centos中检查RPM包的依赖性</title>
      <link href="/posts/179557ff.html"/>
      <url>/posts/179557ff.html</url>
      
        <content type="html"><![CDATA[<h1>产生原因</h1><ol><li>定制本地yum源的时候漏了几个依赖包,导致软件无法安装</li><li>配置的仓库包不完整,下载的软件的时候缺少几个包</li><li>由于网络环境,无法配置外网源,只能导入rpm包,但是缺少了几个依赖</li></ol><blockquote><p>很多场景下，是不允许配置yum源的</p></blockquote><h1>一个简单的栗子</h1><ul><li>安装zabbix的时候缺少依赖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh zabbix-server-mysql-3.4.4-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error: Failed dependencies:</span><br><span class="line">libOpenIPMI.so<span class="number">.0</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libOpenIPMIposix.so<span class="number">.0</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libevent-<span class="number">2.0</span>.so<span class="number">.5</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libiksemel.so<span class="number">.3</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libnetsnmp.so<span class="number">.31</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libodbc.so<span class="number">.2</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br></pre></td></tr></table></figure><p>显然是机器导入的rpm缺少依赖包导致的,但我们只能看到文件,无法看到这个文件在什么包</p><ul><li>查询在哪个rpm包</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> whatprovides libOpenIPMI.so.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>结果如下,可以看到这文件是OpenIPMI-libs提供的,我们可以直接yum安装,或者由于网络问题,可以下载了导入机器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos, versionlock</span><br><span class="line">OpenIPMI-libs-2.0.27-1.el7.i686 : The OpenIPMI runtime libraries</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Provides    : libOpenIPMI.so.0</span><br></pre></td></tr></table></figure><ul><li><p>安装</p><ul><li><p>直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y OpenIPMI-libs-2.0.27-1.el7.i686</span><br></pre></td></tr></table></figure></li><li><p>下载导入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yumdownloader</span> --destdir=.   OpenIPMI-libs-<span class="number">2</span>.<span class="number">0</span>.<span class="number">27</span>-<span class="number">1</span>.el7.i686</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>优化解决依赖手法1</h1><p>除了<code>yum whatprovides libOpenIPMI.so.0</code>这种粗暴方式,其实我们有更好的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum deplist  zabbix50-5.0.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>输出如下.可以看到什么包需要什么,由谁提供</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos, versionlock</span><br><span class="line">package: zabbix50.x86_64 5.0.21-1.el7</span><br><span class="line">  dependency: config(zabbix50) = 5.0.21-1.el7</span><br><span class="line">   provider: zabbix50.x86_64 5.0.21-1.el7</span><br><span class="line">  dependency: libc.so.6()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.11)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.14)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.15)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.17)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.2.5)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.3)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.3.4)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.4)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.7)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libcrypto.so.10()(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcrypto.so.10(OPENSSL_1.0.1_EC)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcrypto.so.10(OPENSSL_1.0.2)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcrypto.so.10(libcrypto.so.10)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcurl.so.4()(64bit)</span><br><span class="line">   provider: libcurl.x86_64 7.29.0-59.el7_9.1</span><br><span class="line">  dependency: libdl.so.2()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libm.so.6()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libm.so.6(GLIBC_2.2.5)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libpcre.so.1()(64bit)</span><br><span class="line">   provider: pcre.x86_64 8.32-17.el7</span><br><span class="line">  dependency: libpthread.so.0()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libpthread.so.0(GLIBC_2.2.5)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libresolv.so.2()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libssl.so.10()(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libssl.so.10(libssl.so.10)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libz.so.1()(64bit)</span><br><span class="line">   provider: zlib.x86_64 1.2.7-20.el7_9</span><br><span class="line">  dependency: libz.so.1(ZLIB_1.2.0)(64bit)</span><br><span class="line">   provider: zlib.x86_64 1.2.7-20.el7_9</span><br><span class="line">  dependency: logrotate</span><br><span class="line">   provider: logrotate.x86_64 3.8.6-19.el7</span><br><span class="line">  dependency: rtld(GNU_HASH)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">   provider: glibc.i686 2.17-326.el7_9</span><br></pre></td></tr></table></figure><h1>优化解决依赖手法2</h1><p>配置一台和生产测试一样的虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zabbix50-5.0.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>使用yum install会自己查询依赖，如下所示，我们可以直接得到需要的依赖关系</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">正在安装</span><br><span class="line">ansible</span><br><span class="line">为依赖而安装</span><br><span class="line"><span class="keyword">python</span>-babel</span><br><span class="line"><span class="keyword">python</span>-httplib2</span><br><span class="line"><span class="keyword">python</span>-jinja2</span><br><span class="line"><span class="keyword">python</span>-paramiko</span><br><span class="line">python2-jmespath</span><br></pre></td></tr></table></figure><p>我们再次用<code>yumdownloader</code>命令进行下载包</p><h1>优化解决依赖手法3</h1><p>我常用的方法,但<code>需要注意</code>的是,使用<code>yumdownloader</code>的时候,他会检测本机的rpm包,然后下载软件缺失的依赖包,那么就是说,如果我本机和目的rpm列表有出入,可能我本机的包更多,那么我下载的依赖可能更少,那么导入目标机器结果依赖可能还是没解决,所以我们这个手法还是需要保持俩台机器的环境一致</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumdownloader --destdir=<span class="regexp">/root/</span>Desktop/rpms --resolve ansible</span><br></pre></td></tr></table></figure><h1>小工具-rpmreaper</h1><p>本来是用作清理系统中无用以及它们所依赖的包，它有很直观的ncurses界面来展示已安装的包和它们依赖关系的树形图</p><ul><li>安装</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> rpmreaper</span><br></pre></td></tr></table></figure><ul><li>运行</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rpmreaper</span></span><br></pre></td></tr></table></figure><p>rpmrepater会向用户显示已安装包的列表</p><ol><li><p>你可以使用上/下箭头来滚动屏幕</p></li><li><p>你可以在指定包上使用&quot;r&quot;键来显示其依赖关系，循环在指定包上按下&quot;r&quot;键可以展示出余下的信息</p></li><li><p>&quot;L&quot;标志的意思是说这个包是一片“孤叶”，意思说说没有任何包依赖它</p></li><li><p>&quot;o&quot;标志是说这个包是整个依赖链的中间部分</p></li><li><p>按下&quot;b&quot;键会显示其他依赖于该包的其他包</p></li></ol><h1>小工具-yumex</h1><p>yum Extender (简称 yumex ) , 是 yum 的图形化操作界面。可以通过 yumex 方便的查看软件包，安装、卸载软件包。对于对命令行不熟的人简直就是神奇，管理软件包很方便</p><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install yumex</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumex --root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局域网ip冲突解决方法</title>
      <link href="/posts/771f3e87.html"/>
      <url>/posts/771f3e87.html</url>
      
        <content type="html"><![CDATA[<h1>问题描述</h1><p>由于在一个网段下面ip地址是唯一的,当产生2个一样的ip的时候就会出现网络故障,可以hi使用一个工具<code>arp-scan</code>来扫描它们，这个工具会在本地网络发送ARP（Address Resolution Protocol）(地址解析协议)包来收集地址。如果有多个MAC地址声称拥有相同的IP地址，那么就存在冲突</p><h1>安装软件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y arp-scan</span><br></pre></td></tr></table></figure><h1>冲突检测</h1><p>指定eth1网卡进行检测</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan  --interface=eth1 -l</span><br></pre></td></tr></table></figure><h1>输出结果</h1><p>虚拟机不是很准,实际上是可以看到<code>DUP</code>的报错</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">1</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:c0:<span class="number">00</span>:<span class="number">08</span>VMware, Inc.</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">2</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:e1:<span class="number">0</span>b:edVMware, Inc.</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">254</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:e4:eb:<span class="number">75</span>VMware, Inc.</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">2</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:e1:<span class="number">0</span>b:edVMware, Inc. (DUP: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之tar</title>
      <link href="/posts/2208ab89.html"/>
      <url>/posts/2208ab89.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>Unix和<a href="https://baike.baidu.com/item/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F/4336219?fromModule=lemma_inlink">类Unix系统</a>上的压缩打包工具，可以将多个文件合并为一个文件，打包后的文件后缀亦为<strong>tar</strong></p><h1>参数</h1><h2 id="功能">功能</h2><ul><li>-c 创建压缩文件</li><li>-x  解压缩,提取</li><li>-t  查看压缩包内容</li><li>-r  附加新的文件到tar文件中</li><li>-u 用已打包的文件的较新版本更新tar文件</li><li>-A 将tar文件作为一个整体追加到另一个tar文件中</li><li>-d,–compare 将文件系统里的文件和tar文件里的文件进行比较</li><li>–delete  删除tar文件里的文件</li></ul><h2 id="常用选项">常用选项</h2><ul><li>-v 啰嗦模式,展示过程</li><li>-z 通过gzip指令压缩/解压缩文件,文件后缀名自己加<code>*.tar.gz</code></li><li>-p 保留原来的文件权限与属性</li><li>–exclude= 排除</li><li>-C 仅压缩指定目录里的内容或解压缩到指定目录</li></ul><h1>打包压缩</h1><ul><li>经典打包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf test.tar.gz  shell/  a.txt   b.sh</span><br></pre></td></tr></table></figure><ul><li>压缩带属性</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvpf log31.tar.gz log2014.log log2015.log log2016.log</span><br></pre></td></tr></table></figure><ul><li>压缩排除某些文件夹</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --exclude=/opt/test/a -czvf test.tar.gz /opt/test</span><br></pre></td></tr></table></figure><h1>列举查看压缩包</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf test<span class="selector-class">.tar</span><span class="selector-class">.gz</span> </span><br></pre></td></tr></table></figure><h1>解压缩</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf test.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压部分文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf  log.tar.gz  test/a.log</span><br></pre></td></tr></table></figure><blockquote><p>这个要先用-tvf列举出具体路径,不然找不到我示例的test/a.log</p></blockquote><ul><li>解压到指定位置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf a.tar.gz -C /opt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程压缩与解压</title>
      <link href="/posts/c9c09545.html"/>
      <url>/posts/c9c09545.html</url>
      
        <content type="html"><![CDATA[<h1>pigz简介</h1><p>使用pigz，利用了多核cpu，提高了压缩速度，将我们闲置的核心利用起来！</p><h1>前提</h1><p>首先要安装一个pigz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pigz</span><br></pre></td></tr></table></figure><h1>pigz常用命令参数</h1><ul><li>-p: 设置最大使用线程数量，默认所有在线cpu，如果不能获取cpu数量，则取8</li><li>-b：设置压缩块大小，默认128k</li><li>-d：解压缩</li><li>-q：静默模式，不输出任何信息</li><li>-k：不删除原始文件</li><li>-l：输出压缩内容</li><li>-r：递归子目录</li><li>-S：使用sss后缀替换gz</li><li>-v：输出详细信息</li></ul><h1>多线程压缩</h1><p>–use-compress-program=pigz即代表使用的pigz工具</p><blockquote><p>加time只是用来对比时间</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time tar --use-compress-program=pigz -cvpf dxc.tar.gz  ./*</span><br></pre></td></tr></table></figure><h1>多线程解压</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time tar --use-compress-program=pigz -xvpf dxc.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pigz -p 8 -d output.tgz</span><br></pre></td></tr></table></figure><h1>pigz参数使用方式</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --<span class="keyword">use</span>-<span class="keyword">compress</span>-<span class="keyword">program</span>=<span class="string">&quot;pigz -k -p8&quot;</span> -cvf output.tgz   /<span class="keyword">var</span>/<span class="keyword">log</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的驱动问题</title>
      <link href="/posts/8715157e.html"/>
      <url>/posts/8715157e.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>安装windows系统一般都会下载<code>驱动总裁</code>或者<code>鲁大师</code>,又或者通过微软的自动更新来更新系统的驱动,但在Linux里面,驱动一般是集成在linux内核里面的,如果我们有一个pci设备没有驱动且内核不支持该怎么处理?</p><h1>查看设备驱动</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lspci -k</span> </span><br></pre></td></tr></table></figure><p>可以先浏览一遍所有的pci设备,只需要关注每个设备是否有<code>Kernel driver in use</code>等字样,如果有的话就代表该设备可以驱动</p><ul><li>举个例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">02</span>:<span class="number">01.0</span> Ethernet controller: Intel Corporation 82545EM Gigabit Ethernet <span class="title function_">Controller</span> <span class="params">(Copper)</span> (rev <span class="number">01</span>)</span><br><span class="line">DeviceName: Ethernet0</span><br><span class="line">Subsystem: VMware PRO/<span class="number">1000</span> MT Single Port Adapter</span><br><span class="line">Kernel driver in use: e1000</span><br><span class="line">Kernel modules: e1000</span><br></pre></td></tr></table></figure><p>例如我有一个网卡,他成功加载了e1000的驱动,这样就代表我们可以使用该网卡</p><h1>没有驱动的处理</h1><p>如果没有<code>Kernel driver in use</code>字样,处理手段一般是<code>确认硬件型号</code>-&gt;<code>搜寻源代码</code>-&gt;<code>编译安装</code>来解决的</p><h2 id="确定型号">确定型号</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -<span class="keyword">nn</span> | <span class="keyword">grep</span> -i eth</span><br></pre></td></tr></table></figure><p>我们通过<code>-nn</code>参数来将<code>厂商号:设备号</code>输出如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">02</span>:<span class="number">01</span>.<span class="number">0</span> Ethernet : Intel Corporation <span class="number">82545</span>EM Gigabit <span class="meta"> [8086:100f] (rev 01)</span></span><br></pre></td></tr></table></figure><p>其中,我们只需要关注<code>[8086:100f]</code>这组数据就可以了</p><h2 id="含义">含义</h2><p><code>8086</code>是厂商号,代表某家厂商,<code>100f</code>是设备号,代表该厂商的产品</p><p>一般来说,如果内核完全不认网卡的话我们只能看出产品名字写的是<code>Ethernet</code>,也有一部分系统<code>可以认出全名</code>,如果能认出全名我们直接搜索全名就可以了,但如果没有全名我们只能依赖<code>厂商号:设备号</code>来定位设备</p><h2 id="网页搜索">网页搜索</h2><p>登陆<a href="https://devicehunt.com/">devicehunt网站</a>,我们只需要将我们的<code>device id</code>,即我例子中的<code>100f</code>填入搜索框,他就会将该设备的名字查询出来,类似这种网站的还有很多,比如 <a href="http://pci-ids.ucw.cz/read/PC/8088/0107">pci-ids.ucw.cz</a></p><h2 id="查找驱动">查找驱动</h2><p>既然已经知道型号了,那么就可以搜索对应的驱动源代码,一般找的网站有如下</p><ol><li>各个产品的官网</li><li>github或者gitee</li><li>我不知道了</li></ol><p>假设我们成功的找到的某个产品的驱动源代码,我们只需要导入我们的<code>linux发行版</code>进行编译安装</p><h1>编译安装</h1><p>例如我成功在<code>INTEL</code>官网下载了<code>e1000e-3.8.7.tar.gz</code>源码包</p><ul><li>解压源码包</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf e1000e-<span class="number">3</span>.<span class="number">8</span>.<span class="number">7</span>.tar.gz</span><br></pre></td></tr></table></figure><ul><li>查看README</li></ul><p>每个产品都会有类似的<code>README</code>文档来指导你如何使用,例如有如下2种方式,第一种就是让我们用<code>rpmbuild</code>来自己生成一个<code>rpm</code>包,第二种会让我生成一个<code>ko</code>文件,然后安装到内核里面去,然后我们再去使用<code>lspci</code>查看驱动的办法来验证是否记载驱动就可以了</p><ol><li><code>rpmbuild -tb e1000e-&lt;x.x.x&gt;.tar.gz</code></li><li>手动编译<ol><li>查看具体步骤,是否要先./configure</li><li>make编译</li><li>insmod xx.ko 手动加载驱动</li><li>使用lspci -nvs 01:00.0这种来看设备的驱动是否加载</li><li>如果加载成功就make install</li></ol></li></ol><blockquote><ol><li>makera,centos这些系统有的命令</li><li>make,gcc,g++这种命令属于开发工具,如果系统没有的话需要自己安装</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之strace</title>
      <link href="/posts/dd9530c1.html"/>
      <url>/posts/dd9530c1.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>strace是用来诊断,调试的linux用户空间跟踪器,来监视用户空间进程和内核交互,比如系统调用,信号传递,进程状态变更</p><h1>示例</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -tt -T -v -f -e [close|openat|execve] -o log  ./ceshi.sh -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><h1>常用选项</h1><ul><li>-tt : 显示毫秒级别</li><li>-T : 显示每次系统调用所消耗的时间</li><li>-v : 对于某些相关的调用,展示完整的环境变量,文件stat结构</li><li>-f : 跟踪目标进程以及目标进程创建的子进程</li><li>-e : 控制要跟踪的时间和跟踪行为,比如指定要跟踪的系统调用名称</li><li>-o : 把strace输出单独写到文件</li><li>-s : 系统调用某个参数是字符串的四行,最多输出指定长度的内容,默认32字节</li><li>-p : 指定要跟踪的进程pid 多个pid写多个-p</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统资源异常处理思路</title>
      <link href="/posts/e853bb7.html"/>
      <url>/posts/e853bb7.html</url>
      
        <content type="html"><![CDATA[<h1>常见资源问题</h1><ol><li>系统操作卡顿</li><li>cpu,内存资源占用过高</li><li>进程占用资源高</li><li>系统异常重启或宕机</li><li>开机时间长</li></ol><h1>资源异常处理思路</h1><h2 id="日志分析">日志分析</h2><ul><li>dmesg</li><li>/var/log/*</li><li>串口调试</li><li>~/.xsession-errors</li></ul><h2 id="卡顿分析">卡顿分析</h2><ul><li>本地卡顿还是远程卡顿</li></ul><h2 id="异常进程">异常进程</h2><ul><li>strace进程跟踪</li><li>pstack进程跟踪</li><li>jstack进程跟踪(针对java)</li></ul><h2 id="更换用户测试">更换用户测试</h2><ul><li>切换用户没有问题则考虑~/.conf  ~/.cache 环境变量</li></ul><h2 id="是否和显卡有关系">是否和显卡有关系</h2><ul><li>是否有硬件加速</li><li>更换硬件</li><li>xdriinfo或Xorg.0.log日志分析</li></ul><h2 id="内核或驱动">内核或驱动</h2><ul><li>升级驱动(<a href="http://kernel.org">kernel.org</a>)</li><li>升级内核</li></ul><h2 id="core文件">core文件</h2><ul><li>tmp目录下是否有core,或者第三方程序下是否有</li><li>gdb调试</li></ul><h2 id="是否与桌面图形相关">是否与桌面图形相关</h2><ul><li>top看图形进程占用</li><li>关闭图形是否临时解决</li><li>lightdm/gdm服务状态</li></ul><h1>linux性能分析工具</h1><h2 id="cpu">cpu</h2><ul><li>top :  显示系统和进程cpu,内存关系</li><li>uptime :  系统平均负载</li><li>vmstat :  报告和采样内存,io,cpu信息</li><li>procinfo :  cpu和中断信息</li><li>mpstat :  分析cpu</li><li>sar :  分析cpu</li><li>oprofile :  分析系统,进程的消耗</li><li>perf :  分析cpu调用路径和消耗</li><li>time :  进程cpu使用信息</li><li>strace :  系统调用信息</li><li>lstrace :  库函数调用信息和耗时</li><li>ps :  对特定进程分析</li><li>pidstat :  分析进程对cpu的占用</li></ul><h2 id="内存">内存</h2><ul><li>vmstat :  分析内存,io,cpu</li><li>free :  展示系统和进程cpu,内存,使用情况</li><li>slabtop :  内核缓存分配和使用情况</li><li>sar -r :  内存信息</li><li>/proc/memoryinfo :  内存信息</li><li>ps  :  进程和内存关系</li><li>/proc/<pid>/mem :  进程内存信息</li><li>memprof :  图形化内存分析</li><li>kcachegnnd :  图形化内存分析</li><li>/proc/iomem :  物理地址分配信息</li><li>pmap :  进程内存映射信息</li></ul><h2 id="磁盘">磁盘</h2><ul><li>iostat :  统计设备和分区磁盘IO信息</li><li>iotop :  列出进程磁盘IO信息</li><li>sar -d :  报告磁盘IO相关信息</li><li>blktrace :  跟踪磁盘IO时间</li><li>lsof :  列出进程打开文件,目录信息</li><li>pidstat -d  :  进程磁盘io统计信息</li><li>dd :  测速</li><li>dstat :  全能的系统信息统计工具</li><li>fio :  测速</li><li>mount :  挂载</li><li>badblocks :  检查磁盘损坏的区块</li></ul><h2 id="网络">网络</h2><ul><li>nmcli :  网络配置工具</li><li>ifconfig :  网络接口和统计</li><li>iperf :  流量检测</li><li>tcpdump :  抓包</li><li>wireshark :  图形化抓包</li><li>ss :  套接字分析</li><li>netstat :  统计网络协议和接口信息</li><li>ethtool :  统计以太网设备信息</li><li>ping :  万能的ping检测</li><li>tracerout :  跟踪路由</li><li>route :  显示路由</li></ul><h1>进程分析</h1><h2 id="进程的相关知识">进程的相关知识</h2><h2 id="进程含义">进程含义</h2><ul><li><p>运行中的程序副本(指令加数据)</p></li><li><p>理想状态下是70%CPU时间用户模式+30%CPU时间内核模式.</p></li><li><p>进程需要内存来存放自己的指令和代码，需要cpu来运行指令并完成对数据的加工，此然也需要内存把自己所输出的数据及处理的结果给保存下来等等。事实上我们运行中的进程数量是远远多余cpu核心数量的</p></li><li><p>假如只有1个cpu,他要么在执行用户代码,要么执行内核代码,不能同时执行2个</p></li><li><p>内核为了追踪每个进程,必须实现每一个进程可随时调入和调出,准备很多数据结构来保存这些数据,这个过程即为<code>任务列表</code>,每个进程都有一个task,每一个task在内核中都有一个专门的数据格式来存放相关信息,包括进程id,进程的线程,在调度上进程和线程没有区别</p></li><li><p>io过程,进程运行的过程中,需要请求的数据如果不在内存里面,就会请求内核吧数据从磁盘载入内存,从而供程序访问,io就被分成了2段,第一段是内核将磁盘数据加载到内核内存,然后再从内核内存复制到进程内存</p></li></ul><h2 id="常用命令">常用命令</h2><ul><li>大致看进程使用全部内存,包括共享内存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | awk &#x27;&#123;total +=$6&#125;END&#123;print total&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>大致看进程易用内存,比aux精确</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep Pss /proc/[1-9]*/smaps | awk &#x27;&#123;total+=$2&#125;END&#123;print total&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>cpu占用最高的10个进程,以pid排序</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k3nr | head -n 10</span><br></pre></td></tr></table></figure><ul><li>内存占用最高的10个进程,以pid排序</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k4nr | head -n 10</span><br></pre></td></tr></table></figure><ul><li>树形看进程,但不能看内核进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -axjf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree</span><br></pre></td></tr></table></figure><ul><li>查看进程下的所有线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -efL | grep &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>查看进程下有哪些线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -T -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>top/htop<ul><li>top -Hp [pid]</li><li>top 然后按P或M</li><li>top 然后按F</li></ul></li><li>vmstat n m</li><li>mpstat nm</li><li>sar工具</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -u -h -f /var/log/saxxx</span><br></pre></td></tr></table></figure><ul><li>指定命令固定在某个cpu上</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -c 3 top</span><br></pre></td></tr></table></figure><ul><li>显示进程是否固定在某个cpu上</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">taskset -c -p &lt;pid&gt;</span><br><span class="line">ps -o pid,psr,comm -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><h1>java进程占用问题思路</h1><ul><li>找出占用最高的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top 按M</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k3nr | awk &#x27;&#123;print $3 &quot;\t&quot; $11&#125;&#x27; | head -n 10</span><br></pre></td></tr></table></figure><ul><li>找出进程占用最高的线程ID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top  -Hp &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>找出cpu占用最高的线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -mp 2688 -o &quot;THREAD,tid,time&quot;</span><br></pre></td></tr></table></figure><ul><li>十进制线程号转换成十六进制线程号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%x\n&quot; &lt;tid&gt;</span><br></pre></td></tr></table></figure><ul><li>jstack找出问题代码</li></ul><p>tid(16进制西那才ID小写英文)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstack -l &lt;pid&gt;</span><br><span class="line">jstack -f &lt;pid&gt;</span><br><span class="line">jstack -l &lt;pid&gt; | grep tid -A 30</span><br></pre></td></tr></table></figure><blockquote><p>如果是java代码问题,应该找研发</p><p>如果是java虚拟机或者系统问题,应该继续查</p></blockquote><h1>其他进程占用cpu问题思路</h1><h2 id="top大法">top大法</h2><h3 id="用户态">用户态</h3><p>%us+%sy &gt; 70 ,用户态是否有可疑进程</p><h3 id="中断">中断</h3><ul><li>硬中断 hi</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -d cat <span class="regexp">/proc/i</span>nterrupts</span><br></pre></td></tr></table></figure><ul><li>软中断 si</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">watch</span> -n <span class="number">1</span> <span class="string">&quot;cat /proc/softirqs&quot;</span></span><br></pre></td></tr></table></figure><h3 id="灵异进程">灵异进程</h3><p>cpu占用很高但找不到</p><ul><li>关注<code>running</code>进程,是否有什么在不停的重启</li><li>关注<code>D</code>状态进程,不可中断的睡眠状态,该状态的进程无法kill,更不能自行退出,只能重启或恢复他依赖的资源来解决</li></ul><h2 id="uptime或w">uptime或w</h2><p>load average 越高,说明任务队列越长,处于等待的任务越多</p><h2 id="vmstat">vmstat</h2><ul><li>cs  上下文切换次数陡增或者和正常差别很大</li><li>in  中断次数较多</li><li>r  就绪队列长度一直高于最大cpu个数,考虑cpu竞争</li><li>wa  op等待cpu时间,值越大,磁盘大量做随机访问造成的,磁盘性能有瓶颈</li></ul><h2 id="pidstat">pidstat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -p &lt;pid&gt; -wt 1 10</span><br></pre></td></tr></table></figure><ul><li>Cswch/s 每秒主动任务上下文切换数量</li><li>Nvcswch/s 每秒被动任务上下文切换数量,值越大活吗进程被强制调度,就是争抢cpu,cpu时间片不足</li></ul><h2 id="sar">sar</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -q #查看近段时间cpu负载</span><br></pre></td></tr></table></figure><h2 id="判断是否是系统进程">判断是否是系统进程</h2><ul><li>U系</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S</span><br></pre></td></tr></table></figure><ul><li>R系</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf</span><br></pre></td></tr></table></figure><h2 id="显卡相关">显卡相关</h2><p>涉及到显卡硬件加速相关,有些应用可能需要用到,但可能走的是cpu软实现,并没有用到硬件</p><h2 id="是否程序不断自启动">是否程序不断自启动</h2><p>有些程序利用定时任务不断拉起服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rni &quot;进程&quot; /etc</span><br></pre></td></tr></table></figure><h2 id="对比其他机器">对比其他机器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -c top -d 1 -n 5</span><br></pre></td></tr></table></figure><h1>内存分析</h1><p>linux内存管理子系统架构<code>用户空间</code>,<code>内核空间</code>,<code>机器硬件</code></p><h2 id="查看配置">查看配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure><p>关注如下</p><ol><li>MemTotal 物理大小</li><li>MemFree 空闲</li><li>MemAvailabe 可用</li><li>Buffers 给文件做缓冲的</li><li>Cached 高速缓冲控制器</li><li>SwapCacaed</li><li>Active 活跃使用的bufferf或cache</li><li>Inactive 不经常用的大小</li><li>Slab</li><li>Sreclaimable  可回收slab</li><li>Sunreclaim 不可回收slab</li></ol><h2 id="检查现有的">检查现有的</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><p>应用可用内存~free+buffers+cached</p><p>Mem:avaiable~/proc/meminfo的MenAvailable</p><h1>smem</h1><ul><li>VSS</li></ul><p>虚拟耗用内存,包含共享库使用的内存</p><ul><li>RSS</li></ul><p>实际使用内存,包含共享库占用的,用top可以查到,最常用的内存指标,是进程占用的物理内存大小,Rss包含进程间共享的内存,所以累加起来会超出系统的内存消耗</p><ul><li>PSS</li></ul><p>所有使用某共享库的程序均分该共享库占用的内存时,每个进程占用的内存,所有进程的PSS之和就是系统的内存使用量,更精确,是将共享内存平均分摊到各个进程中的</p><ul><li>USS</li></ul><p>进程独自占用的物理内存,是PSS中自己的部分,只计算进程独自占用的</p><h2 id="常用命令-2">常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure><ul><li>实时显示内核slab缓冲区信息</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">slabtop</span></span><br></pre></td></tr></table></figure><ul><li>是否有内存限制或预留内存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cmdline</span><br></pre></td></tr></table></figure><ul><li>查看进程总内存是否正常</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | awk &#x27;&#123;total+=$6&#125;END&#123;print total/1024&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>日志分析超出内存或alloc的问题</li></ul><ol><li>dmesg</li><li>kernel.log</li><li>syslog</li></ol><ul><li>近段时间内存分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -r -h -f /var/log/sa/saxx</span><br></pre></td></tr></table></figure><ul><li>串口调试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启,引导加入console=ttyS0,115200n8</span></span><br></pre></td></tr></table></figure><h2 id="对比测试">对比测试</h2><ol><li>和centos对比</li><li>重新部署程序或和正常机器对比</li><li>换个用户排除环境变量问题</li><li>异常和正常的机器硬件,系统,bios,主板,硬盘,cpu,内存,包,是否一致</li><li>内存泄露问题,meminfo取多份对比,看看是在内核还是用户进程</li></ol><h2 id="核内内存问题">核内内存问题</h2><ol><li>MemFree和MemAvailable,定位内存消耗的方向是内核还是用户</li><li>slabtop实时观察哪个slab一直增高</li><li>对比看slab增长情况</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo  | grep -Ei &quot;slab|reclaim&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>定位具体的slab问题</li></ol><p>取多份slabinfo对比,带着/sys/kernel/slab分析</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>slabinfo</span><br></pre></td></tr></table></figure><p>如果dentry高,判断下是否进程对文件频繁读写,可以用strace分析</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -fp &lt;pid&gt; -e trace=<span class="keyword">open</span>,<span class="keyword">stat</span>,<span class="keyword">close</span>,<span class="keyword">unlink</span></span><br></pre></td></tr></table></figure><ol start="5"><li>内核问题一般是驱动问题<ol><li>lsmod对比</li><li>卸载驱动</li><li>驱动分析</li></ol></li><li>找到驱动地址</li></ol><p>可以看到函数对应的地址,通过地址找到驱动,也可以通过驱动找到地址</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/i</span>omem</span><br></pre></td></tr></table></figure><h2 id="核外内存问题">核外内存问题</h2><ol><li><p>top按M查看占用最大的</p></li><li><p>ps大法</p></li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ps</span> -aux | awk <span class="string">&#x27;&#123;total+=<span class="variable">$6</span>&#125;END&#123;print total/1024&#125;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux --<span class="built_in">sort</span> -rss | <span class="built_in">head</span></span><br></pre></td></tr></table></figure><ol start="3"><li>ps_mem</li><li>dstat</li></ol><p>动态展示进程内存占用</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat <span class="comment">--top-mem</span></span><br></pre></td></tr></table></figure><ol start="5"><li>进程内存分析</li></ol><ul><li>查看smaps</li></ul><p>smaps展示了一个进程的内存消耗</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/&lt;pid&gt;/smaps</span><br></pre></td></tr></table></figure><ul><li>内存泄露</li></ul><p>VIRT/VSZ或者writeable/private,如果在重复操作中一直问题,那么应该是内存泄露</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pmap -d &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>strace调试</li></ul><h2 id="pid是否超过限度">pid是否超过限度</h2><p><code>fork:cannot allocate memory</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | wc -l</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat  /proc/sys/kernel/pid_max</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysc &amp;&amp; echo3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><p>linux下频繁存取文件之后,物理内存会被消耗完,程序结束之后不会立即被正常释放的</p><h1>磁盘问题</h1><ul><li>磁盘整体使用情况</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -i</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/fstab</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid</span><br></pre></td></tr></table></figure><ul><li>是否开启读写缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cache</span><br></pre></td></tr></table></figure><ul><li>查看队列模式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/block/&lt;磁盘名&gt;/queue/scheduler </span><br></pre></td></tr></table></figure><ul><li>设置队列模式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &lt;队列模式&gt; &gt;&gt;  /sys/block/&lt;磁盘名&gt;/queue/scheduler </span><br><span class="line">echo  mq-deadline &gt;&gt;  /sys/block/&lt;磁盘名&gt;/queue/scheduler </span><br></pre></td></tr></table></figure><p>grub加入scsi_mod.use_blk_mq=0 elevator=deadline 修改算法</p><ul><li>查看磁盘调度算法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i scheduler</span><br></pre></td></tr></table></figure><ul><li>查看io</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x -N -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat -d</span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat -d <span class="comment">--top-io</span></span><br></pre></td></tr></table></figure><ul><li>io性能测试</li></ul><ol><li>blktrace</li><li>fio</li><li>dd</li></ol><ul><li>检测磁盘健康</li></ul><ol><li>badblocks</li><li>e2fsck</li><li>fsck</li><li>xfs_repair</li></ol><ul><li>判断磁盘类型</li></ul><p>1=HDD</p><p>0=SSD</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/sys/</span>block<span class="regexp">/&lt;磁盘名&gt;/</span>queue/rotational  </span><br></pre></td></tr></table></figure><ul><li>是否开启缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cache | grep -i read #读缓存</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cache | grep -i write #读缓存</span><br></pre></td></tr></table></figure><h2 id="磁盘分析工具">磁盘分析工具</h2><h3 id="dd">dd</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试写速率,请求直接变成io指令发到磁盘</span></span><br><span class="line">time dd if=/dev/zero of=test bs=4k count=100000 oflag=direct status=progress</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试写速率,规避cache</span></span><br><span class="line">time dd if=test  of=/dev/null bs=4k count=100000 oflag=direct status=progress</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试读速率,规避cache</span></span><br><span class="line">time dd if=/dev/xxx  of=/dev/null bs=4k count=100000 oflag=direct status=progress</span><br></pre></td></tr></table></figure><h3 id="blktrace">blktrace</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.采集信息,根据cpu个数生成文件个数,名字是&#123;device&#125;.blktrace.&#123;cpu&#125;</span></span><br><span class="line">blktrace -d /dev/sdX  [-o /tmp/sda ]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.合并信息,执行btt就要先把blktrace生成的文件合并</span></span><br><span class="line">blkparse -i sda -d sda.blkparse.bin</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.统计信息,将合并的信息分解程很多歌名字相关的文件信息</span></span><br><span class="line">btt -i sda.blkparse.bin -o sda.btt</span><br></pre></td></tr></table></figure><h2 id="磁盘检查修复工具">磁盘检查修复工具</h2><h3 id="badblocks">badblocks</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.扫描</span></span><br><span class="line">badblocks -s -v /dev/xxx</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.如果找到了坏道,可以进行写入扫描进行修复,写入扫描遇到坏道的时候自动重映射,扫描会覆盖原有数据,要备份的,写入扫描速度很低,所以应该扫描只读扫描时候发现错误的地方</span></span><br><span class="line">badblocks -w -s -v /dev/xxx [END] [START]</span><br></pre></td></tr></table></figure><h3 id="fstrim">fstrim</h3><p>回收已经挂载的文件系统未使用的块</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fstrim -av</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之pidstat</title>
      <link href="/posts/33b1a077.html"/>
      <url>/posts/33b1a077.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之iostat</title>
      <link href="/posts/84a73f90.html"/>
      <url>/posts/84a73f90.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>分析io性能</p><h1>概述</h1><p>在衡量磁盘性能时的基本指标：<code>利用率</code>、<code>饱和度</code>、<code>IOPS</code>、<code>吞吐量</code>和<code>响应时间</code></p><ol><li>利用率(Utilization):磁盘处理I/O的时间百分比,过度使用<code>(如超过 80%)</code>通常意味着磁盘I/O存在性能瓶颈</li><li>饱和度(Saturation):指磁盘处理I/O的繁忙程度,过度饱和意味着磁盘存在严重的性能瓶颈,当饱和度为100%时,磁盘无法接受新的I/O请求</li><li>IOPS(Input/Output Per Second):指每秒I/O请求的数量</li><li>吞吐量(Throughput):每秒I/O请求的大小</li><li>响应时间(Response time):指发送I/O请求和接收响应之间的间隔时间</li></ol><blockquote><p>一般面对IO问题,我们先考虑<code>是否产生了IO问题</code>,在安装系统之后一般都是要对磁盘进行一个测试的,常用的工具有<code>dd</code>,<code>fio</code>等,目的是要检验出磁盘的<code>随机读</code>、<code>顺序读</code>、<code>随机写</code>、<code>顺序写</code><br>等性能(通常是 512B ~ 1MB 之间),以判断是否能够满足应用的需求</p></blockquote><h1>命令参数</h1><p><strong>-c：</strong> 显示CPU使用情况<br><strong>-d：</strong> 显示磁盘使用情况<br><strong>-N：</strong> 显示磁盘阵列(LVM) 信息<br><strong>-n：</strong> 显示NFS 使用情况<br><strong>-k：</strong> 以 KB 为单位显示<br><strong>-m：</strong> 以 M 为单位显示<br><strong>-t：</strong> 报告每秒向终端读取和写入的字符数和CPU的信息<br><strong>-V：</strong> 显示版本信息<br><strong>-x：</strong> 显示详细信息<br><strong>-p：</strong>[磁盘] 显示磁盘和分区的情况</p><h1>多种用法简介</h1><ul><li>间隔1秒，总共显示5次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat 1 5</span><br></pre></td></tr></table></figure><ul><li>每隔2秒,显示一次设备统计信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d 2</span><br></pre></td></tr></table></figure><ul><li>每隔2秒,显示一次设备统计信息.总共输出3次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d 2 3</span><br></pre></td></tr></table></figure><ul><li>每隔2秒显示一次sda, sdb两个设备的扩展统计信息,共输出3次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x sda sdb 2 3</span><br></pre></td></tr></table></figure><ul><li>每隔2秒显示一次sda及上面所有分区的统计信息,共输出3次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -p sda 2 3</span><br></pre></td></tr></table></figure><ul><li>以M为单位显示所有信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -m</span><br></pre></td></tr></table></figure><ul><li>报告每秒向终端读取和写入的字符数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -t</span><br></pre></td></tr></table></figure><ul><li>显示指定硬盘信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d sda</span><br></pre></td></tr></table></figure><ul><li>查看TPS和吞吐量信息</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">iostat</span> -d -k <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>查看设备使用率和响应时间</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">iostat</span> -d -k <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h1>简单使用方法</h1><p>直接使用,显示所有设备负载情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat</span><br></pre></td></tr></table></figure><p>下面是输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.30    0.00    0.07    0.01    0.00   99.62</span><br><span class="line"></span><br><span class="line">Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd</span><br><span class="line">dm-0              3.40        67.65         6.81         0.00     492797      49628          0</span><br><span class="line">dm-1              0.01         0.30         0.00         0.00       2216          0          0</span><br><span class="line">sda               1.89        84.39         6.52         0.00     614737      47473          0</span><br><span class="line">sdb               0.02         0.35         0.00         0.00       2569          4          0</span><br></pre></td></tr></table></figure><ul><li>含义解释</li></ul><ol><li>%user：CPU在<code>用户模式</code>下的时间百分比</li><li>%nice：CPU在带NICE值的用户模式下的时间百分比</li><li>%system：CPU在系统模式下的时间百分比</li><li>%iowait：CPU等待输入输出完成时间的百分比</li><li>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比</li><li>%idle：CPU<code>空闲时间</code>百分比</li><li>device:磁盘名称</li><li>tps：每秒钟发送到的I/O请求数</li><li>Blk_read/s：每秒读取的block数</li><li>Blk_wrtn/s：每秒写入的block数</li><li>Blk_read：读入的block总数</li><li>Blk_wrtn：写入的block总数</li></ol><blockquote><p>%iowait的值过高，表示硬盘存在I/O瓶颈<br>%idle值高，表示CPU较空闲<br>%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量<br>%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。</p></blockquote><h1>整体磁盘I/O观察(重点)</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x -N -p</span><br></pre></td></tr></table></figure><p>iostat 是最常用的磁盘 I/O 性能观察工具。它提供了各种常用性能指标，例如每个磁盘的利用率、IOPS 和吞吐量<br>下面是<code>iostat</code>的输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">scd0              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">dm-0              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">dm-1              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br></pre></td></tr></table></figure><p>每一列都对应了之前说的<code>基本指标</code></p><ul><li><code>%util</code> 是我们前面提到的磁盘I/O使用情况,</li><li><code>r/s</code> 和 <code>w/s</code> 是 IOPS</li><li><code>rkB/s</code> 和 <code>wkB/s</code> 是吞吐量</li><li><code>r_await</code> 和 <code>w_await</code> 是响应时间</li></ul><blockquote><p>关于磁盘饱和度,可以利用<code>平均请求队列长度</code>或<code>完成读写请求的等待时间</code>与<code>基准测试（例如通过 fio）的结果</code>进行比较</p><p>从iostat无法得出磁盘的饱和度,饱和度反应的是磁盘处理io的繁忙程度,过高的饱意味着磁盘有严重的io问题,饱和度100%时候无法接受新的io请求</p></blockquote><h1>查看设备使用率,响应时间</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x 1 1</span><br></pre></td></tr></table></figure><p>以下是输出结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Device</span>            r/s     rkB/s   rrqm/s  %rrqm r_await rareq-sz     w/s     wkB/s   wrqm/s  %wrqm w_await wareq-sz     d/s     dkB/s   drqm/s  %drqm d_await dareq-sz     f/s f_await  aqu-sz  %util</span><br><span class="line"><span class="attribute">dm</span>-<span class="number">0</span>             <span class="number">1</span>.<span class="number">70</span>     <span class="number">67</span>.<span class="number">07</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">2</span>.<span class="number">90</span>    <span class="number">39</span>.<span class="number">45</span>    <span class="number">1</span>.<span class="number">68</span>      <span class="number">6</span>.<span class="number">80</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">38</span>     <span class="number">4</span>.<span class="number">04</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">01</span>   <span class="number">0</span>.<span class="number">11</span></span><br><span class="line"><span class="attribute">dm</span>-<span class="number">1</span>             <span class="number">0</span>.<span class="number">01</span>      <span class="number">0</span>.<span class="number">30</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">2</span>.<span class="number">32</span>    <span class="number">22</span>.<span class="number">85</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span></span><br><span class="line"><span class="attribute">sda</span>              <span class="number">1</span>.<span class="number">10</span>     <span class="number">83</span>.<span class="number">67</span>     <span class="number">0</span>.<span class="number">82</span>  <span class="number">42</span>.<span class="number">71</span>    <span class="number">2</span>.<span class="number">38</span>    <span class="number">76</span>.<span class="number">10</span>    <span class="number">0</span>.<span class="number">78</span>      <span class="number">6</span>.<span class="number">50</span>     <span class="number">0</span>.<span class="number">91</span>  <span class="number">53</span>.<span class="number">78</span>    <span class="number">0</span>.<span class="number">66</span>     <span class="number">8</span>.<span class="number">34</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">15</span>    <span class="number">1</span>.<span class="number">66</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">11</span></span><br><span class="line"><span class="attribute">sdb</span>              <span class="number">0</span>.<span class="number">02</span>      <span class="number">0</span>.<span class="number">35</span>     <span class="number">0</span>.<span class="number">02</span>  <span class="number">43</span>.<span class="number">12</span>   <span class="number">15</span>.<span class="number">22</span>    <span class="number">16</span>.<span class="number">79</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">8</span>.<span class="number">75</span>     <span class="number">1</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">8</span>.<span class="number">75</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">03</span></span><br></pre></td></tr></table></figure><ol><li><strong>rrqm/s:</strong>  每秒进行 merge 的读操作数目。即 rmerge/s</li><li><strong>wrqm/s:</strong>  每秒进行 merge 的写操作数目。即 wmerge/s</li><li><strong>r/s:</strong>  每秒完成的读 I/O 设备次数。即 rio/s</li><li><strong>w/s:</strong>  每秒完成的写 I/O 设备次数。即 wio/s</li><li><strong>rkB/s:</strong>  每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</li><li><strong>wkB/s:</strong>  每秒写K字节数。是 wsect/s 的一半。</li><li><strong>avgrq-sz:</strong>  平均每次设备I/O操作的数据大小 (扇区)。</li><li><strong>avgqu-sz:</strong>  平均I/O队列长度。</li><li><strong>rsec/s:</strong>  每秒读扇区数。即 rsect/s</li><li><strong>wsec/s:</strong>  每秒写扇区数。即 wsect/s</li><li>**r_await:**每个读操作平均所需的时间</li><li>不仅包括硬盘设备读操作的时间，还包括了在kernel队列中等待的时间。</li><li>**w_await:**每个写操作平均所需的时间</li><li>不仅包括硬盘设备写操作的时间，还包括了在kernel队列中等待的时间。</li><li><strong>await:</strong> 平均每次设备I/O操作的等待时间 (毫秒)。</li><li><strong>svctm:</strong> 平均每次设备I/O操作的服务时间 (毫秒)。</li><li><strong>%util:</strong>  一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</li></ol><blockquote><p>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。</p><p>如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间</p><p>如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化</p><p>如果avgqu-sz比较大，也表示有当量io在等待。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件描述符和进程数调优</title>
      <link href="/posts/b379b34f.html"/>
      <url>/posts/b379b34f.html</url>
      
        <content type="html"><![CDATA[<h1>问题描述</h1><ul><li><p>文件描述符</p><p><code>Too many open files</code>是Linux系统中常见的错误,从字面意思上看就是说程序打开的文件数过多,其实files不单是文件的意思,也包括打开的通讯链接(比如socket),正在监听的端口等等,也可以叫做句柄(handle),这个错误通常也可以叫做<code>句柄数超出系统限制</code></p></li><li><p>用户打开进程数</p><p><code>no more progres</code>或者是<code>Resource temporarily unavailable</code>,是没有更多的进程可用,产生的原因可能有</p><ol><li>用户的nproc达到限制，无法创建新的进程</li><li>系统没有可分配的的pid，即进程号已经达到内核参数kernel.pid_max的限制</li><li>系统可用内存低，新的进程无法申请到内存导致不能启动</li></ol><p>nproc是操作系统级别对每个用户创建的进程数的限制,在Linux下运行多线程时,每个线程的实现其实是一个轻量级的进程,对应的术语是:light weight process(LWP)</p></li></ul><h1>产生的原因</h1><p>Linux操作系统中利用<code>ulimit</code>限制shell启动进程占用的资源,ulimit支持对用户的<code>打开进程数</code>、<code>进程打开文件句柄数</code>、<code>进程打开文件的大小</code>、进程coredump文件`大小等资源进行限制，从而防止某个用户进程过度占用系统资源，避免影响整个操作系统和其他应用的正常运行。但是使用ulimit进行限制后，当用户资源超限制时会出现各种各样的报错</p><h1>文件描述符达到上限</h1><h2 id="修改上限file-max">修改上限file-max</h2><p>这是<code>系统级</code>参数,file-max是查看所有进程的打开文件数量的系统范围限制,即系统可打开的最大数量,但日志里面报&quot;file-max reached&quot;的时候才去修改</p><ul><li>查看file-max数值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max  </span><br></pre></td></tr></table></figure><p>file-max的值也也和下面有近似</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r MemTotal /proc/meminfo | awk &#x27;&#123;printf(&quot;%d&quot;,$2/10)&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="修改方法">修改方法</h3><ul><li>写入sysctl.conf</li></ul><p>重启生效,建议先用临时设定确定一个值之后写入配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;fs.file-max = 6553560&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><p>重启恢复默认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo  6553560 &gt; /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w &quot;fs.file-max=6553560&quot;</span><br></pre></td></tr></table></figure><h2 id="修改nr-open">修改nr_open</h2><p>这是<code>进程级</code>的参数,查看单个进程可以打开的最大文件数</p><ul><li>查看</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/nr_open   #输出1048576即是1024*1024,正好是100万</span><br></pre></td></tr></table></figure><h3 id="修改方法-2">修改方法</h3><ul><li>写入sysctl.conf</li></ul><p>重启生效,建议先用临时设定确定一个值之后写入配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;fs.nr_open=100000000&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><p>,重启恢复默认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo  100000000 &gt; /proc/sys/fs/nr_open</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><p>重启恢复默认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w &quot;fs.nr_open=100000000&quot;</span><br></pre></td></tr></table></figure><h2 id="查看file-nr">查看file-nr</h2><p>他其实就是一个统计,输出<code>当前打开的文件数</code>,<code>空闲文件句柄数量</code>,<code>文件句柄的最大数量(file-max)</code>三列值,这是一个只读文件,是拿来看资源的,不用修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-nr   #输出55040195620</span><br></pre></td></tr></table></figure><h2 id="修改limits-conf">修改limits.conf</h2><p>既可以用<code>ulimit命令</code>来修改,也可以<code>写进系统的配置文件</code></p><blockquote><p>注意</p><ol><li><p>nofile是打开最大文件数, 对应limits.conf的nofile参数,重启生效</p></li><li><p>soft要小于hard</p></li><li><p>nofile的值需要小于等于nr_open的值</p></li></ol></blockquote><ul><li>修改成如下</li></ul><p>将所有用户的对<code>文件描述符</code>的限制都改成6553500</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 6553500</span><br><span class="line">* hard nofile 6553500</span><br></pre></td></tr></table></figure><h2 id="分析系统">分析系统</h2><p>其实<code>调优</code>只是释放资源的一种手段,更重要的是找出原因,可能是业务某个时间段业务量激增,也可能是应用触发了某个bug</p><ul><li>统计各命令打开句柄数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure><ul><li>统计各进程打开句柄数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &#x27;&#123;print $2&#125;&#x27; | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure><ul><li>统计各用户打开句柄数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &#x27;&#123;print $3&#125;&#x27; | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure><h2 id="复现方法">复现方法</h2><p>将我们的资源临时改成<code>6</code>,此时类似<code>top</code>或者<code>lsof</code>等命令就已经不能用了,因为他们产生的句柄会很多,而我们只限制只能打开<code>6</code></p><ul><li>临时修改nofile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 6</span><br></pre></td></tr></table></figure><ul><li>随便输入某些命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><ul><li>触发报错</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span>: failed <span class="attribute">openproc</span>: Too many open files</span><br></pre></td></tr></table></figure><h1>用户最大进程数量达到上限</h1><p>在rhel6和7上面,这个参数默认对root没有限制,他是从内核继承的,对于其他用户来说就4096,是根据下面的文件设定的</p><ul><li>CentOS6中limits.d下面是90-nproc.conf</li><li>CentOS7中limits.d下面是20-nproc.conf</li></ul><h2 id="如何查看">如何查看</h2><ul><li>查看所有用户创建的进程数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps h -Led -o user | sort | uniq -c | sort -n</span><br></pre></td></tr></table></figure><ul><li>指定某个用户查看创建的进程数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o nlwp,pid,lwp,args -u root | sort -n</span><br></pre></td></tr></table></figure><h2 id="修改xx-nproc-conf文件">修改xx-nproc.conf文件</h2><p>将第一行的nproc的值放大,我一般是改成4096,如果还不够继续放大</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*          soft    nproc     1024</span><br><span class="line">root       soft    nproc     unlimite</span><br></pre></td></tr></table></figure><h2 id="如何生效">如何生效</h2><p>有2种方法如下,任选其中之一</p><ul><li>本地注销桌面或者退出终端重新登陆</li><li>重启最好</li></ul><h2 id="验证结果">验证结果</h2><h3 id="对于bash用户">对于bash用户</h3><ul><li>查看方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><p>修改的是<code>nproc</code>参数,对应<code>max user processes</code>字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">real-time non-blocking time  (microseconds, -R) unlimited</span><br><span class="line">core file size              (blocks, -c) unlimited</span><br><span class="line">data seg size               (kbytes, -d) unlimited</span><br><span class="line">scheduling priority                 (-e) 0</span><br><span class="line">file size                   (blocks, -f) unlimited</span><br><span class="line">pending signals                     (-i) 61604</span><br><span class="line">max locked memory           (kbytes, -l) 64</span><br><span class="line">max memory size             (kbytes, -m) unlimited</span><br><span class="line">open files                          (-n) 65535</span><br><span class="line">pipe size                (512 bytes, -p) 8</span><br><span class="line">POSIX message queues         (bytes, -q) 819200</span><br><span class="line">real-time priority                  (-r) 0</span><br><span class="line">stack size                  (kbytes, -s) 8192</span><br><span class="line">cpu time                   (seconds, -t) unlimited</span><br><span class="line">max user processes                  (-u) 61604</span><br><span class="line">virtual memory              (kbytes, -v) unlimited</span><br><span class="line">file locks                          (-x) unlimited</span><br></pre></td></tr></table></figure><h3 id="对于tcsh用户">对于tcsh用户</h3><ul><li>查看方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><p>修改的是<code>nproc</code>参数,对应<code>maxproc</code>字段</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cputime</span>      unlimited</span><br><span class="line"><span class="attribute">filesize</span>     unlimited</span><br><span class="line"><span class="attribute">datasize</span>     unlimited</span><br><span class="line"><span class="attribute">stacksize</span>    <span class="number">8192</span> kbytes</span><br><span class="line"><span class="attribute">coredumpsize</span> unlimited</span><br><span class="line"><span class="attribute">memoryuse</span>    unlimited</span><br><span class="line"><span class="attribute">vmemoryuse</span>   unlimited</span><br><span class="line"><span class="attribute">descriptors</span>  <span class="number">65535</span> </span><br><span class="line"><span class="attribute">memorylocked</span> <span class="number">64</span> kbytes</span><br><span class="line"><span class="attribute">maxproc</span>      <span class="number">61604</span> </span><br><span class="line"><span class="attribute">maxlocks</span>     unlimited</span><br><span class="line"><span class="attribute">maxsignal</span>    <span class="number">61604</span> </span><br><span class="line"><span class="attribute">maxmessage</span>   <span class="number">819200</span> </span><br><span class="line"><span class="attribute">maxnice</span>      <span class="number">0</span> </span><br><span class="line"><span class="attribute">maxrtprio</span>    <span class="number">0</span> </span><br><span class="line"><span class="attribute">maxrttime</span>    unlimited</span><br></pre></td></tr></table></figure><h2 id="复现方法-2">复现方法</h2><ul><li>将普通用户的nproc临时修改</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ulimit</span> -u  <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>简单写个test.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        pid=fork();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count= %d\n&quot;</span>,count);&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="keyword">test</span>.c -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><ul><li>执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure><ul><li>报错</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: fork: retry: 资源暂时不可用</span><br></pre></td></tr></table></figure><h1>想法</h1><ul><li><p>[x] <code>limits.conf和xx-nproc.conf都支持修改</code>nproc<code>,为什么就改xx-nproc.conf? </code>因为/etc/security/limits.d/里面的文件里面的配置会覆盖/etc/security/limits.conf的配置</p></li><li><p>[x] <code>顺序</code>?soft&lt;hard&lt;nr_open&lt;file-max</p></li><li><p>[ ] <code>文件描述符的上限在哪?</code></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for  V in `seq  100000  10000000` ; do ulimit -n $V ; [[ $? != 0 ]] &amp;&amp; break;done</span><br></pre></td></tr></table></figure><ul><li><p>[x] <code>lsof是否可以用来排查这俩个报错?</code>lsof可以看打开的文件数量,用ps看进程数量</p></li><li><p>[x] <code>file-max的上限在哪里呢?</code>只要你的内存足够大，file-max的值可以非常大(大概这么说)</p></li><li><p>[x] <code>nproc的最大是在哪里?</code></p></li></ul><p>这个数字在centos8(不包括8)是和配置显示一致的,在8之后由内核决定,通过下面的命令,可以计算出我们可以配置的最大的nproc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(($(cat /proc/sys/kernel/threads-max)/2))</span><br></pre></td></tr></table></figure><ul><li>[x] 之前一直拿root做实验,其实得用普通用户来验证所有的效果,就比如nproc,root和普通用户看到是不一样的,明显默认root就会多一点,而普通用户是根据配置来的</li></ul><h1>推荐阅读</h1><ol><li><a href="https://xie.infoq.cn/article/30eeb766ecfac245cc96c45c6">https://xie.infoq.cn/article/30eeb766ecfac245cc96c45c6</a></li><li><a href="https://www.cnblogs.com/Chary/p/15842219.html">https://www.cnblogs.com/Chary/p/15842219.html</a></li><li><a href="https://blog.csdn.net/cnbird2008/article/details/8666620">https://blog.csdn.net/cnbird2008/article/details/8666620</a></li><li><a href="https://elixir.bootlin.com/linux/latest/source">linux内核代码</a></li><li><a href="https://elixir.bootlin.com/linux/v5.10.143/source/kernel/fork.c#L2523">kernel/forc.c,内核定义的nproc最大值,810行左右</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防止误删的操作</title>
      <link href="/posts/e27212c1.html"/>
      <url>/posts/e27212c1.html</url>
      
        <content type="html"><![CDATA[<h1>rm -rf /*</h1><p>众所周知,这是一条执行了就很难挽回的命令,如果在生产环境执行了这条命令,那基本很难救回数据了</p><h1>小技巧</h1><ul><li>新建一个垃圾桶</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir  ~/.trash</span><br></pre></td></tr></table></figure><ul><li>修改环境变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim   ~/.bashrc</span><br></pre></td></tr></table></figure><ul><li>添加一下内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alias rm=del   #使用别名del代替rm   </span><br><span class="line">del()                #函数del，作用：将rm命令修改为mv命令</span><br><span class="line">&#123;  </span><br><span class="line">  mv $@ ~/.trash/  </span><br><span class="line">&#125;  </span><br><span class="line">cleardel()          #函数cleardel，作用：清空回收站.trash文件夹，y或Y表示确认，n表示取消</span><br><span class="line">&#123;  </span><br><span class="line">    read -p &quot;clear sure?[Input &#x27;y&#x27; or &#x27;Y&#x27; to confirm. &amp;&amp; Input &#x27;n&#x27; to cancel.]&quot; confirm   </span><br><span class="line">    [ $confirm == &#x27;y&#x27; ] || [ $confirm == &#x27;Y&#x27; ]  &amp;&amp; /bin/rm -rf ~/.trash/*   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li>更新环境变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h1>原理</h1><p>实际上就是将<code>rm</code>这个命令指向我们自己定义的<code>del</code>命令,而<code>del</code>命令会将我们所有的参数都<code>mv</code>移动到<code>~/.trash</code>目录下,这样当我们误执行rm的时候,实际上只是将文件移动了路径,然后我们在配置一个<code>定时任务</code>,定期清理这个<code>垃圾桶</code>就可以了</p><h1>缺陷</h1><ol><li>由于数据都是mv到家目录的,所以家目录的占用会越来越大,如果不定期清理,可能会导致其他问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 防止误删 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看centos系统引导方式</title>
      <link href="/posts/b5cf572b.html"/>
      <url>/posts/b5cf572b.html</url>
      
        <content type="html"><![CDATA[<h1>运行以下命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -d /sys/firmware/efi ] &amp;&amp; echo UEFI || echo BIOS</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git拉取总是需要密码</title>
      <link href="/posts/e07e5f84.html"/>
      <url>/posts/e07e5f84.html</url>
      
        <content type="html"><![CDATA[<h1>解决办法</h1><ul><li>先在本地git仓库下执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><ul><li>然后拉取</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><ul><li>此时他会提示输入密码,完成验证之后就可以了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mdadm制作raid测试</title>
      <link href="/posts/e6331d74.html"/>
      <url>/posts/e6331d74.html</url>
      
        <content type="html"><![CDATA[<h1>mdadm</h1><p>Linux内核中有一个md(multiple devices)模块在底层管理RAID设备，它会在应用层给我们提供一个应用程序的工具mdadm ，mdadm是linux下用于创建和管理软件RAID的命令</p><h1>参数</h1><p>-a检测设备名称或添加磁盘<br>-n指定设备数量<br>-l指定RAID级别<br>-C创建<br>-v显示过程<br>-f模拟设备损坏<br>-r移除设备<br>-Q查看摘要信息<br>-D查看详细信息<br>-S停止RAID磁盘阵列</p><h1>搭建raid10</h1><h2 id="准备">准备</h2><ul><li>硬件准备<br>使用虚拟机增加2块5G的虚拟磁盘,然后开机</li><li>软件准备<br>安装mdadm命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mdadm</span><br></pre></td></tr></table></figure><h2 id="创建阵列">创建阵列</h2><p>利用mdadm创建raid,名字是<code>md1</code>的,raid模式是<code>主备</code>的,硬盘块数是<code>2</code>,使用sdb,sdc两块磁盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -C -v /dev/md1 -l 1 -n 2 /dev/sd&#123;b,c&#125;</span><br></pre></td></tr></table></figure><h2 id="查看raid">查看raid</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -D /dev/md1</span><br></pre></td></tr></table></figure><h2 id="格式化">格式化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/md1</span><br></pre></td></tr></table></figure><h2 id="挂载设备">挂载设备</h2><blockquote><p>永久挂载的话就是写入fstab里面</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/md1 /raid-test</span><br></pre></td></tr></table></figure><h2 id="写入配置文件">写入配置文件</h2><blockquote><p>说明</p><ol><li>/etc/mdadm.conf作为默认的配置文件，方便跟踪软RAID的配置，尤其是可以配置监视和事件上报选项。</li><li>–scan只能扫描配置里写的盘符,没有配置在配置文件中的RAID不能组装起来</li><li>DEVICE中配置的是组装RAID时，所有要扫描的磁盘，如RAID中的成员盘没有配置到DEVICE项中，则该磁盘无法组装到RAID中</li></ol></blockquote><ul><li>将盘符纳入磁盘</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo DEVICE /dev/sd[b-i] &gt; /etc/mdadm.conf</span><br></pre></td></tr></table></figure><ul><li>配置软raid信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm --detail --scan &gt;&gt; /etc/mdadm.conf</span><br></pre></td></tr></table></figure><ul><li>组装raid</li></ul><blockquote><p>强制组装–force</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -A --scan</span><br></pre></td></tr></table></figure><h1>模拟故障</h1><h2 id="模拟损坏磁盘">模拟损坏磁盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm /dev/md1 -f /dev/sdb</span><br></pre></td></tr></table></figure><h2 id="查看损坏详情">查看损坏详情</h2><blockquote><p>在状态栏可以看到faulty  /dev/sdb等字样</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -D /dev/md1</span><br></pre></td></tr></table></figure><blockquote><p>[UU]这块很复杂</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/mdstat</span><br></pre></td></tr></table></figure><h2 id="移除损坏盘">移除损坏盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm /dev/md1 -r /dev/sdb</span><br></pre></td></tr></table></figure><h2 id="恢复">恢复</h2><ul><li>给raid1加入新磁盘</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm /dev/md1 -a /dev/sdd</span><br></pre></td></tr></table></figure><ul><li>查看raid状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -D /dev/md1</span><br></pre></td></tr></table></figure><ul><li>查看进度条</li></ul><blockquote><p>这块如果不修改参数,速度会很慢的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 cat /proc/mdstat</span><br></pre></td></tr></table></figure><h1>软raid提速参数</h1><h2 id="坏盘恢复同步提速参数">坏盘恢复同步提速参数</h2><p>此参数会提高同步时硬盘的速度,相当于解封限制,更快同步,但是会影响系统</p><ul><li>内核参数<br>修改<code>/etc/sysctl.conf</code>,加入</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dev.raid.speed_limit_min = 500000</span><br><span class="line">dev.raid.speed_limit_max = 900000</span><br></pre></td></tr></table></figure><ul><li>生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安装部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置bond-network</title>
      <link href="/posts/7a4729e2.html"/>
      <url>/posts/7a4729e2.html</url>
      
        <content type="html"><![CDATA[<h1>声明</h1><p>本文章适用于centos6和centos7使用network配置静态ip、dhcp、bond三种网络模式</p><h1>名词解释</h1><h2 id="bond">bond</h2><p>就是把多个物理网卡绑定成一个逻辑上的网卡，使用同一个IP工作，在增加带宽的同时也可以提高冗余性，一般使用较多的就是来提高冗余，分别和不同交换机相连，提高可靠性，但有时服务器带宽不够了也可以用作增加带宽。</p><h2 id="网卡bond的模式">网卡bond的模式</h2><p>网卡绑定mode共有七种(0~6)模式</p><ul><li>mode=0:平衡负载模式<br>传输数据包顺序是依次传输（即：第1个包走eth0，下一个包就走eth1….一直循环下去，直到最后一个传输完毕,一个连接的数据包从不同的接口发出的话，中途再经过不同的链路，在客户端很有可能会出现数据包无序到达的问题，而无序到达的数据包需要重新要求被发送</li><li>mode=1:主-备份策略<br>bond1为主备模式，只有一个网卡在使用中。优点就是很安全，两块网卡同时坏的概率很低。缺点则是利用率低下，只有50%的利用率。</li><li>mode=2:平衡策略<br>基于指定的传输HASH策略传输数据包</li><li>mode=3:广播策略<br>在每个slave接口上传输每个数据包</li><li>mode=4:动态链接聚合<br>创建一个聚合组，它们共享同样的速率和双工设定。相当于两块小网卡合并一起当作一个大网卡用，类似1+1=2</li><li>mode=5:适配器传输负载均衡<br>不需要交换机支持的通道bonding。在每个slave上根据当前的负载（根据速度计算）分配外出流量。如果正在接受数据的slave出故障了，另一个slave接管失败的slave的MAC地址</li><li>mode=6:平衡负载模式<br>该模式包含了上一个模式，同时加上针对IPV4流量的接收负载均衡，而且不需要任何交换机的支持。接收负载均衡是通过ARP协商实现的。bonding驱动截获本机发送的ARP应答，并把源硬件地址改写为bond中某个slave的唯一硬件地址，从而使得不同的对端使用不同的硬件地址进行通信</li></ul><h1>配置bond</h1><blockquote><p>文件目录/etc/sysconfig/network-scripts/<br>如果ifcfg-bond0没有就创建一个</p></blockquote><h2 id="修改配置文件">修改配置文件</h2><ul><li>bond0虚拟网卡</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=bond0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">USERCTL=no</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">IPADDR=190.1.1.1</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=190.1.1.254</span><br><span class="line">BONDING_OPTS=&quot;mode=1 miimon=100&quot;</span><br></pre></td></tr></table></figure><ul><li>eth0网卡</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line">NAME=eth0</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">USERCTL=no</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPV6INIT=no</span><br><span class="line">SLAVE=yes</span><br><span class="line">MASTER=bond0</span><br></pre></td></tr></table></figure><ul><li>eth1网卡</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth1</span><br><span class="line">NAME=eth1</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">USERCTL=no</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPV6INIT=no</span><br><span class="line">SLAVE=yes</span><br><span class="line">MASTER=bond0</span><br></pre></td></tr></table></figure><h2 id="启动网卡">启动网卡</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifup bond0</span><br></pre></td></tr></table></figure><h2 id="查看bond状态">查看bond状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/net/bonding/bond0</span><br></pre></td></tr></table></figure><ul><li>输出如下</li></ul><blockquote><p>Bonding Mode: fault-tolerance (active-backup)就是主备模式</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)</span><br><span class="line"></span><br><span class="line">Bonding Mode: fault-tolerance (active-backup)</span><br><span class="line">Primary Slave: None</span><br><span class="line">Currently Active Slave: ens34</span><br><span class="line">MII Status: up</span><br><span class="line">MII Polling Interval (ms): 100</span><br><span class="line">Up Delay (ms): 0</span><br><span class="line">Down Delay (ms): 0</span><br><span class="line"></span><br><span class="line">Slave Interface: ens33</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: 1000 Mbps</span><br><span class="line">Duplex: full</span><br><span class="line">Link Failure Count: 0</span><br><span class="line">Permanent HW addr: 00:0c:29:fe:d5:e1</span><br><span class="line">Slave queue ID: 0</span><br><span class="line"></span><br><span class="line">Slave Interface: ens34</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: 1000 Mbps</span><br><span class="line">Duplex: full</span><br><span class="line">Link Failure Count: 0</span><br><span class="line">Permanent HW addr: 00:0c:29:fe:d5:eb</span><br><span class="line">Slave queue ID: 0</span><br></pre></td></tr></table></figure><h2 id="修改bond模式">修改bond模式</h2><h2 id="修改配置">修改配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-bond0</span><br></pre></td></tr></table></figure><p>将<code>BONDING_OPTS</code>里面<code>mode=1</code>改成<code>mode=3</code></p><h2 id="删除bonding驱动">删除bonding驱动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmmod bonding</span><br></pre></td></tr></table></figure><h2 id="重启网络">重启网络</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifup bond0</span><br></pre></td></tr></table></figure><h1>配置dhcp模式</h1><h2 id="修改配置文件-2">修改配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure><p>将内容改成如下,其中BOOTPROTO指定获取ip方式为dhcp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">NAME=eth0</span><br><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure><h2 id="获取ip">获取ip</h2><p>将网线查到可以dhcp的网口上使用ifup打开网卡获取ip</p><h1>配置静态ip</h1><h2 id="修改配置文件-3">修改配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure><p>将内容改成如下,其中BOOTPROTO指定获取ip方式为none或者static，填入ip、子网掩码、网关等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NAME=eth0</span><br><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">USERCTL=no</span><br><span class="line">IPV6INIT=no</span><br><span class="line">IPADDR=192.168.10.20</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">NM_CONTROLLED=no</span><br></pre></td></tr></table></figure><h2 id="获取ip-2">获取ip</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifup eth0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之nmcli</title>
      <link href="/posts/6ad86d1e.html"/>
      <url>/posts/6ad86d1e.html</url>
      
        <content type="html"><![CDATA[<h1>NetworkManager</h1><ol><li>NetworkManager服务是管理和监控网络设置的守护进程,Centos7之前的版本都是通过network.service管理网络配置</li><li>到了Centos7就同时支持network.service和NetworkManager.service</li><li>在RHEL 8/Centos 8上已废弃network.service（默认不安装）,只能通过NetworkManager进行网络配置。</li><li>NetworkManager主要管理2个对象 <code>Connection</code>（网卡连接配置） 和 <code>Device</code>（网卡设备）,他们之间是多对一的关系,但是同一时刻只能有一个Connection对于Device才生效</li></ol><h1>启动方法</h1><p>启动+开机自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now NetworkManager</span><br></pre></td></tr></table></figure><h1>三种方法配置网络</h1><ol><li>通过nmcli connection add命令配置,会自动生成ifcfg文件</li><li>手动配置ifcfg文件,通过nmcli connection reload来加载生效</li><li>手动配置ifcfg文件,通过传统network.service来加载生效</li></ol><h1>nmcli基操</h1><p>NetworkManager在系统中的管理工具为nmcli,这个命令<code>嘎嘎好用</code></p><h2 id="查看所有连接">查看所有连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show </span><br></pre></td></tr></table></figure><h2 id="查看所有激活的连接">查看所有激活的连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show --active</span><br></pre></td></tr></table></figure><h2 id="查看指定的网口的连接">查看指定的网口的连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show eth0</span><br></pre></td></tr></table></figure><h2 id="关闭连接">关闭连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection down eth0</span><br></pre></td></tr></table></figure><h2 id="启用连接">启用连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up eth0</span><br></pre></td></tr></table></figure><h1>nmcli配置网络实例-dhcp</h1><h2 id="新增连接">新增连接</h2><ul><li>创建一个连接名<code>dachui</code>,使用ens33设备</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui type Ethernet ifname ens33</span><br></pre></td></tr></table></figure><h2 id="展示创建后的效果">展示创建后的效果</h2><p>(实在不想配图)<br>可以看出只有一个行<code>NAME</code>是ens33是激活的(因为激活的连接在终端显示绿色,或者用–active可以看出来)</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME    UUID                                  TYPE      DEVICE </span><br><span class="line">ens33   c96bc909-188e-ec64-3a96-6a90982b08ad  ethernet  ens33  </span><br><span class="line">dachui  4b27c0d3-17d5-434b-90d1-5ac57a0f6147  ethernet  --     </span><br><span class="line">ens34   94aea789-efb3-ef4c-81b0-e8b18ecc9797  ethernet  -- </span><br></pre></td></tr></table></figure><h2 id="查看dachui的配置">查看<code>dachui</code>的配置</h2><p>如果不加<code>grep</code>,他会显示很多信息,但我们只需要关注ipv4的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show dachui | grep ipv4</span><br></pre></td></tr></table></figure><h2 id="配置展示">配置展示</h2><p>可以看出第一行<code>ipv4.method</code>的是<code>auto</code>,他代表<code>dachui</code>这个连接是用<code>dhcp</code>的方式获取ip的</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ipv4.method:                            auto</span><br><span class="line">ipv4.dns:                               --</span><br><span class="line">ipv4.dns-search:                        --</span><br><span class="line">ipv4.dns-options:                       &quot;&quot;</span><br><span class="line">ipv4.dns-priority:                      0</span><br><span class="line">ipv4.addresses:                         --</span><br><span class="line">ipv4.gateway:                           --</span><br><span class="line">ipv4.routes:                            --</span><br><span class="line">ipv4.route-metric:                      -1</span><br><span class="line">ipv4.route-table:                       0 (unspec)</span><br><span class="line">ipv4.routing-rules:                     --</span><br><span class="line">ipv4.ignore-auto-routes:                否</span><br><span class="line">ipv4.ignore-auto-dns:                   否</span><br><span class="line">ipv4.dhcp-client-id:                    --</span><br><span class="line">ipv4.dhcp-timeout:                      0 (default)</span><br><span class="line">ipv4.dhcp-send-hostname:                是</span><br><span class="line">ipv4.dhcp-hostname:                     --</span><br><span class="line">ipv4.dhcp-fqdn:                         --</span><br><span class="line">ipv4.never-default:                     否</span><br><span class="line">ipv4.may-fail:                          是</span><br><span class="line">ipv4.dad-timeout:                       -1 (default)</span><br></pre></td></tr></table></figure><h2 id="激活dhcp">激活dhcp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con show ens33 | grep IP4</span><br></pre></td></tr></table></figure><ul><li>激活的结果<br>可以看出这边ipv4的地址已经自动获取了</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP4.ADDRESS[1]:                         192.168.42.135/24</span><br><span class="line">IP4.GATEWAY:                            192.168.42.2</span><br><span class="line">IP4.ROUTE[1]:                           dst = 0.0.0.0/0, nh = 192.168.42.2, mt = 102</span><br><span class="line">IP4.ROUTE[2]:                           dst = 192.168.42.0/24, nh = 0.0.0.0, mt = 102</span><br><span class="line">IP4.DNS[1]:                             192.168.42.2</span><br><span class="line">IP4.DOMAIN[1]:                          localdomain</span><br></pre></td></tr></table></figure><h1>nmcli配置网络实例-static</h1><p>刚才是展示的新增一个连接,使用默认的<code>dhcp</code>方式配置网络,但实际项目中需要使用静态ip的方式,配置静态的手段有很多,可以对现在有<code>连接</code>进行系iu改,也可以再创建一个<code>连接</code>并且同时指定他的ip地址</p><h2 id="一次性创建">一次性创建</h2><p>乍一看命令<code>嘎嘎</code>长,其实很简单</p><ul><li><code>嘎嘎</code>长的命令,其实可以更长</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui-static type ethernet ifname ens33 ipv4.method manual ipv4.address 192.168.42.5/24 ipv4.gateway 192.168.42.2</span><br></pre></td></tr></table></figure><blockquote><p>我拆开两部分分析</p></blockquote><ol><li>创建连接,指定模式<br>这边就是创建了<code>dahcui-static</code>的连接,使用<code>type</code>指定此连接为<code>ethernet</code>(以太网),并且设备是<code>ens33</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui-static type ethernet ifname ens33</span><br></pre></td></tr></table></figure><ol start="2"><li>配置网络要素<br>一个ip地址至少需要指定一个<code>ip</code>和<code>子网掩码</code>才可以生效,网关也是需要配置的,还有指定是手动</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ipv4</span>.method manual ipv4.address <span class="number">192.168.42.5</span>/<span class="number">24</span> ipv4.gateway <span class="number">192.168.42.2</span></span><br></pre></td></tr></table></figure><ul><li>激活连接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static | grep IP4</span><br></pre></td></tr></table></figure><blockquote><p>输出为下面的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP4.ADDRESS[1]:                         192.168.42.5/24</span><br><span class="line">IP4.GATEWAY:                            192.168.42.2</span><br><span class="line">IP4.ROUTE[1]:                           dst = 0.0.0.0/0, nh = 192.168.42.2, mt = 102</span><br><span class="line">IP4.ROUTE[2]:                           dst = 192.168.42.0/24, nh = 0.0.0.0, mt = 102</span><br><span class="line">IP4.DNS[1]:                             192.168.42.2</span><br><span class="line">IP4.DOMAIN[1]:                          localdomain</span><br></pre></td></tr></table></figure><h2 id="编辑连接">编辑连接</h2><p>如果之前是创建好了多个连接,但是需要修改,可以通过modify的方法</p><ul><li>提示一点<br>如果要修改,请看好原先的<code>连接</code>是<code>自动获取</code>还是<code>手动获取</code>,如果是自动,需要改模式</li></ul><blockquote><p>可以一并加入修改的,我只是拆开提示一下,遇到过一次改了半天没生效,一看连接方式是dhcp</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static ipv4.method manual </span><br></pre></td></tr></table></figure><ul><li>修改ip<br>也可以修改其他的,在输入<code>dachui-static</code>之后按<code>tap</code>会列举出所有的<code>配置项</code>,然后根据语法修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static ipv4.address 192.168.42.200/24</span><br></pre></td></tr></table></figure><ul><li>重启网卡<br>修改之后需要激活一下才能生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static</span><br></pre></td></tr></table></figure><blockquote><p>这样一个基本的nmlci创建连接就结束了</p></blockquote><h1>其他基操</h1><h2 id="增加路由">增加路由</h2><p>内网环境下,机器可能有多个网段,那么加路由肯定是必须的,比如我这需要访问<code>10.10.10.0/24</code>的机器,那么通过如下方法进行配置</p><ul><li>加路由</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static +ipv4.routes &quot;10.10.10.0/24 192.168.42.2&quot;</span><br></pre></td></tr></table></figure><ul><li>激活看信息</li></ul><ol><li>配置信息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP4.ROUTE[5]:                           dst = 10.10.10.0/24, nh = 192.168.42.2, mt = 102</span><br></pre></td></tr></table></figure><ol start="2"><li>路由信息</li></ol><ul><li>route展示</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><ul><li>输出结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.42.2    0.0.0.0         UG    102    0        0 ens33</span><br><span class="line">10.10.10.0      192.168.42.2    255.255.255.0   UG    102    0        0 ens33</span><br></pre></td></tr></table></figure><h2 id="删除路由">删除路由</h2><p>学会增加,也要学会删除</p><ul><li><code>乍一看</code>是不是一样的?其实将<code>+</code>改成<code>-</code>,然后<code>重新激活</code>就可以了</li></ul><blockquote><p>所以修改的逻辑很简单的,<code>+</code>就增加,<code>-</code>就是删除,<code>什么都不加</code>就是修改</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static -ipv4.routes &quot;10.10.10.0/24 192.168.42.2&quot;</span><br></pre></td></tr></table></figure><h2 id="增加ip">增加ip</h2><p>有时候需要在一个连接上加多个ip地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static +ipv4.addresses 2.2.2.2/16</span><br></pre></td></tr></table></figure><h2 id="删除连接">删除连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection delete dachui-static</span><br></pre></td></tr></table></figure><h2 id="网卡开机自启动">网卡开机自启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static autoconnect yes</span><br></pre></td></tr></table></figure><h1>nmtui</h1><p>其实nmcli的玩法有很多,但其实还有一个工具<code>nmtui</code>,他是<code>NetworkManager-tui</code>的一个工具,通过字符图形化配置网络</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之top</title>
      <link href="/posts/5285e72b.html"/>
      <url>/posts/5285e72b.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>top命令的功能是用于实时显示系统运行状态，包含处理器、内存、服务、进程等重要资源信息</p><h1>语法格式</h1><p>top [参数]</p><h1>用法</h1><h2 id="基本用法">基本用法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><h2 id="指定刷新时间">指定刷新时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -d 1</span><br></pre></td></tr></table></figure><h2 id="显示进程的命令行参数">显示进程的命令行参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -c</span><br></pre></td></tr></table></figure><h2 id="监视指定进程">监视指定进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 5201 -p 54231</span><br></pre></td></tr></table></figure><h2 id="显示指定用户">显示指定用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -u root</span><br></pre></td></tr></table></figure><blockquote><p>我的top输出</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 23:15:06 up 21 min,  3 users,  load average: 1.19, 0.72, 0.32</span><br><span class="line">Tasks: 191 total,   3 running, 144 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  1.5 us,  3.0 sy,  0.0 ni, 95.0 <span class="built_in">id</span>,  0.0 wa,  0.5 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  4009048 total,  2791500 free,   493780 used,   723768 buff/cache</span><br><span class="line">KiB Swap:   839676 total,   839676 free,        0 used.  3218592 avail Mem </span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                        </span><br><span class="line">8671 root      20   0  511852 105736  43568 S   4.0  2.6   0:04.58 X                                                                                              </span><br><span class="line">9872 root      20   0  702884  46780  35292 S   2.0  1.2   0:00.81 mate-terminal                                                                                        </span><br></pre></td></tr></table></figure><h1>top的交互功能</h1><ul><li>在top基本视图中，敲击c键，可以显示进程的路径</li><li>在top基本视图中，敲击k键，可以在不退出top命令的情况下杀死某个正在运行的进程</li><li>在top基本视图中，敲击1键，可监控每个逻辑CPU的状况</li><li>在top基本视图中，敲击上下键，可以增减显示的进程数目</li></ul><h1>top输出解释</h1><h2 id="第一行-基本信息">第一行-基本信息</h2><h3 id="系统当前时间">系统当前时间</h3><p>top - 23:15:06</p><h3 id="系统运行时间">系统运行时间</h3><p>up 21 min</p><h3 id="当前登录用户数量">当前登录用户数量</h3><p>3 users</p><h3 id="负载均衡情况">负载均衡情况</h3><p>load average: 1.19, 0.72, 0.32<br>三个数分别是1分钟、5分钟、15分钟的负载情况</p><blockquote><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以<code>逻辑CPU</code>的数量，结果高于5的时候就表明系统在超负荷运转了</p></blockquote><h2 id="第二行-进程">第二行-进程</h2><h3 id="总进程">总进程</h3><p>Tasks: 191 total</p><h3 id="当前运行进程数量">当前运行进程数量</h3><p>3 running</p><h3 id="休眠进程数量">休眠进程数量</h3><p>144 sleeping</p><h3 id="停止进程数量">停止进程数量</h3><p>0 stopped,</p><h3 id="僵尸进程数量">僵尸进程数量</h3><p>0 zombie</p><blockquote><p>在unix/linux中，正常情况下,子进程是通过父进程创建的,子进程在创建新的进程,子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束.当一个进程完成它的工作终止之后,它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态</p></blockquote><ul><li>孤儿进程<br>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li><li>僵尸进程<br>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</li></ul><h2 id="第三行-cpu状态">第三行-cpu状态</h2><h3 id="us">us</h3><p>用户空间占用CPU的百分比</p><h3 id="sy">sy</h3><p>内核空间占用CPU的百分比</p><h3 id="ni">ni</h3><p>改变过优先级的进程占用CPU的百分比</p><h3 id="id">id</h3><p>空闲CPU百分比</p><h3 id="wa">wa</h3><p>IO等待占用CPU的百分比</p><h3 id="hi">hi</h3><p>硬中断占用CPU的百分比</p><h3 id="si">si</h3><p>软中断占用CPU的百分比</p><h3 id="st">st</h3><p>当Linux系统是在虚拟机中运行时，等待CPU资源的时间占比</p><blockquote><p>简单说，Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p></blockquote><ul><li>Kernel space<br>用户空间可以执行任意命令，调用系统的一切资源；</li><li>User space<br>内核空间只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令</li></ul><h2 id="第四行-内存状态">第四行-内存状态</h2><h3 id="total">total</h3><p>总内存量4009048</p><h3 id="free">free</h3><p>空闲内存2791500</p><h3 id="used">used</h3><p>已用内存493780</p><h3 id="buff-cache">buff/cache</h3><p>缓存内存723768</p><blockquote><p>KiB Mem：Kib表示描述单位，MEM表示内存</p></blockquote><h2 id="第五行-swap状态">第五行-swap状态</h2><h3 id="total-2">total</h3><p>总内存量839676</p><h3 id="free-2">free</h3><p>空闲内存839676</p><h3 id="used-2">used</h3><p>已用内存0</p><h3 id="avail-Mem">avail Mem</h3><p>可用内存3218592</p><ul><li>free 是真正尚未被使用的物理内存数量。</li><li>available 是应用程序认为可用内存数量，available = free + buffer + cache (注：只是大概的计算方法)</li></ul><h2 id="第六行-进程监控">第六行-进程监控</h2><ul><li>PID — 进程id</li><li>USER — 进程所有者</li><li>PR — 进程优先级</li><li>NI — nice值。负值表示高优先级，正值表示低优先级</li><li>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li><li>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li><li>SHR — 共享内存大小，单位kb</li><li>S — 进程状态。D=不可中断的睡眠状态；R=运行；S=睡眠；T=跟踪/停止；Z=僵尸进程</li><li>%CPU — 上次更新到现在的CPU时间占用百分比</li><li>%MEM — 进程使用的物理内存百分比</li><li>TIME+ — 进程使用的CPU时间总计，单位1/100秒</li><li>COMMAND — 进程名称（命令名/命令行）</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RH442系统调优笔记</title>
      <link href="/posts/69bbfb9a.html"/>
      <url>/posts/69bbfb9a.html</url>
      
        <content type="html"><![CDATA[<h1>基础知识</h1><p>调优是很困难的,也<code>不是万能</code>的,调优只是对系统策略进行一定的调整来获取更大的<code>吞吐量</code>和<code>响应时间</code>,调优之前要尽可能分析系统瓶颈在哪</p><h1>调优目的</h1><ul><li>为某一特定的角色来调优<ul><li>数据库服务器</li><li>文件服务器</li><li>web服务器</li><li>电子邮件服务器</li><li>中间件等</li></ul></li><li>找出和调整系统瓶颈</li><li>得更快的响应时间或者更大的吞吐量</li></ul><h1>相关概念</h1><ul><li>调优目标：设置明确的性能目标可以在成功调节性能后获得可度量的收益</li><li>性能瓶颈：当资源或设备达到其最大操作容量时，就出现了瓶颈，瓶颈会影响整体性能</li><li>人为因素：在系统调优时，必须考虑人的主观因素</li><li>负载优化：性能调优通常针对特定工作负载进行优化，但这时可能其他工作进程会被这些设置所阻碍</li><li>吞吐量和延迟：吞吐量是指给定时间内资源可以传输或处理的数据量的度量；延迟是资源必须等待开始数据传输或处理的延迟</li></ul><h1>处理步骤</h1><h2 id="收集信息">收集信息</h2><p>调优之前要尽可能收集所有信息,可以通过sosreport命令收集这些信息进行分析,但是收集的时候也需要把握一个<code>度</code>,因为收集信息的过程其实是<code>监控</code>过程,监控是需要消耗一定的资源的,比如CPU的使用率已经99%了,如果还需要<code>实时监控</code>获取信息,可能会导致不可预想的后果</p><ol><li>系统配置信息(OS版本,处理器信息,内存信息等)</li><li>存储信息</li><li>进程信息</li><li>网络信息</li><li>日志信息</li></ol><h2 id="分析过程">分析过程</h2><p>分析是决策的关键,通常将系统分为四个层次来逐步分析,减少问题的集中化</p><ol><li>CPU</li><li>磁盘</li><li>内存</li><li>网络</li></ol><h1>注意</h1><ol><li>系统调优不是万能的,没有系统调优也是万万不能的</li><li>调优是竟可能的发挥硬件和系统的性能,但实际上能提升性能最简单的方法就是升级硬件,你从Gtx750ti换RTX3060他不比优化配置提升来的快吗…机械换固态直接解决大部分io问题…</li><li>但实际上已经2022年了,服务器的配置不会太低,所以在有限的条件下通过系统调优优化业务是一项0成本的方法</li><li>系统调优需要注意每一步操作,因为不是所有参数都可以解决问题,还可能产生新的问题,就和写bug一样</li></ol><h1>调优工具</h1><h2 id="基操工具">基操工具</h2><h3 id="top">top</h3><p>全局统揽</p><h3 id="ps">ps</h3><p>监控进程</p><h3 id="free">free</h3><p>内存分析</p><h3 id="pcp">pcp</h3><p>收集性能数据</p><h3 id="df">df</h3><p>磁盘信息</p><h3 id="lsblk">lsblk</h3><p>磁盘信息</p><h3 id="ss">ss</h3><p>套接字信息</p><h3 id="tuna">tuna</h3><p>调试配置细节</p><h3 id="ulimit">ulimit</h3><p>资源限制参数</p><h2 id="sysstat工具">sysstat工具</h2><h3 id="vmstat">vmstat</h3><p>报告虚拟内存使用情况</p><h3 id="pidstat">pidstat</h3><p>pidstat命令通过进程或线程报告CPU，磁盘I/O，内存使用情况。-p选项可以指定某个进程的ID</p><h3 id="iostat">iostat</h3><p>报告CPU的统计数据和I/O的统计数据。iostat命令可以加入时间间隔和计数次数</p><h3 id="mpstat">mpstat</h3><p>先查看是用户态还是内核态的cpu负载高，如果是用户态就用pidstat看具体进程，如果是内核态就用iostat查看调用的I/O</p><h3 id="sar">sar</h3><p>生成系统活动报告</p><h1>查看硬件资源</h1><h2 id="dmesg">dmesg</h2><p>用于检测和控制内核环缓冲,回顾内核信息</p><h2 id="lscpu">lscpu</h2><p>查看CPU信息,cpu是机器的核心,如果cpu太弱那基本玩不转</p><h2 id="dmidecode">dmidecode</h2><p>检索SMBIOS和DMI的数据结构，并显示出重要的硬件信息</p><h2 id="lspci">lspci</h2><p>检测连接到PCI总线的设备</p><h2 id="lsusb">lsusb</h2><p>检测连接到USB总线的设备</p><h2 id="lshw">lshw</h2><p>列出具体的硬件配置信息，该命令列出精确的内存配置，如固件版本，主板配置，CPU版本和速度，缓存信息和总栈信息</p><h1>内核调优</h1><h2 id="proc文件系统">proc文件系统</h2><p>proc是一个伪文件系统，它提供了内核数据结构的结构。一些/proc文件直接指向了内核参数,编辑/proc文件中的设置与直接编辑内核参数相同。例如vmstat指令就是读取的/proc/meminfo中的信<br>/proc下面有一些常用子文件</p><ul><li>/proc/cpuinfo 提供CPU信息</li><li>/proc/meminfo 提供内存信息</li><li>/proc/swaps 提供swap空间利用率的信息</li><li>/proc/partitions 提供块设备信息</li><li>/proc/<code>PID</code>/ 提供特定某个运行中的进程信息</li></ul><h2 id="内核调节参数">内核调节参数</h2><p>Linux内核通过/proc像用户公开信息和可调节参数，/proc/sys子目录包含了可调节的参数。由于/proc/sys下的更改都直接写入内存中的内核，<code>所以当下次重启时并不会永久保存</code><br>/proc/sys/dev下常见的子目录：</p><ul><li>/proc/sys/dev：系统设备的可调节参数，例如RAID、CD-ROW、SCSI设备等</li><li>/proc/sys/fs：文件系统的可调参数</li><li>/proc/sys/kernel：包含内核内部工作的可调参数</li><li>/proc/sys/net：网络可调参数</li><li>/proc/sys/vm：虚拟内存可调参数</li></ul><h2 id="更改内核参数">更改内核参数</h2><h3 id="编辑器或重定向">编辑器或重定向</h3><ul><li>例如释放缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><ul><li>例如</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1&quot; &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure><h3 id="sysctl指令">sysctl指令</h3><ul><li>查看所有内核可调参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a </span><br></pre></td></tr></table></figure><ul><li>加载配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><ul><li>打印出某个内核参数的值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -n vm.swappiness</span><br></pre></td></tr></table></figure><ul><li>更改某个内核参数的值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.swappiness=60</span><br></pre></td></tr></table></figure><h3 id="etc-sysctl-d-下创建条目">/etc/sysctl.d/下创建条目</h3><p>在系统引导过程中，从以下三个目录中的配置文件中加载可调参数：</p><ul><li>/etc/sysctl.d/*.conf（首选）</li><li>/run/sysctl.d/*.conf</li><li>/usr/lib/sysctl.d/*.conf（不建议）</li></ul><h2 id="sys文件系统">sys文件系统</h2><p>sysfs文件系统也是伪文件系统，挂载到/sys目录上。/sys下的文件提供对作为内核模块加载的设备，文件系统和其他软件的信息和参数的访问。sysfs树曾经也是/proc的一部分，但出于安全性考虑被移植到了自己的文件系统中<br>/sys下常见的子目录：</p><ul><li>/sys/module 加载的内核模块信息</li><li>/sys/devices 保存了所有设备的信息（硬件设备）</li><li>/sys/dev  主要包含b（块block）设备和c（字符串char）设备，但都是以链接文件的形式指向了/sys/devices下真实设备</li><li>/sys/bus 包含各种总线类型</li><li>/sys/class 按照功能来划分的设备，但都是以链接文件的形式指向了/sys/devices下真实设备</li></ul><h2 id="tuned">tuned</h2><p>RHEL系统提供了一个名为tuned的调优服务，来帮助管理员针对不同的工作负载做调优<br>tuned有很多与定义好的profile文件，不同的profile文件是为了满足不同的工作负载而定义的。tuned服务分为静态调优和动态调节</p><ul><li>静态<br>tuned守护进程会在服务启动时或选择新的调优配置文件时应用系统配置。对于静态而言，内核参数是针对整体性能预期而设置的，不会随着活跃度的变化而进行调整</li><li>动态<br>tuned服务会一直监视系统，并根据运行时行为的变化而调整设置。RHLE8中默认关闭了动态调优，如果想启用，则需要修改/etc/tuned/tuned-main.conf文件中的dynamic_tuning = 0，把0换成1。同时动态调优会默认10秒调整一次。可以修改update_interval参数来设定希望的间隔时间</li></ul><h3 id="配置">配置</h3><ul><li>显示出当前正在使用的profile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuned-adm active</span><br></pre></td></tr></table></figure><ul><li>列出所有可用的profile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuned-adm list</span><br></pre></td></tr></table></figure><ul><li>切换某个profile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuned-adm profile PROFILE</span><br></pre></td></tr></table></figure><ul><li>推荐使用某个profile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuned-adm recommend</span><br></pre></td></tr></table></figure><ul><li>关闭调优服务器的调优参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuned-adm off</span><br></pre></td></tr></table></figure><h1>资源限制</h1><p>使用ulimit限制系统资源<br>交互式的使用ulimit将限制到单个用户shell，当某个用户登录系统后，pam_limits限制其使用的资源。在/etc/pam.d/system-auth文件中，有一个&quot;session&quot;调用了pam_limits<br>当用户登录系统后，PAM模块通过/etc/security/limits.conf和/etc/security/limits.d/*.conf的设置来解析和应用ulimit设置。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux机器信息采集</title>
      <link href="/posts/739a6897.html"/>
      <url>/posts/739a6897.html</url>
      
        <content type="html"><![CDATA[<h1>采集信息分类</h1><p>构成计算机的有硬件设备和软件设备</p><h2 id="软件">软件</h2><ol><li>系统的版本,ip,主机名,内核等信息</li></ol><h2 id="硬件">硬件</h2><ol><li>CPU</li><li>内存</li><li>硬盘</li><li>显卡</li><li>网卡</li></ol><h1>软件采集</h1><p>linux发行版很多<br>例如有debian,Ubuntu,centos,redhat,fedora,kylinsec,kylin,linx,arch,majaro,gentoo等,所以各个发行版看版本的命令也不一样,这边只对<code>R系</code>的发行版进行说明</p><h2 id="系统版本">系统版本</h2><ul><li>centos</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/centos-release</span><br></pre></td></tr></table></figure><ul><li>kylin系列</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/.kyinfo</span><br></pre></td></tr></table></figure><ul><li>其他命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有些发行版需要单独安装此包</span></span><br><span class="line">lsb_release -a </span><br></pre></td></tr></table></figure><h2 id="查看系统内核版本">查看系统内核版本</h2><p><code>uname</code>命令是所有Linux发行版基本通用的命令,uname的选项有很多,我会更新这个命令的用法的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><h2 id="查看系统架构">查看系统架构</h2><p>系统架构有以下两大类</p><ul><li>x86_64</li><li>ARM</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch</span><br></pre></td></tr></table></figure><h1>处理器CPU采集</h1><h2 id="查看CPU生产厂家">查看CPU生产厂家</h2><p>防止小作坊生产的(233333),用<code>uniq</code>基本上都是<code>过滤重复项</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s processor-manufacturer | uniq</span><br></pre></td></tr></table></figure><h2 id="CPU型号">CPU型号</h2><ol><li>通过查看cpuinfo文件过滤model name,并且过滤出重复项,因为cpu基本上是多核心的,再用cut剪切不需要的部分</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &#x27;model name&#x27; | uniq | cut -d: -f2</span><br></pre></td></tr></table></figure><ol start="2"><li>也可以通过dmidecode命令进行查看</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s processor-version | uniq</span><br></pre></td></tr></table></figure><ol start="3"><li>还可以通过命令查看<br>但是如果服务器是多路CPU可能输出会比较多</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure><h2 id="查看处理器位数">查看处理器位数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getconf LONG_BIT</span><br></pre></td></tr></table></figure><h2 id="查看机器是几路CPU">查看机器是几路CPU</h2><p>几路就是机器有几个实实在在的<code>cpu</code>硬件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;physical id&quot; /proc/cpuinfo | sort | uniq | wc -l</span><br></pre></td></tr></table></figure><h2 id="查看每颗处理器cores-核心-数量">查看每颗处理器cores(核心)数量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq | awk &#x27;&#123;print $4&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="查看总核数">查看总核数</h2><p>简单计算就出来了<br><code>总核数</code> = 物理CPU个数 X <code>每颗</code>物理CPU的<code>核数</code></p><h2 id="查看总逻辑CPU数">查看总逻辑CPU数</h2><p><code>总逻辑CPU数</code> = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l</span><br></pre></td></tr></table></figure><h2 id="查看所有cores-核心数量">查看所有cores(核心数量)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;cpu cores&quot; | wc -l</span><br></pre></td></tr></table></figure><h2 id="查看L1缓存">查看L1缓存</h2><p>一级缓存是CPU第一层高速缓存,分为数据缓存(L1d)和指令缓存(L1i),内置的L1高速缓存的容量和结构对CPU的性能影响较大,不过高速缓冲存储器均由静态RAM组成,结构较复杂m在CPU管芯面积不能太大的情况下,L1级高速缓存的容量不可能做得太大,一般服务器CPU的L1缓存的容量通常在32—256KB</p><ul><li>数据缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep -i &#x27;L1d cache&#x27; </span><br></pre></td></tr></table></figure><ul><li>指令缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep -i &#x27;L1i cache&#x27;</span><br></pre></td></tr></table></figure><h2 id="查看L2缓存">查看L2缓存</h2><p>二级缓存是CPU的第二层高速缓存,L2高速缓存容量也会影响CPU的性能,原则是越大越好,现在家庭用CPU容量最大的是4MB,而服务器和工作站上用CPU的L2高速缓存更高达2MB—4MB，有的高达8MB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep -i &#x27;L2 cache&#x27; </span><br></pre></td></tr></table></figure><h2 id="查看L3缓存">查看L3缓存</h2><p>进一步提高了CPU的效率,越大越好,比如谁给我买一个<a href="https://www.amd.com/zh-hans/products/cpu/amd-ryzen-threadripper-pro-5955wx">AMD Ryzen™ Threadripper™ PRO 5955WX</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep -i &#x27;L3 cache&#x27;</span><br></pre></td></tr></table></figure><h2 id="查看处理器频率">查看处理器频率</h2><ol><li>lscpu过滤<br>这个数值是<code>动态</code>变化的!</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep -i &#x27;CPU MHz&#x27; | awk -F &#x27;：|:&#x27; &#x27;&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure><ol start="2"><li>cpuinfo文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep MHz</span><br></pre></td></tr></table></figure><ol start="3"><li>DMI查看</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s processor-frequency | uniq</span><br></pre></td></tr></table></figure><h1>查看内存信息</h1><h2 id="查看内存总大小">查看内存总大小</h2><ul><li>大小</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode | grep -A16 &quot;Memory Device&quot; | grep Size | grep -v No | awk &#x27;&#123;sum+=$2&#125;END&#123;print sum&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>单位<br>其实单位一般就是MB</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode | grep -A16 &quot;Memory Device&quot; | grep Size | grep -v No | awk &#x27;&#123;print $3&#125;&#x27; | uniq</span><br></pre></td></tr></table></figure><h2 id="从系统角度看内存">从系统角度看内存</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><h2 id="查看内存条数量和每根的具体大小">查看内存条数量和每根的具体大小</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode | grep -A16 &quot;Memory Device&quot; | grep Size </span><br></pre></td></tr></table></figure><blockquote><p>输入如下,其实只要看Size:字段</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Size: 8192 MB</span><br><span class="line">Size: 4096 MB</span><br><span class="line">Size: 4096 MB</span><br><span class="line">Size: No Module Installed</span><br><span class="line">Range Size: 8 GB</span><br><span class="line">Range Size: 4 GB</span><br><span class="line">Range Size: 4 GB</span><br></pre></td></tr></table></figure><h2 id="查看机器最大支持内存容量">查看机器最大支持内存容量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode | grep &quot;Maximum Capacity&quot; | sed  &quot;s/^[ \t]*//&quot;</span><br></pre></td></tr></table></figure><h2 id="查看内存频率">查看内存频率</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode|grep -A16 &quot;Memory Device&quot;|grep &#x27;Speed&#x27; </span><br></pre></td></tr></table></figure><blockquote><p>其实上面的命令就足够了,但可以过滤其他参数来显示更加精确,比如</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode|grep -A16 &quot;Memory Device&quot;|grep &#x27;Speed&#x27; | grep -iv &#x27;unKnown&#x27;</span><br></pre></td></tr></table></figure><h2 id="查看内存制造商">查看内存制造商</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode | grep -A16 &quot;Memory Device&quot; | grep &#x27;Manufacturer&#x27;</span><br></pre></td></tr></table></figure><h2 id="查看内存规格">查看内存规格</h2><blockquote><p>我只有家用的物理机器,服务器没有试过</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -t memory | grep Type:</span><br></pre></td></tr></table></figure><h2 id="查看内存序列号">查看内存序列号</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -t memory | grep -i &#x27;Serial Number&#x27; </span><br></pre></td></tr></table></figure><h1>查看主板信息</h1><h2 id="总揽信息">总揽信息</h2><blockquote><p>可以看出很多信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -t bios</span><br></pre></td></tr></table></figure><p>比如我这张昂达主板</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># dmidecode 3.2</span><br><span class="line">Getting SMBIOS data from sysfs.</span><br><span class="line">SMBIOS 3.0.0 present.</span><br><span class="line"></span><br><span class="line">Handle 0x0000, DMI type 0, 24 bytes</span><br><span class="line">BIOS Information</span><br><span class="line">        Vendor: American Megatrends Inc.</span><br><span class="line">        Version: 5.11</span><br><span class="line">        Release Date: 2016/05/30</span><br><span class="line">        Address: 0xF0000</span><br><span class="line">        Runtime Size: 64 kB</span><br><span class="line">        ROM Size: 6144 kB</span><br><span class="line">        Characteristics:</span><br><span class="line">                PCI is supported</span><br><span class="line">                BIOS is upgradeable</span><br><span class="line">                BIOS shadowing is allowed</span><br><span class="line">                Boot from CD is supported</span><br><span class="line">                Selectable boot is supported</span><br><span class="line">                BIOS ROM is socketed</span><br><span class="line">                EDD is supported</span><br><span class="line">                5.25&quot;/1.2 MB floppy services are supported (int 13h)</span><br><span class="line">                3.5&quot;/720 kB floppy services are supported (int 13h)</span><br><span class="line">                3.5&quot;/2.88 MB floppy services are supported (int 13h)</span><br><span class="line">                Print screen service is supported (int 5h)</span><br><span class="line">                Serial services are supported (int 14h)</span><br><span class="line">                Printer services are supported (int 17h)</span><br><span class="line">                ACPI is supported</span><br><span class="line">                USB legacy is supported</span><br><span class="line">                BIOS boot specification is supported</span><br><span class="line">                Targeted content distribution is supported</span><br><span class="line">                UEFI is supported</span><br><span class="line">        BIOS Revision: 5.11</span><br><span class="line"></span><br><span class="line">Handle 0x0057, DMI type 13, 22 bytes</span><br><span class="line">BIOS Language Information</span><br><span class="line">        Language Description Format: Long</span><br><span class="line">        Installable Languages: 2</span><br><span class="line">                zh|CN|unicode</span><br><span class="line">                &lt;BAD INDEX&gt;</span><br><span class="line">        Currently Installed Language: zh|CN|unicode</span><br></pre></td></tr></table></figure><h2 id="主板BIOS厂商">主板BIOS厂商</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s bios-vendor</span><br></pre></td></tr></table></figure><h2 id="BIOS版本">BIOS版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s bios-version</span><br></pre></td></tr></table></figure><h2 id="主板厂家">主板厂家</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s system-manufacturer</span><br></pre></td></tr></table></figure><h2 id="主板具体型号">主板具体型号</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s system-product-name</span><br></pre></td></tr></table></figure><h2 id="机器序列号">机器序列号</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s system-serial-number</span><br></pre></td></tr></table></figure><h1>查看显卡信息</h1><h2 id="定位型号">定位型号</h2><ul><li>查看显卡厂商ID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nn | grep -i vga</span><br></pre></td></tr></table></figure><blockquote><p>输出结果如,只需要关注 [10de:1c82] 类似这个的字段</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01:00.0 VGA compatible controller [0300]: NVIDIA Corporation GP107 [GeForce GTX 1050 Ti] [10de:1c82] (rev a1)</span><br></pre></td></tr></table></figure><ul><li>登陆网站查询</li></ul><ol><li>有些显卡可能比较老,在lspci可能不会输出,此时就要登陆<a href="https://devicehunt.com/">devicehunt</a>进行查询</li><li>上面说了要关注<code>[10de:1c82]</code> 字段,其中<code>10de</code>是<code>Vendor ID</code>,<code>1c82</code>是<code>Device ID</code></li><li>只需要在<a href="https://devicehunt.com/">devicehunt</a>网站的<code>Device ID</code>输入框输入<code>1c82</code>就可以查询了</li></ol><h2 id="N卡">N卡</h2><p>如果已经安装好了驱动,只要输入N卡命令</p><ul><li>以字符模式输出信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><ul><li>打开显卡设置面板</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-settings</span><br></pre></td></tr></table></figure><h2 id="查看显存">查看显存</h2><p>(我也没试过)</p><ol><li>dmesg查看</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i VRAM</span><br></pre></td></tr></table></figure><ol start="2"><li>查看proc下内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/gpuinfo_0</span><br></pre></td></tr></table></figure><h1>查看网卡信息</h1><h2 id="定位型号-2">定位型号</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpi -nn | grep -i eth</span><br></pre></td></tr></table></figure><p>输出如下,可以看到有四个设备,查询方法和显卡一直,一般来说都会有驱动,但如果没有,则需要去对应网站下载源码进行编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0b:00.0 Ethernet controller [0200]: Intel Corporation Ethernet Controller I225-V [8086:15f3] (rev 03)</span><br><span class="line">0b:00.1 Ethernet controller [0200]: Intel Corporation Ethernet Controller I225-V [8086:15f3] (rev 03)</span><br><span class="line">0b:00.2 Ethernet controller [0200]: Intel Corporation Ethernet Controller I225-V [8086:15f3] (rev 03)</span><br><span class="line">0b:00.3 Ethernet controller [0200]: Intel Corporation Ethernet Controller I225-V [8086:15f3] (rev 03)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/posts/f3fb008f.html"/>
      <url>/posts/f3fb008f.html</url>
      
        <content type="html"><![CDATA[<h1>用到的软件</h1><ol><li>hexo博客</li><li>node.js语言,进行本地部署</li><li>git代码管理,托管服务器</li><li>nginx代理服务,用于代理</li><li>centos7.9-2204操作系统</li><li>vscode博客编辑软件</li><li>windterm远程工具</li><li>docker运行容器</li><li>twikoo评论系统</li><li>vercel部署api显示github贡献图</li></ol><h1>原理</h1><p>1.为本地hexo博客配置一个部署静态文件的远程仓库<br>2.配置 Nginx 托管博客文件目录<br>3.配置远程仓库自动更新到博客文件目录的钩子<br>在本地将博客同步到服务器之后会自动更新到nginx的页面</p><h1>搭建步骤</h1><h2 id="初始化centos">初始化centos</h2><ol><li>关闭selinux</li><li>关闭防火墙</li><li>配置网络</li></ol><h2 id="初始化git仓库">初始化git仓库</h2><p>使用windterm连接服务器</p><ul><li>创建用户管理</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -s /sbin/nologin test</span><br></pre></td></tr></table></figure><ul><li>创建一个仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/repo</span><br><span class="line">mkdir -p /var/www/hexo</span><br></pre></td></tr></table></figure><ul><li>配置权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R test:test /var/repo</span><br><span class="line">chown -R test:test /var/www/hexo</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 755 /var/repo</span><br><span class="line">chmod -R 755 /var/www/hexo</span><br></pre></td></tr></table></figure><ul><li>初始化仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/repo</span><br><span class="line">git init --bare hexo.git</span><br></pre></td></tr></table></figure><ul><li>创建git钩子</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch /var/repo/hexo.git/hooks/post-receive</span><br><span class="line">chmod +x /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>post-receive添加如下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">git <span class="attr">--work-tree</span>=/var/www/hexo --git-dir=/var/repo/hexo.git checkout -f</span><br></pre></td></tr></table></figure><h2 id="配置nginx">配置nginx</h2><ul><li>修改nginx.conf</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">     server &#123;</span><br><span class="line">     #SSL 访问端口号为 443</span><br><span class="line">     listen      443 ssl;</span><br><span class="line">     #填写绑定证书的域名</span><br><span class="line">     server_name 域名;</span><br><span class="line">     #证书文件名称</span><br><span class="line">     ssl_certificate crt的绝对路径;</span><br><span class="line">     #私钥文件名称</span><br><span class="line">     ssl_certificate_key key的绝对路径;</span><br><span class="line">     ssl_session_timeout 5m;</span><br><span class="line">     #请按照以下协议配置</span><br><span class="line">     ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">     #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。</span><br><span class="line">     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">     ssl_prefer_server_ciphers on;</span><br><span class="line">     location / &#123;</span><br><span class="line">         root   /var/hexo;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">填写绑定证书的域名</span></span><br><span class="line"> server_name 域名;</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">把http的域名请求转成https</span></span><br><span class="line"> return 301 https://域名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置本地hexo同步">配置本地hexo同步</h2><ul><li>编辑_config.yml</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@域名或者ip:/var/repo/hexo.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><ul><li>安装依赖<br>本地机器需要安装node.js才能操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安装部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dnf插件</title>
      <link href="/posts/a5bbe015.html"/>
      <url>/posts/a5bbe015.html</url>
      
        <content type="html"><![CDATA[<h1>dnf插件查看</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf --help</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">插件命令列表：</span><br><span class="line">builddep                  Install build dependencies for package or spec file</span><br><span class="line">changelog                 查看软件包的改变日志数据</span><br><span class="line">config-manager            管理 dnf 配置选项和软件仓库</span><br><span class="line">copr                      与 Copr 仓库交互。</span><br><span class="line">debug-dump                转储已安装的 RPM 软件包信息至文件</span><br><span class="line">debug-restore             恢复调试用转储文件中的软件包记录</span><br><span class="line">debuginfo-install         安装调试信息软件包</span><br><span class="line">download                  下载软件包至当前目录</span><br><span class="line">groups-manager            创建并编辑组元数据文件</span><br><span class="line">needs-restarting          判断所升级的二进制文件是否需要重启</span><br><span class="line">playground                与 Playground 仓库交互。</span><br><span class="line">repoclosure               显示仓库中未被解决的依赖关系的列表</span><br><span class="line">repodiff                  列出两组仓库中的不同</span><br><span class="line">repograph                 以点线图方式输出完整的软件包依赖关系图</span><br><span class="line">repomanage                管理 RPM 软件包目录</span><br><span class="line">reposync                  下载远程仓库中的全部软件包</span><br></pre></td></tr></table></figure><p>功能有很多,只看几个我会的</p><h1>changelog</h1><p>在源仓库可以使用的时候才可以查询</p><ul><li>查询openssh的改动日志</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf changelog openssh</span><br></pre></td></tr></table></figure><ul><li>查看指定行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf changelog  --count=30  kernel</span><br></pre></td></tr></table></figure><ul><li>查看bugfix</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf changelog --bugfix</span><br></pre></td></tr></table></figure><h1>config-manager</h1><p>类似yum-config-manager?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --disable cdrom</span><br></pre></td></tr></table></figure><h1>download</h1><ul><li>只下载到当前路径</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf download  openssh</span><br></pre></td></tr></table></figure><h1>repoclosure</h1><p>显示仓库中未被解决的依赖关系的列表,是仓库!不是本机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf repoclosure</span><br></pre></td></tr></table></figure><h1>repograph</h1><p>将结果输出重定向到文件,vim进行搜索</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf repograph &gt; yilai.txt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;openssh-server&quot; [color=&quot;0.891304347826 0.991304347826 1.0&quot;];</span><br><span class="line">&quot;openssh-server&quot; -&gt; &#123;</span><br><span class="line">&quot;glibc&quot;</span><br><span class="line">&quot;bash&quot;</span><br><span class="line">&quot;systemd&quot;</span><br><span class="line">&quot;openssl-libs&quot;</span><br><span class="line">&quot;libselinux&quot;</span><br><span class="line">&quot;zlib&quot;</span><br><span class="line">&quot;systemd-libs&quot;</span><br><span class="line">&quot;krb5-libs&quot;</span><br><span class="line">&quot;libxcrypt&quot;</span><br><span class="line">&quot;libcom_err&quot;</span><br><span class="line">&quot;pam&quot;</span><br><span class="line">&quot;audit-libs&quot;</span><br><span class="line">&quot;shadow-utils&quot;</span><br><span class="line">&quot;openssh&quot;</span><br><span class="line">&quot;crypto-policies&quot;</span><br><span class="line">&#125; [color=&quot;0.891304347826 0.991304347826 1.0&quot;];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包管理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>repo文件解释</title>
      <link href="/posts/834a969d.html"/>
      <url>/posts/834a969d.html</url>
      
        <content type="html"><![CDATA[<h1>什么是repo文件</h1><p>repo文件是yum仓库的配置文件后缀，通常一个repo文件中可以设置多个yum仓库源，当安装和升级时yum会读取此配置文件，到yum仓库下载所需的rpm包并安装</p><h1>yum工作原理</h1><ul><li><p>服务器端：在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内。</p></li><li><p>客户端：如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的记录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装。</p></li></ul><h1>举个栗子</h1><p>repo文件一般都在<code>/etc/yum.repo.d</code>路径下面</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Base]</span></span><br><span class="line"><span class="attr">name</span>=CentOS-<span class="variable">$releasever</span> - Base</span><br><span class="line"><span class="attr">baseurl</span>=https://mirrors.ustc.edu.cn/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centos<span class="literal">off</span>icial</span><br></pre></td></tr></table></figure><ul><li><p>[Base]<br>是serverid,.必选值,不可重复,重复了以后面的为准,定义软件仓库(Repository)的名称,用作Yum识别不同仓库</p></li><li><p>name<br>用于定义仓库名和描述信息,用做配置说明,支持<code>$releasever</code>和<code>$basearch</code>这样的变量</p></li><li><p>baseurl<br>必填选项,定义仓库文件路径。可选的协议值为http, https, file://, ftp://,可以在里面使用变量,<code>但只能写一个</code></p></li><li><p>mirrorlist</p><p>是指定一个镜像服务器的地址列表</p></li><li><p>enabled<br>是否开启当前仓库，0表示关闭，1表示开启。如未指明，默认为1</p></li><li><p>gpgcheck<br>是否检查软件包的GPG签名，1为开启，0为关闭</p></li><li><p>gpgkey<br>用于指定GPG签名文件的URL</p></li><li><p>常用变量</p><ul><li><p>$releasever</p><p>发行版的版本，从yum.conf文件中的distroverpkg获取，如果没有，则根据redhat-release包进行判断。</p></li><li><p>$arch</p><p>cpu体系，如i686,athlon等</p></li><li><p>$basearch</p><p>cpu的基本体系组，如i686和athlon同属i386，alpha和alphaev6同属alpha。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 配置解释 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置解释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code-server搭建</title>
      <link href="/posts/a74d3561.html"/>
      <url>/posts/a74d3561.html</url>
      
        <content type="html"><![CDATA[<h1>下载软件</h1><p>code-server软件</p><h1>解压</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf code-server.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><h1>定义配置文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.config/code-server</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.config/code-server/config.yml</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#加入内容</span><br><span class="line">bind-addr: 0.0.0.0:81</span><br><span class="line">auth: password</span><br><span class="line">password: test.2022</span><br><span class="line">cert: false</span><br></pre></td></tr></table></figure><h1>定义service资源</h1><ul><li>创建文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim code-server.service</span><br></pre></td></tr></table></figure><ul><li>写入配置,ExecStart的是二进制所在路径</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=code-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=exec</span><br><span class="line">ExecStart=/usr/local/code-server/bin/code-server</span><br><span class="line">Restart=always</span><br><span class="line">User=root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure><ul><li>移动配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv code-server.service /etc/systemd/system/</span><br></pre></td></tr></table></figure><ul><li>如果后面修改 /etc/systemd/system/code-server.service</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h1>管理服务</h1><ul><li>启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start code-server</span><br></pre></td></tr></table></figure><ul><li>查看</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status code-server</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安装部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之systemctl</title>
      <link href="/posts/5154c07a.html"/>
      <url>/posts/5154c07a.html</url>
      
        <content type="html"><![CDATA[<h1>概念</h1><ul><li>systemd<br>systemd是与SysV和LSB初始化脚本兼容的系统和服务管理器,开启systemd服务,可以基于守护进程按需启动策略<br>systemd服务支持快照和系统状态恢复,维护挂载和自动挂载点,服务之间的从属关系也有逻辑控制</li><li>systemd unit<br>system服务的开启和监督系统是基于unit的,unit就是一个与配置文件对应的名称和类型组成,unit的类型如下</li></ul><ol><li>service unit 系统服务</li><li>Target unit 一组systemd units</li><li>Automount unit 文件系统挂载点</li><li>Device unit  内核识别的设备文件</li><li>Mount unit   文件系统挂载点</li><li>Path unit    一个文件系统中的文件或目录</li><li>Scope unit  外部创建的进程</li><li>Snapshot unit   systemd manager  的保存状态</li></ol><ul><li>systemd的特性</li></ul><ol><li>更快的启动速度</li><li>按需启动能力</li><li>采用cgroup特性跟踪和管理进程的生命周期</li><li>采用挂载点和自动挂载的管理</li><li>实现事务依赖性关系管理</li><li>与SysV初始化脚本兼容</li><li>对系统进程快照和恢复</li></ol><h1>管理服务</h1><p>用systemctl命令管理进行 运行 启动 重启 显示 自启动 关闭自启动 等</p><h1>基操</h1><h2 id="显示运行的服务">显示运行的服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type service</span><br></pre></td></tr></table></figure><h2 id="显示所有的服务">显示所有的服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type service --all</span><br></pre></td></tr></table></figure><h2 id="查看服务状态">查看服务状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status httpd</span><br></pre></td></tr></table></figure><ul><li>显示指标<br>loaded: 说明服务是否被加载,同时显示对应的绝对路径是否启用<br>active: 是否运行<br>main pid: 进程pid<br>cgroup: 相关控制组的其他信息</li></ul><h2 id="管理服务的基操">管理服务的基操</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start sshd</span><br><span class="line">systemctl stop  sshd</span><br><span class="line">systemctl restart sshd</span><br><span class="line">systemctl enable sshd</span><br><span class="line">systemctl disable sshd</span><br></pre></td></tr></table></figure><h2 id="操作系统电源">操作系统电源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl poweroff  #关闭系统,下电</span><br><span class="line">systemctl halt      #关闭系统,不下电</span><br><span class="line">systemctl reboot    #重启</span><br><span class="line">systemctl suspend   #待机</span><br><span class="line">systemctl hibernate  #休眠</span><br><span class="line">systemctl hybrid-sleep #待机+休眠</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码安装软件</title>
      <link href="/posts/15a364b4.html"/>
      <url>/posts/15a364b4.html</url>
      
        <content type="html"><![CDATA[<h1>R系安装软件的2种方式</h1><ul><li>rpm包安装</li><li>编译安装软件</li></ul><h1>为什么用源码安装</h1><ol><li>rpm包版本太旧,官方的新包还没有出来,使用源码编译安装可以解决业务问题</li><li>rpm包安装的软件缺少某些功能</li><li>优化编译参数提升性能,兼容性好</li><li>但是过程繁琐,可能缺少其他依赖包</li></ol><h1>简易源码安装步骤</h1><ol><li>下载源码包,检查包的完整性并解压</li><li>查看README或者install文件,里面是安装方法</li><li>使用./configure命令生成Makefile文件</li><li>编译 make</li><li>安装 make install,默认路径/usr/local</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安装部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之dnf</title>
      <link href="/posts/a36cc04b.html"/>
      <url>/posts/a36cc04b.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>DNF:Dandified YUM,是基于RPM的Linux发行版的软件包管理器,它用于在 Fedora / RHEL / CentOS操作系统中安装,更新和删除软件包,目前 DNF 命令和yum命令相互兼容,软件包仓库依旧使用 YUM 仓库。</p><h1>注意</h1><p>dnf和yum的基础命令都是兼容的,但是dnf默认安装了很多插件,后会出一个插件的学习记录</p><h1>配置dnf</h1><ul><li>dnf主要配置文件<br>/etc/dnf/dnf.conf<br>在rockylinux和centos9stream系统中/etc/yum.conf是指向dnf.conf的软链接,内容如下</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">installonly_limit</span>=<span class="number">3</span></span><br><span class="line"><span class="attr">clean_requirements_on_remove</span>=<span class="literal">True</span></span><br><span class="line"><span class="attr">best</span>=<span class="literal">True</span></span><br><span class="line"><span class="attr">skip_if_unavailable</span>=<span class="literal">False</span></span><br></pre></td></tr></table></figure><p>参数说明</p><ol><li>cachedir:缓存目录,存储rpm包和数据库文件(默认没写,在其他路径)</li><li>best: 升级包的时候总是尝试安装最高版本,如果最高不能装就停止并显示原因</li><li>installonly_limit: 同时安装&quot;installonlypkgs&quot; 指令列出包的数量,默认3,不建议降低</li><li>clean_requirements_on_remove:删除dnf remove期间不在使用的依赖项,即是dnf连带安装的依赖,只能通过此参数为true来删除</li></ol><h1>设置仓库</h1><h2 id="修改dnf源文件">修改dnf源文件</h2><p>还是修改/etc/yum.repos.d下面的repo文件,配置和yum一样</p><h2 id="创建本地源仓库">创建本地源仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install createrepo</span><br></pre></td></tr></table></figure><ul><li>将软件包放在该目录下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createrepo --database /mnt/test </span><br></pre></td></tr></table></figure><h2 id="命令添加源">命令添加源</h2><p>会在/etc/yum.repo.d下生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --add-repo repo_url</span><br></pre></td></tr></table></figure><h1>查看源</h1><ul><li>查看本机配置的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf repolist</span><br></pre></td></tr></table></figure><ul><li>查看具体的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf repolist base</span><br></pre></td></tr></table></figure><h1>启停源</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --set-enable repo_name</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --set-disable repo_name</span><br></pre></td></tr></table></figure><h1>基操</h1><p>基本没yum没有区别</p><ul><li>查</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf search ssh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf provides ssh</span><br></pre></td></tr></table></figure><ul><li>列举安装的包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf list all</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf list openssh</span><br></pre></td></tr></table></figure><ul><li>查看包的信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf info openssh</span><br></pre></td></tr></table></figure><h1>光下载不安装</h1><p>这是一个dnf插件实现的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf download package_name</span><br></pre></td></tr></table></figure><h1>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install httpd</span><br></pre></td></tr></table></figure><h1>卸载软件包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf remove httpd</span><br></pre></td></tr></table></figure><h1>列出详细的组信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf  groups info &quot;开发工具&quot;</span><br></pre></td></tr></table></figure><h1>安装卸载软件包组</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf groups install 软件包组/id</span><br><span class="line">dnf groups remove 软件包组/id</span><br></pre></td></tr></table></figure><h1>检查更新</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf check-update</span><br></pre></td></tr></table></figure><h1>升级软件包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf update</span><br></pre></td></tr></table></figure><h1>升级单独的</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf update 包名</span><br></pre></td></tr></table></figure><h1>升级组</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf group update group_name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之xz</title>
      <link href="/posts/2307c602.html"/>
      <url>/posts/2307c602.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>用来压缩文件的命令</p><h1>用法</h1><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -Jcf a.tar.xz  shell/</span><br></pre></td></tr></table></figure><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xz -z a.txt</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -Jxf a.tar.xz</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xz -d  a.tar.xz</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之zip</title>
      <link href="/posts/e416da7.html"/>
      <url>/posts/e416da7.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>日常工作中,我们在linux发行版直接一般不用zip,但为了和windows一起分享资料,可以用zip打包</p><h1>压缩</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip a.zip  shell/</span><br></pre></td></tr></table></figure><h1>解压</h1><p>unzip a.zip</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之bizp2</title>
      <link href="/posts/29735a96.html"/>
      <url>/posts/29735a96.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>解压缩的,不能压缩文件夹</p><h1>用法</h1><ul><li>压缩<br>效果是源文件不见了，多了一个a.txt.bz2</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 a.txt</span><br></pre></td></tr></table></figure><ul><li>覆盖原文件压缩<br>如果当前目录下存在一样的文件，强制覆盖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -f a.txt</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -dv a.txt.bz2</span><br></pre></td></tr></table></figure><ul><li>模拟解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -tv a.txt.bz2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之gzip</title>
      <link href="/posts/eda8d2e4.html"/>
      <url>/posts/eda8d2e4.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>可以压缩文件节省磁盘 60%~70%的压缩率,但不能压文件夹</p><h1>操作</h1><ul><li>压缩文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -v a.txt</span><br></pre></td></tr></table></figure><ul><li>解压文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dv  a.txt.gz</span><br></pre></td></tr></table></figure><ul><li>列出压缩文件内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -l a.txt.gz</span><br></pre></td></tr></table></figure><ul><li>递归压缩(不是压缩文件,是分别压缩文件夹下的文件)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -r shell/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之at</title>
      <link href="/posts/5fbf421d.html"/>
      <url>/posts/5fbf421d.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>定时任务，指定一个时间执行一个任务，只执行一次</p><h1>用法</h1><h2 id="查看任务队列">查看任务队列</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atq</span><br></pre></td></tr></table></figure><h2 id="立即执行脚本">立即执行脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at -f a.sh now </span><br></pre></td></tr></table></figure><h2 id="10分钟之后执行">10分钟之后执行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at -f a.sh now+10 min</span><br></pre></td></tr></table></figure><h2 id="20-20执行脚本">20:20执行脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at -f a.sh 20:20</span><br></pre></td></tr></table></figure><h1>在指定日期执行脚本</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at -f a.sh 04/27/2023</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fcitx码表</title>
      <link href="/posts/80826a5.html"/>
      <url>/posts/80826a5.html</url>
      
        <content type="html"><![CDATA[<h1>生成码表txt文件(罗马字符为例子)</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim test.txt</span><br></pre></td></tr></table></figure><p>加入如下内容</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;fcitx Version 0x03 Table file</span><br><span class="line"><span class="attribute">KeyCode</span>=abcdefghijklmnopqrstuvwxy</span><br><span class="line"><span class="attribute">Length</span>=4</span><br><span class="line"><span class="attribute">Pinyin</span>=@</span><br><span class="line"><span class="attribute">PinyinLength</span>=4</span><br><span class="line"><span class="attribute">Prompt</span>=&amp;</span><br><span class="line"><span class="attribute">ConstructPhrase</span>=^</span><br><span class="line">[Rule]</span><br><span class="line"><span class="attribute">e2</span>=p11+p12+p21+p22</span><br><span class="line"><span class="attribute">e3</span>=p11+p21+p31+p32</span><br><span class="line"><span class="attribute">a4</span>=p11+p21+p31+n11</span><br><span class="line">[Data]</span><br><span class="line">a 工</span><br><span class="line">a 戈</span><br><span class="line">a 或</span><br><span class="line">a 其</span><br><span class="line">aa 式</span><br><span class="line">aa 戒<span class="built_in"></span></span><br><span class="line"><span class="built_in">aaa </span>工</span><br><span class="line">aaaa 工</span><br><span class="line">aaaa 恭恭敬敬</span><br></pre></td></tr></table></figure><h1>转换成码表</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txt2mb test.txt test.mb</span><br></pre></td></tr></table></figure><h1>配置文件的解释</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[CodeTable]</span><br><span class="line">UniqueName=wubi</span><br><span class="line">Name=Wubi</span><br><span class="line">Name[bo_CN]=སྨྱུག་རིམ་ཡིག་གཟུགས།</span><br><span class="line">Name[ca]=Wubi</span><br><span class="line">Name[da]=Wubi</span><br><span class="line">Name[de]=Wubi</span><br><span class="line">Name[en]=Wubi</span><br><span class="line">Name[ja]=Wubi</span><br><span class="line">Name[ko]=Wubi</span><br><span class="line">Name[ru]=Уби (Wubi)</span><br><span class="line">Name[ug_CN]=ۋۇبى خەت شەكلى</span><br><span class="line">Name[zh_CN]=五笔字型</span><br><span class="line">Name[zh_HK]=五筆字型</span><br><span class="line">Name[zh_TW]=五筆字型</span><br><span class="line">IconName=wubi</span><br><span class="line">File=wbx.mb                    # 码表文件名称，一般不动</span><br><span class="line">AdjustOrder=AdjustNo            # 自动调频</span><br><span class="line">Priority=10</span><br><span class="line">UsePY=True                     # 万能键</span><br><span class="line">PYKey=z</span><br><span class="line">AutoSend=-1                 　  #　 自动上屏</span><br><span class="line">NoneMatchAutoSend=1            #　空码自动上屏</span><br><span class="line">UseMatchingKey=True</span><br><span class="line">MatchingKey=z</span><br><span class="line">AutoPhrase=True</span><br><span class="line">AutoPhraseLength=4</span><br><span class="line">AutoPhrasePhrase=True</span><br><span class="line">SaveAutoPhrase=3</span><br><span class="line">ExactMatch=False</span><br><span class="line">PromptTableCode=False     # 编码提示</span><br><span class="line">Symbol=zzzz</span><br><span class="line">Enabled=True</span><br><span class="line">LangCode=zh_CN</span><br><span class="line">NoMatchDontCommit=True</span><br><span class="line">SimpleCodeOrderLevel=2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fcitx输入法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之dos2unix</title>
      <link href="/posts/816f4133.html"/>
      <url>/posts/816f4133.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>由于windows上文件的结束符和linux上的不同，那么在windows上编写的文件或者是脚本在Linux上就会遇到类似于下面的错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh^M: bad interpreter: No such file or directory</span><br></pre></td></tr></table></figure><h1>使用方法</h1><h2 id="转换单个文件">转换单个文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dos2unix demo.sh</span><br></pre></td></tr></table></figure><h2 id="转换多个文件">转换多个文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.sh&quot; | xargs dos2unix</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之lscpu</title>
      <link href="/posts/52a81fc0.html"/>
      <url>/posts/52a81fc0.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>查看cpu信息</p><h1>lscpu输出</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Architecture:          x86_64 <span class="comment">#架构，这里的64指的位处理器</span></span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit <span class="comment">#CPU支持的模式：32位、64位</span></span><br><span class="line">Byte Order:            Little Endian <span class="comment">#字节排序的模式，常用小端模式</span></span><br><span class="line">CPU(s):                2 <span class="comment">#逻辑CPU数量</span></span><br><span class="line">On-line CPU(s) list:   0,1 <span class="comment">#在线的cpu数量 有些时候为了省电或者过热的时候，某些CPU会停止运行</span></span><br><span class="line">Thread(s) per core:    2 <span class="comment">#每个核心支持的线程数</span></span><br><span class="line">Core(s) per socket:    1 <span class="comment">#每颗物理cpu的核数</span></span><br><span class="line">Socket(s):             1 <span class="comment">#主板上插CPU的槽的数量，即物理cpu数量</span></span><br><span class="line">NUMA node(s):          1</span><br><span class="line">Vendor ID:             GenuineIntel <span class="comment">#cpu厂商ID</span></span><br><span class="line">CPU family:            6 <span class="comment">#CPU系列</span></span><br><span class="line">Model:                 85 <span class="comment">#CPU型号</span></span><br><span class="line">Model name:            Intel(R) Xeon(R) Gold 6271C CPU @ 2.60GHz</span><br><span class="line">Stepping:              7</span><br><span class="line">CPU MHz:               2593.906 <span class="comment">#cpu主频</span></span><br><span class="line">BogoMIPS:              5187.81 <span class="comment">#MIPS是每秒百万条指令,Bogo是Bogus(伪)的意思，这里是估算MIPS值</span></span><br><span class="line">Hypervisor vendor:     KVM  <span class="comment">#cpu支持的虚拟化技术</span></span><br><span class="line">Virtualization type:   full</span><br><span class="line">L1d cache:             32K <span class="comment">#一级高速缓存 dcache 用来存储数据</span></span><br><span class="line">L1i cache:             32K <span class="comment">#一级高速缓存 icache 用来存储指</span></span><br><span class="line">L2 cache:              1024K <span class="comment">#二级缓存</span></span><br><span class="line">L3 cache:              33792K <span class="comment">#三级缓存 缓存速度上 L1 &gt; L2 &gt; L3 &gt; DDR(内存)</span></span><br><span class="line">NUMA node0 CPU(s):     0,1</span><br><span class="line">Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat umip pku ospke avx512_vnni spec_ctrl</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpuinfo</title>
      <link href="/posts/f7ef0533.html"/>
      <url>/posts/f7ef0533.html</url>
      
        <content type="html"><![CDATA[<h1>linux查看cpu信息的方式</h1><ul><li>使用命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure><ul><li>查看文件<br>cpuinfo这个文件的输出行数是非常多的,取决于机器cpu的数量配置,对于服务器来说输出可能几百行,但大部分的都是重复的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><h1>cpuinfo示例</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">processor: 0</span><br><span class="line">vendor_id: GenuineIntel</span><br><span class="line">cpu family: 6</span><br><span class="line">model: 85</span><br><span class="line">model name: Intel(R) Xeon(R) Gold 6271C CPU @ 2.60GHz</span><br><span class="line">stepping: 7</span><br><span class="line">microcode: 0x1</span><br><span class="line">cpu MHz: 2593.906</span><br><span class="line">cache size: 33792 KB</span><br><span class="line">physical id: 0</span><br><span class="line">siblings: 2</span><br><span class="line">core id: 0</span><br><span class="line">cpu cores: 1</span><br><span class="line">apicid: 0</span><br><span class="line">initial apicid: 0</span><br><span class="line">fpu: yes</span><br><span class="line">fpu_exception: yes</span><br><span class="line">cpuid level: 13</span><br><span class="line">wp: yes</span><br><span class="line">flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat umip pku ospke avx512_vnni spec_ctrl</span><br><span class="line">bogomips: 5187.81</span><br><span class="line">clflush size: 64</span><br><span class="line">cache_alignment: 64</span><br><span class="line">address sizes: 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br><span class="line"></span><br><span class="line">processor: 1</span><br><span class="line">vendor_id: GenuineIntel</span><br><span class="line">cpu family: 6</span><br><span class="line">model: 85</span><br><span class="line">model name: Intel(R) Xeon(R) Gold 6271C CPU @ 2.60GHz</span><br><span class="line">stepping: 7</span><br><span class="line">microcode: 0x1</span><br><span class="line">cpu MHz: 2593.906</span><br><span class="line">cache size: 33792 KB</span><br><span class="line">physical id: 0</span><br><span class="line">siblings: 2</span><br><span class="line">core id: 0</span><br><span class="line">cpu cores: 1</span><br><span class="line">apicid: 1</span><br><span class="line">initial apicid: 1</span><br><span class="line">fpu: yes</span><br><span class="line">fpu_exception: yes</span><br><span class="line">cpuid level: 13</span><br><span class="line">wp: yes</span><br><span class="line">flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat umip pku ospke avx512_vnni spec_ctrl</span><br><span class="line">bogomips: 5187.81</span><br><span class="line">clflush size: 64</span><br><span class="line">cache_alignment: 64</span><br><span class="line">address sizes: 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br></pre></td></tr></table></figure><h1>字符解释</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">processor: 0 <span class="comment">#系统中逻辑处理核心数的编号，从0开始排序</span></span><br><span class="line">vendor_id: GenuineIntel <span class="comment">#CPU制造商</span></span><br><span class="line">cpu family: 6 <span class="comment">#CPU产品系列代号</span></span><br><span class="line">model: 85 <span class="comment">#CPU属于其系列中的哪一代的代号</span></span><br><span class="line">model name: Intel(R) Xeon(R) Gold 6271C CPU @ 2.60GHz <span class="comment">#CPU属于的名字及其编号、标称主频</span></span><br><span class="line">stepping: 7 <span class="comment">#CPU属于制作更新版本</span></span><br><span class="line">microcode: 0x1 <span class="comment">#CPU微代码</span></span><br><span class="line">cpu MHz: 2593.906 <span class="comment">#CPU的实际使用主频</span></span><br><span class="line">cache size: 33792 KB <span class="comment">#CPU二级缓存大小</span></span><br><span class="line">physical id: 0 <span class="comment">#单个物理CPU的标号</span></span><br><span class="line">siblings: 2 <span class="comment">#单个物理CPU的逻辑CPU数。siblings=cpu cores [*2]</span></span><br><span class="line">core id: 0 <span class="comment">#当前物理核在其所处CPU中的编号，这个编号不一定连续</span></span><br><span class="line">cpu cores: 1 <span class="comment">#该逻辑核所处CPU的物理核数。比如此处cpu cores 是4个，那么对应core id 可能是 1、3、4、5</span></span><br><span class="line">apicid: 0 <span class="comment">#用来区分不同逻辑核的编号，系统中每个逻辑核的此编号必然不同，此编号不一定连续</span></span><br><span class="line">initial apicid: 0 <span class="comment">#我不知道</span></span><br><span class="line">fpu: yes <span class="comment">#是否具有浮点运算单元</span></span><br><span class="line">fpu_exception: yes <span class="comment">#是否支持浮点计算异常</span></span><br><span class="line">cpuid level: 13 <span class="comment">#执行cpuid指令前，eax寄存器中的值，根据不同的值cpuid指令会返回不同的内容</span></span><br><span class="line">wp: yes <span class="comment">#表明当前CPU是否在内核态支持对用户空间的写保护</span></span><br><span class="line">flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat umip pku ospke avx512_vnni spec_ctrl <span class="comment">#当前CPU支持的功能</span></span><br><span class="line">bogomips: 5187.81 <span class="comment">#在系统内核启动时粗略测算的CPU速度</span></span><br><span class="line">clflush size: 64 <span class="comment">#每次刷新缓存的大小单位</span></span><br><span class="line">cache_alignment: 64 <span class="comment">#缓存地址对齐单位</span></span><br><span class="line">address sizes: 46 bits physical, 48 bits virtual <span class="comment">#可访问地址空间位数</span></span><br><span class="line">power management: <span class="comment">#对能源管理的支持</span></span><br></pre></td></tr></table></figure><h1>cpu数量的计算</h1><ul><li>物理CPU数(physical id)<br>就是处理器的实际数量,一颗还是两颗(你肉眼看得见的那个)</li><li>CPU核心数(cpu cores)<br>单块CPU上面能处理数据的芯片组的数量，如双核、四核等</li><li>计算<br>总核数 = 物理CPU个数 * 每颗物理CPU的核数<br>总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 配置解释 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置解释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lvm操作</title>
      <link href="/posts/93b16f73.html"/>
      <url>/posts/93b16f73.html</url>
      
        <content type="html"><![CDATA[<h1>lvm是什么</h1><p>想要随着实际需求的变化调整硬盘分区的大小时，会受到硬盘的限制。这时就需要用到另外一项非常普及的硬盘设备资源管理技术了—LVM（逻辑卷管理器）,LVM 可以允许用户对硬盘资源进行动态调整,LVM 技术是在硬盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行卷组合并,用户不必关心物理硬盘设备的低层架构和布局，就可以实现对硬盘分区的动态调整</p><h1>几个概念</h1><ul><li>物理卷<br>PV(Physical Volume)是LVM的最底层概念</li><li>卷组<br>VG(Volume Group)是LVM概念上的磁盘设备,通过将单个或者多个物理卷组合生成卷组,卷组的大小又物理卷的容量和个数决定</li><li>物理长度<br>PE(Physical Extent)是将物理卷组成卷组之后划分的最小存储单位,默认大小是4MB</li><li>逻辑卷<br>LV(Logical Volume)是逻辑意义上的分区,可以指定从卷组中提取多少容量来创建逻辑卷并格式化和挂载</li></ul><h1>创建LVM分区</h1><h2 id="创建之前首先要查看磁盘设备">创建之前首先要查看磁盘设备</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk  </span><br></pre></td></tr></table></figure><p>可以看到如下,其中sdb是新插入的磁盘</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME              MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda                 8:0    0   30G  0 disk </span><br><span class="line">├─sda1              8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2              8:2    0   29G  0 part </span><br><span class="line">  ├─kylinsec-root 253:0    0   26G  0 lvm  /</span><br><span class="line">  └─kylinsec-swap 253:1    0    3G  0 lvm  <span class="section">[SWAP]</span></span><br><span class="line">sdb                 8:16   0    1G  0 disk </span><br><span class="line">sr0                11:0    1 1024M  0 rom  </span><br></pre></td></tr></table></figure><h2 id="创建物理卷">创建物理卷</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/sdb</span><br></pre></td></tr></table></figure><h2 id="创建卷组">创建卷组</h2><p>使用sdb硬盘,创建出一块名为<code>test_vg</code>的卷组设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgcreate test_vg /dev/sdb</span><br></pre></td></tr></table></figure><h2 id="创建逻辑卷">创建逻辑卷</h2><p>在已有的卷组中（test_vg）创建一个逻辑卷（home_nice），大小为400M</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvcreate  -n  home_kylin -L 400M  test_vg</span><br></pre></td></tr></table></figure><p>如果需要使用所有的空间可以这么写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvcreate  -n  home_kylin -l +100%FREE  test_vg</span><br></pre></td></tr></table></figure><h2 id="格式化逻辑卷">格式化逻辑卷</h2><p>首先需要获取逻辑卷的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -p</span><br></pre></td></tr></table></figure><p>其中<code>/dev/mapper/test_vg-home_kylin</code>是刚创建的逻辑卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lsblk -p的信息</span> </span><br><span class="line">NAME                            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">/dev/sda                          8:0    0   30G  0 disk </span><br><span class="line">├─/dev/sda1                       8:1    0    1G  0 part /boot</span><br><span class="line">└─/dev/sda2                       8:2    0   29G  0 part </span><br><span class="line">  ├─/dev/mapper/kylinsec-root   253:0    0   26G  0 lvm  /</span><br><span class="line">  └─/dev/mapper/kylinsec-swap   253:1    0    3G  0 lvm  [SWAP]</span><br><span class="line">/dev/sdb                          8:16   0    1G  0 disk </span><br><span class="line">└─/dev/mapper/test_vg-home_kylin 253:2    0  400M  0 lvm  </span><br><span class="line">/dev/sr0                         11:0    1 1024M  0 rom  </span><br></pre></td></tr></table></figure><h2 id="使用mkfs进行格式化">使用mkfs进行格式化</h2><p>示例中使用的是ext4文件系统,还可以选择xfs等其他文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/mapper/test_vg-home_kylin</span><br></pre></td></tr></table></figure><h2 id="挂载磁盘到系统">挂载磁盘到系统</h2><p>提供了2种方式,推荐使用<code>永久挂载</code>方式</p><h3 id="临时挂载磁盘">临时挂载磁盘</h3><h4 id="创建一个临时的目录">创建一个临时的目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/kylin</span><br></pre></td></tr></table></figure><h4 id="挂载逻辑卷">挂载逻辑卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/mapper/test_vg-home_kylin  /home/kylin</span><br></pre></td></tr></table></figure><h4 id="查看挂载信息">查看挂载信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -Th</span><br></pre></td></tr></table></figure><p>挂载的信息如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件系统                       容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/kylinsec-root       26G  7.0G   18G   29% /</span><br><span class="line">devtmpfs                       1.9G     0  1.9G    0% /dev</span><br><span class="line">tmpfs                          2.0G     0  2.0G    0% /dev/shm</span><br><span class="line">tmpfs                          2.0G   13M  2.0G    1% /run</span><br><span class="line">tmpfs                          2.0G     0  2.0G    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                      976M  198M  712M   22% /boot</span><br><span class="line">tmpfs                          393M   28K  393M    1% /run/user/0</span><br><span class="line">/dev/mapper/test_vg-home_kylin  380M  2.3M  354M    1% /home/data</span><br></pre></td></tr></table></figure><h3 id="将磁盘永久挂载到系统">将磁盘永久挂载到系统</h3><h4 id="修改-etc-fstab文件">修改/etc/fstab文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure><ul><li>方法1：使用路径挂载<br>在/etc/fstab最后加入,其中ext4是文件系统类型,需要和格式化(mkfs)时的保持一致</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/mapper/test_vg-home_kyin   /home/kylin        ext4    defaults        1 1</span><br></pre></td></tr></table></figure><ul><li>方法2：使用UUID挂载<br>使用blkid查看磁盘的UUID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid</span><br></pre></td></tr></table></figure><p>结果如下（只截取了需要的内容）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/mapper/test_vg-home_kylin: UUID=&quot;e98054f6-b74b-49fb-9c9d-04fd53c831b0&quot; TYPE=&quot;ext4&quot; </span><br></pre></td></tr></table></figure><p>将/dev/mapper/test_vg-home_kylin的UUID值加入就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=e98054f6-b74b-49fb-9c9d-04fd53c831b0   /        ext4    defaults        1 1</span><br></pre></td></tr></table></figure><p>验证fstab修改是否正确,如果已经临时挂载了,需要先将挂载的磁盘umount,才能验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a</span><br></pre></td></tr></table></figure><h1>删除lvm分区</h1><h2 id="卸载需要删除的分区">卸载需要删除的分区</h2><p>删除磁盘前需要确认已经umount，否则会失败,查看分区和挂载点信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><p>挂载点信息如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件系统                        容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/kylinsec-root        26G  7.1G   18G   30% /</span><br><span class="line">/dev/sda1                       976M  198M  712M   22% /boot</span><br><span class="line">/dev/mapper/test_vg-home_kylin  380M  2.3M  354M    1% /home/kylin</span><br></pre></td></tr></table></figure><p>首先需要卸载<code>/home/kylin</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /home/kylin</span><br></pre></td></tr></table></figure><h2 id="查看逻辑卷信息">查看逻辑卷信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvdisplay</span><br></pre></td></tr></table></figure><p>只截取了home_kylin的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--- Logical volume ---</span><br><span class="line">LV Path                /dev/test_vg/home_kylin</span><br><span class="line">LV Name                home_kylin</span><br><span class="line">VG Name                test_vg</span><br><span class="line">LV UUID                bA2Rjo-YS01-vTAd-Ze1f-DdwP-lvaf-ugZt7N</span><br><span class="line">LV Write Access        read/write</span><br><span class="line">LV Creation host, time ceshi, 2022-05-31 10:08:19 +0800</span><br><span class="line">LV Status              available</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">open                 1</span></span><br><span class="line">LV Size                400.00 MiB</span><br><span class="line">Current LE             100</span><br><span class="line">Segments               1</span><br><span class="line">Allocation             inherit</span><br><span class="line">Read ahead sectors     auto</span><br><span class="line">- currently set to     8192</span><br><span class="line">Block device           253:2</span><br></pre></td></tr></table></figure><h2 id="使用lvremove删除此分区">使用lvremove删除此分区</h2><p>lvremove 后面接的是LV Path对应的名字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvremove  /dev/test_vg/home_kylin</span><br></pre></td></tr></table></figure><p>确认/etc/fstab是否有相关的信息,将与这块磁盘的信息删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/fstab</span><br></pre></td></tr></table></figure><h1>对lvm分区扩容</h1><h2 id="查看空闲空间">查看空闲空间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgdisplay</span><br></pre></td></tr></table></figure><p>内容如下,可以看出Free PE有3839块，其中一块pe是4m，那么Free Pe的大小就是3839*4=15356m</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--- Volume group ---</span><br><span class="line"> VG Name               vg_test</span><br><span class="line"> System ID             </span><br><span class="line"> Format                lvm2</span><br><span class="line"> Metadata Areas        1</span><br><span class="line"> Metadata Sequence No  2</span><br><span class="line"> VG Access             read/write</span><br><span class="line"> VG Status             resizable</span><br><span class="line"> MAX LV                0</span><br><span class="line"> Cur LV                1</span><br><span class="line"> Open LV               1</span><br><span class="line"> Max PV                0</span><br><span class="line"> Cur PV                1</span><br><span class="line"> Act PV                1</span><br><span class="line"> VG Size               &lt;20.00 GiB</span><br><span class="line"> PE Size               4.00 MiB</span><br><span class="line"> Total PE              5119</span><br><span class="line"> Alloc PE / Size       1280 / 5.00 GiB</span><br><span class="line"> Free  PE / Size       3839 / &lt;15.00 GiB</span><br><span class="line"> VG UUID               GDHYHs-f1Yd-vmop-dLWR-VlRQ-h8ju-S5Tkr4</span><br></pre></td></tr></table></figure><h2 id="给vg卷组扩容">给vg卷组扩容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgextend vg_name /dev/sdb</span><br></pre></td></tr></table></figure><h2 id="给具体分区扩容">给具体分区扩容</h2><p>具体分区可以df -Th看出来</p><ul><li>扩指定大小容量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvextend -L +200M /dev/mapper/vg_home</span><br></pre></td></tr></table></figure><ul><li>也可以把所有的给他</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvextend -l +<span class="number">100</span>%FREE <span class="regexp">/dev/m</span>apper/vg_home</span><br></pre></td></tr></table></figure><h1>对lvm分区缩小容量(不建议)</h1>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之git</title>
      <link href="/posts/1dd2999d.html"/>
      <url>/posts/1dd2999d.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理,也是Linus Torvalds(大佬)为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件#</p><h1>先说一个坑</h1><p>千万不要用windows来开发shell脚本,就算是要开发也要用好空格(LF),不然到linux就是会报错的,所以用git的时候会将你的代码上传到云端的库,这样别人用的时候要是遇到这个坑心态可能崩溃</p><h1>开局操作</h1><h2 id="个人信息">个人信息</h2><p>接下来要和平台进行联动,所以要配置一下自己的信息,才能代表你是你</p><ul><li>用户名</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;dddachui&quot;</span><br></pre></td></tr></table></figure><ul><li>email</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;xx@xx.com&quot;</span><br></pre></td></tr></table></figure><h2 id="查看配置">查看配置</h2><ul><li>查看当前配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><ul><li>查看全局配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list --global</span><br></pre></td></tr></table></figure><ul><li>查看系统配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure><h1>正常开局方法</h1><h2 id="初始化仓库">初始化仓库</h2><p>可以用git创建出一个目录，也可以使用一个现有的文件夹做为repo</p><ul><li>指定一个目录作为仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init newrepo  </span><br></pre></td></tr></table></figure><ul><li>又或者是在当前目录下初始化</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">init</span></span><br></pre></td></tr></table></figure><h2 id="添加新文件">添加新文件</h2><p>在仓库编辑保存之后git就会跟踪,此时要把文件提交暂存区,一般是不会输出什么的,不输出就是好事</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add filename</span><br></pre></td></tr></table></figure><h2 id="提交版本">提交版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;写点注释划划水&quot;</span><br></pre></td></tr></table></figure><h2 id="和远端仓库玩耍">和远端仓库玩耍</h2><ul><li>设置远端仓库地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin http://ip:port/username/项目</span><br></pre></td></tr></table></figure><ul><li>推送</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="克隆仓库">克隆仓库</h2><p>一般用于将远端的项目拉到本地，或者你电脑坏了换了新的环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git_url</span><br></pre></td></tr></table></figure><h1>分支</h1><ul><li>查看当前分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><ul><li>创建分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br></pre></td></tr></table></figure><ul><li>切换分支</li></ul><pre><code class="language-shell">git branch test</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机容量换算</title>
      <link href="/posts/5cd3a7a8.html"/>
      <url>/posts/5cd3a7a8.html</url>
      
        <content type="html"><![CDATA[<h1>计算机的存储单位</h1><ul><li>bit 比特最小的存储单位</li><li>Byte 字节是计算机信息技术用于计量存储容量的一种计量单位</li><li>KB 千字节</li><li>MB 兆字节</li><li>GB gb也叫吉字节,十亿字节</li><li>TB 太字节</li><li>PB拍字节</li><li>EB 艾字节</li><li>ZB 泽字节</li><li>BB 尧字节</li></ul><h1>换算关系</h1><p>1Byte = 8 Bit<br>1 KB = 1,024 Bytes<br>1 MB = 1,024 KB = 1,048,576 Bytes<br>1 GB = 1,024 MB = 1,048,576 KB = 1,073,741,824 Bytes<br>1 TB = 1,024 GB = 1,048,576 MB = 1,073,741,824 KB = 1,099,511,627,776 Bytes<br>1 PB = 1,024 TB = 1,048,576 GB =1,125,899,906,842,624 Bytes<br>1 EB = 1,024 PB = 1,048,576 TB = 1,152,921,504,606,846,976 Bytes<br>1 ZB = 1,024 EB = 1,180,591,620,717,411,303,424 Bytes<br>1 YB = 1,024 ZB = 1,208,925,819,614,629,174,706,176 Bytes</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之free</title>
      <link href="/posts/9a6f4fde.html"/>
      <url>/posts/9a6f4fde.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>显示系统中可用和已用内存的量</p><h1>输出的结果</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        total       used        free        shared      buff/cache      available</span><br><span class="line">Mem:    1978        399         223          32         1355            1323</span><br><span class="line">Swap:   2047        0           2047</span><br></pre></td></tr></table></figure><h1>分析下每一列的含义</h1><h2 id="total">total</h2><p>是安装的总内存大小,MemTotal和SwapTotal可以在<code>/proc/meminfo</code>中查看</p><h2 id="used">used</h2><p>使用的内存大小</p><p>used=total - free - buffers - cache</p><h2 id="free">free</h2><p>没有使用的内存,Mem free和Swap free可以在<code>/proc/meminfo</code>中查看,真正尚未被使用的物理内存数量</p><h2 id="shared">shared</h2><p>表示进程共享的内存,大部分被tmpfs用了,在<code>/proc/meminfo</code>中查看Shmem</p><h2 id="buff">buff</h2><p>内核缓冲区使用的内存,在<code>/proc/meminfo</code>中查看Buffers</p><h2 id="cache">cache</h2><p>页面缓存和slabs使用的内存,在<code>/proc/meminfo</code>中查看Cached和Slab</p><h2 id="buff-cache">buff/cache</h2><p>buff+cacahe</p><h2 id="available">available</h2><p>估计有多少内存可用于<code>启动新应用程序</code>，而不进行交换,应用程序认为可用内存数量</p><p>available = free + buffer/cache - 不可被回收内存(共享内存段、tmpfs、ramfs等)。</p><h2 id="buffers-cache">-buffers/cache</h2><p>表示一个应用程序认为系统被用掉多少内存</p><p>-buffers/cache = used - buffers - cached</p><h2 id="buffers-cache-2">+buffers/cache</h2><p>表示一个应用程序认为系统还有多少内存；<br>+buffers/cache = free + buffers + cached</p><h1>混淆点</h1><h2 id="free和available应该看哪个">free和available应该看哪个</h2><p>Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache,所以对于内核来说，buffer 和 cache 都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，available = free + buffer + cache 这个计算不大可靠,但可以得出这两个是不一样的</p><h1>常用命令</h1><ul><li>free里面以不同单位显示换算是1024哦!</li></ul><h2 id="以Byte显示内存使用情况">以Byte显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -b</span><br></pre></td></tr></table></figure><h2 id="以kb为单位显示内存使用情况">以kb为单位显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -k</span><br></pre></td></tr></table></figure><h2 id="以mb为单位显示内存使用情况">以mb为单位显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><h2 id="以gb为单位显示内存使用情况">以gb为单位显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -g</span><br></pre></td></tr></table></figure><h2 id="持续显示内存">持续显示内存</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -s</span><br></pre></td></tr></table></figure><h2 id="显示内存使用总合">显示内存使用总合</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -t</span><br></pre></td></tr></table></figure><h2 id="以易读的单位显示内存使用情况">以易读的单位显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之md5sum</title>
      <link href="/posts/99132266.html"/>
      <url>/posts/99132266.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>md5sum计算并检查MD5消息摘要</p><h1>常用选项</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-b, --binary       以二进制模式读取文件</span><br><span class="line">-c, --check        从文件中读取MD5的校验值并予以检查</span><br><span class="line">-t, --text   以文本模式读入文件内容</span><br><span class="line">--quiet            只会输出校验不通过的文件</span><br><span class="line">--status           校验完成后，不生成错误或正确的提示信息，可以通过命令的返回值来判断echo $?</span><br><span class="line">--strict           对于格式不正确的校验和行，退出非零</span><br><span class="line">-w, --warn         检查输入的md5信息有没有非法行，若有则输出相应信息</span><br><span class="line">--help   显示此帮助信息并退出</span><br><span class="line">--version   显示版本信息并退出</span><br></pre></td></tr></table></figure><h1>基本用法</h1><h2 id="计算文件的md5">计算文件的md5</h2><p>直接计算文件的md5值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum 文件</span><br></pre></td></tr></table></figure><h2 id="利用md5文件校验">利用md5文件校验</h2><ul><li>计算文件的md5并写入文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum 文件 &gt; file.md5</span><br></pre></td></tr></table></figure><ul><li>使用文件校验<br>如果校验成功会提示,不成功的也会提示</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum -c file.md5</span><br></pre></td></tr></table></figure><h1>其他用法</h1><p>除了直接计算和指定md5文件之外还有其他选项</p><ul><li>计算的时候只输出不符合的文件</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum -c <span class="built_in">file</span>.md5  <span class="comment">--quiet</span></span><br></pre></td></tr></table></figure><ul><li>计算md5之后根据$?来判断是否正确<br>echo $?的返回值0或1</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum -c <span class="built_in">file</span>.md5  <span class="comment">--status</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之pssh</title>
      <link href="/posts/8cf6e4c0.html"/>
      <url>/posts/8cf6e4c0.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>pssh命令是一个python编写可以在多台服务器上执行命令的工具，同时文件的并行复制，杀掉远程主机上的进程等<br>要使用pssh之前,必须配置本地主机和被管理的远程主机之间ssh单向的免秘钥认证,这一点和ansible类似</p><h1>安装</h1><p>配置好软件源之后就可以安装这个工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pssh</span><br></pre></td></tr></table></figure><h1>命令使用</h1><p>安装完pssh之后默认有5个命令</p><ul><li>pssh 在多台远程主机上并行执行命令</li><li>pscp或pscp.pssh 把文件并行复制到多台远程主机上</li><li>pslurp 把文件从多台远程主机上复制到本地</li><li>pnuke 在多台远程主机上并行杀掉某一进程（类似于killall命令）</li><li>prsync 使用rsync协议将文件从本地主机同步到多台远程主机上</li></ul><h2 id="pssh">pssh</h2><p>在多台远程主机上并行执行命令</p><h3 id="常用参数">常用参数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  <span class="comment">--version             显示pssh程序的版本</span></span><br><span class="line">  <span class="comment">--help                显示ssh的命令帮助页面</span></span><br><span class="line">  <span class="operator">-</span>h HOST_FILE, <span class="comment">--hosts=HOST_FILE</span></span><br><span class="line">                        hosts file (每行这么写root<span class="variable">@192</span><span class="number">.168</span><span class="number">.42</span><span class="number">.10</span>:<span class="number">22</span>即[<span class="keyword">user</span>@]host[:port])</span><br><span class="line">  <span class="operator">-</span>H HOST_STRING, <span class="comment">--host=HOST_STRING</span></span><br><span class="line">                        主机字符串(root<span class="variable">@192</span><span class="number">.168</span><span class="number">.42</span><span class="number">.10</span>:<span class="number">22</span>即[<span class="keyword">user</span>@]host[:port])</span><br><span class="line">  <span class="operator">-</span>l <span class="keyword">USER</span>, <span class="comment">--user=USER  远程机器的用户名</span></span><br><span class="line">  <span class="operator">-</span>p PAR, <span class="comment">--par=PAR     一次最大允许多少连接</span></span><br><span class="line">  <span class="operator">-</span>o OUTDIR, <span class="comment">--outdir=OUTDIR</span></span><br><span class="line">                        将输出的内容保持到指定文件中</span><br><span class="line">  <span class="operator">-</span>e ERRDIR, <span class="comment">--errdir=ERRDIR</span></span><br><span class="line">                        错误文件的输出路径</span><br><span class="line">  <span class="operator">-</span>t TIMEOUT, <span class="comment">--timeout=TIMEOUT</span></span><br><span class="line">                        TIMEOUT 超时时间设置，<span class="number">0</span>是无限制</span><br><span class="line">  <span class="operator">-</span>O OPTION, <span class="comment">--option=OPTION</span></span><br><span class="line">                        设置ssh参数的具体配置，参照ssh_config配置文件</span><br><span class="line">  <span class="operator">-</span>v, <span class="comment">--verbose         详细模式</span></span><br><span class="line">  <span class="operator">-</span>A, <span class="comment">--askpass         提示输入密码并且把密码传递给ssh（注意这个参数添加后只是提示作用，随便输入或者不输入直接回车都可以）</span></span><br><span class="line">  <span class="operator">-</span>x ARGS, <span class="comment">--extra-args=ARGS</span></span><br><span class="line">                        传递多个SSH 命令，多个命令用空格分开，用引号括起来</span><br><span class="line">  <span class="operator">-</span>X ARG, <span class="comment">--extra-arg=ARG</span></span><br><span class="line">                        同<span class="operator">-</span>x 但是一次只能传递一个命令</span><br><span class="line">  <span class="operator">-</span>i, <span class="comment">--inline          显示命令执行的标准输出和错误输出</span></span><br><span class="line">  <span class="comment">--inline-stdout       inline standard output for each server</span></span><br><span class="line">  <span class="operator">-</span>I, <span class="comment">--send-input      从标准输入读取并作为输入发送到 ssh</span></span><br><span class="line">  <span class="operator">-</span>P, <span class="comment">--print           显示命令结果</span></span><br></pre></td></tr></table></figure><h3 id="操作单个主机">操作单个主机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -H root@yun -P uptime</span><br></pre></td></tr></table></figure><p>输入结果如下,会显示yun这个机器的执行结果,并反馈执行的状态</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:  21:26:50 up  6:56,  5 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line"><span class="section">[1]</span> 21:26:50 <span class="section">[SUCCESS]</span> 127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="操作多台主机">操作多台主机</h3><ul><li>首先编写host文件</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@node1:22</span><br><span class="line">root@node2:22</span><br></pre></td></tr></table></figure><ul><li>然后执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -h host -i uptime</span><br></pre></td></tr></table></figure><ul><li>执行结果</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[1]</span> 21:27:32 <span class="section">[SUCCESS]</span> 127.0.0.1</span><br><span class="line"> 21:27:32 up  6:57,  5 users,  load average: 0.08, 0.04, 0.05</span><br><span class="line"><span class="section">[2]</span> 21:27:32 <span class="section">[SUCCESS]</span> yun</span><br><span class="line"> 21:27:32 up 34 days,  7:47,  1 user,  load average: 0.03, 0.04, 0.05</span><br></pre></td></tr></table></figure><h3 id="保存每台运行的结果">保存每台运行的结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -h hosts -i -o /tmp/pssh/ uptime</span><br></pre></td></tr></table></figure><p>执行之后他会将每个主机的执行结果分别存入对应主机名的文件之中</p><h2 id="pscp或pscp-pssh">pscp或pscp.pssh</h2><p>把文件并行复制到多台远程主机上</p><h3 id="常用参数-2">常用参数</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  其他的解释和pssh一致,多了一个-r</span><br><span class="line">  -r, <span class="comment">--recursive       递归复制目录</span></span><br></pre></td></tr></table></figure><h3 id="同步单个文件到多个主机">同步单个文件到多个主机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pscp.pssh -h host /etc/hosts /etc</span><br></pre></td></tr></table></figure><h3 id="同步目录到多个主机">同步目录到多个主机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pscp -h host -r /usr/local/test  /tmp</span><br></pre></td></tr></table></figure><h2 id="pslurp">pslurp</h2><p>把文件并行复制到多台远程主机上</p><h3 id="常用参数-3">常用参数</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其他的解释和pssh一致</span><br><span class="line">-r, <span class="comment">--recursive       递归复制目录</span></span><br><span class="line">-L LOCALDIR, <span class="comment">--localdir=LOCALDIR</span></span><br><span class="line">                      将文件从远程主机复制到给定的本地目录</span><br></pre></td></tr></table></figure><h3 id="拷贝远端到本地">拷贝远端到本地</h3><p>将远端的/etc/hosts拷贝到本地/etc/并改名为hosts(不是很会,感觉会出问题)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pslurp -h host -L /etc/hosts /etc hosts</span><br></pre></td></tr></table></figure><h2 id="pnuke">pnuke</h2><p>在多台远程主机上并行杀掉某一进程（类似于killall命令）</p><h3 id="常用参数-4">常用参数</h3><p>和pssh一致</p><h3 id="杀死远程的nginx">杀死远程的nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnuke -h host nginx</span><br></pre></td></tr></table></figure><h2 id="prsync">prsync</h2><p>使用rsync协议将文件从本地主机同步到多台远程主机上</p><h3 id="常用参数-5">常用参数</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">其他解释一致</span><br><span class="line">-r, <span class="comment">--recursive       递归复制目录</span></span><br><span class="line">-<span class="keyword">a</span>, <span class="comment">--archive         use rsync -a (archive mode) (OPTIONAL)</span></span><br><span class="line">-z, <span class="comment">--compress        use rsync compression (OPTIONAL)</span></span><br><span class="line">-S ARGS, <span class="comment">--ssh-args=ARGS</span></span><br><span class="line">                      extra arguments <span class="keyword">for</span> ssh</span><br></pre></td></tr></table></figure><h3 id="传文件">传文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prsync -h host test.txt /tmp/dir</span><br></pre></td></tr></table></figure><h3 id="传目录">传目录</h3><p>这个得注意下目录…感觉和rsync差不多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prsync -r -h host /data/ /data</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bash和csh的区别</title>
      <link href="/posts/8ac16b70.html"/>
      <url>/posts/8ac16b70.html</url>
      
        <content type="html"><![CDATA[<h1>什么是shell</h1><p>shell是用户和Linux（或者更准确的说，是用户和Linux内核）之间的接口程序。你在提示符下输入的每个命令都由shell先解释然后传给Linux内核。</p><h1>shell的分类</h1><ul><li>sh<br>sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名,现代的 Linux 上，sh 已经被 bash 代替，/bin/sh往往是指向/bin/bash的符号链接</li><li>bash<br>bash 由 GNU 组织开发，保持了对 sh shell 的兼容性，是各种 Linux 发行版默认配置的 shell</li><li>csh<br>sh 之后另一个广为流传的shell是由柏克莱大学的Bill Joy设计的，这个shell 的语法有点类似C语言，所以才得名为C shell,简称为 csh,往往csh也是指向tcsh的链接符号</li><li>tcsh<br>tcsh 是 csh 的增强版，加入了命令补全功能，提供了更加强大的语法支持</li></ul><h1>查看本机支持的shell</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -l</span><br></pre></td></tr></table></figure><h1>查看当前使用的shell</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><h1>csh和bash的语法区别</h1><p>(这个会慢慢更新,区别有点多)</p><h2 id="环境变量定义">环境变量定义</h2><ul><li>bash定义</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=`pwd`                     # =号两边必须无空格,命令转变量也可以用$(pwd)</span><br><span class="line">export b=1                  # 设置环境变量</span><br></pre></td></tr></table></figure><ul><li>csh定义</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set a = `pwd`               # 用关键词 set， = 两边必须有空格,命令转变量只能用``</span><br><span class="line">setenv  b   1               # 设置环境变量</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之vmstat</title>
      <link href="/posts/4501ee1d.html"/>
      <url>/posts/4501ee1d.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之ulimit</title>
      <link href="/posts/4501ee1d.html"/>
      <url>/posts/4501ee1d.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>ulimit提供对shell和由它启动的进程可用的资源的控制。<code>ulimit</code>这个命令貌似是bash才可以用的,如果使用的是csh或者tcsh这个命令对应的是limit</p><blockquote><p>man手册:Provides control over the resources available to the shell and to processes started by it, on systems that allow such control.  The -H and -S options specify that the hard or soft limit is set for the given resource. A hard limit cannot be increased by a non-root user once it is set; a soft limit may be increased up to the value of the hard limit.  If neither -H nor -S is specified, both the soft and  hard  limits  are  set.   The  value  of limit can be a number in the unit specified for the resource or one of the special values hard, soft, or unlimited, which stand for the current hard limit, the current soft limit, and no limit, respectively. If limit is omitted, the current value of the soft limit of the resource is printed, unless the -H option is given.</p></blockquote><h1>注意</h1><ol><li>ulimit这个命令是对<code>单一程序</code>的限制,当前终端修改之后生效,但打开其他终端就还是默认的大小</li><li>ulimit主要限制的包括打开文件描述符数量、用户的最大进程数量、coredump文件的大小等,他是一个临时的开关,如果需要重启生效必须在limits.conf设置</li></ol><h1>如何查看当前系统限制</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@dddachui ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 15695</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 65535</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 15695</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><h1>首先分析下ulimit输出的参数是什么</h1><h2 id="core-file-size">core file size</h2><p>限制core文件的大小,默认情况下是0就是没有打开的,使用如下命令快速查看此配置,单位是blocks,一个blocks是1024个字节</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c size</span><br></pre></td></tr></table></figure><h2 id="data-seg-size">data seg size</h2><p>限制进程使用数据段的大小,这个限制会影响程序调用brk(系统调用)和sbrk(库函数)调用malloc,如果发现vm不够了,就会用brk去内核申请,一般不做限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -d size</span><br></pre></td></tr></table></figure><h2 id="scheduling-priority">scheduling priority</h2><p>限制进程优先级的,就是进程的NICE值,scheduling priority默认值为0,这个值只对<code>普通用户</code>起作用,对root用户不起作用,nice值的范围为-20到20,优先级从高到底,-20最高</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -e size</span><br></pre></td></tr></table></figure><h2 id="file-size">file size</h2><p>限制进程产生的文件大小,默认情况不限制,单位是blocks,1个blocks=1kb,如果设置了 100kb,那么将不n创建大于100KB的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -f size</span><br></pre></td></tr></table></figure><h2 id="pending-signals">pending signals</h2><p>主要是表示可以被挂起/阻塞的最大信号数量,linux下信号有64种,可以通过下面的kill查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@dddachui ~]# kill -l</span><br><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL10) SIGUSR1</span><br><span class="line">11) SIGSEGV12) SIGUSR213) SIGPIPE14) SIGALRM15) SIGTERM</span><br><span class="line">16) SIGSTKFLT17) SIGCHLD18) SIGCONT19) SIGSTOP20) SIGTSTP</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGURG24) SIGXCPU25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM27) SIGPROF28) SIGWINCH29) SIGIO30) SIGPWR</span><br><span class="line">31) SIGSYS34) SIGRTMIN35) SIGRTMIN+136) SIGRTMIN+237) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+439) SIGRTMIN+540) SIGRTMIN+641) SIGRTMIN+742) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+944) SIGRTMIN+1045) SIGRTMIN+1146) SIGRTMIN+1247) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+1449) SIGRTMIN+1550) SIGRTMAX-1451) SIGRTMAX-1352) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-1154) SIGRTMAX-1055) SIGRTMAX-956) SIGRTMAX-857) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-659) SIGRTMAX-560) SIGRTMAX-461) SIGRTMAX-362) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-164) SIGRTMAX</span><br></pre></td></tr></table></figure><p>编号为1-31的信号为传统unix支持的信号,是不可靠信号(非实时的),编号为32-64的信号是后来扩充的,称作可靠信号(实时信号)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -i size</span><br></pre></td></tr></table></figure><h2 id="max-locked-memory">max locked memory</h2><p>限制内存锁定,只对<code>普通用户</code>起作用,对root用户不起作用,linux对内存是分页管理的,内存中的数据,当不再需要时,会被从物理内存交换到swap或磁盘上,有需要时会被交换到物理内存,因为内存的换入/换出有一定的性能损耗,所以有时候会需要将数据锁定到物理内存,比如数据库等,或安全角度考虑的,比如用户名、密码等,被交换到swap或磁盘会有泄密的可能,所以一直锁定再内存中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -l size</span><br></pre></td></tr></table></figure><h2 id="max-memory-size">max memory size</h2><p>指定可使用内存的上限,单位为KB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -m size</span><br></pre></td></tr></table></figure><h2 id="open-files">open files</h2><p>打开的文件描述符的最大数量,这个值是针对<code>所有用户</code>的,表示可以在进程中打开文件的数量,默认是1024,但这个默认值太小,经常会遇到<code>Too many open files</code>的问题,但不能光顾着改大参数,还得检查程序是否正常释放资源,产生这个<code>Too many open files</code>问题大多是单进程使用文件句柄超过ulimit -n的值</p><h2 id="pipe-size">pipe size</h2><p>指定管道缓冲区的大小,单位512字节</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -p size</span><br></pre></td></tr></table></figure><h2 id="POSIX-message-queues">POSIX message queues</h2><p>限制可以创建使用POSIX消息队列的大小的,单位是bytes,默认是800KB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -q size</span><br></pre></td></tr></table></figure><h2 id="real-time-priority">real-time priority</h2><p>real-time priority是限制程序实时优先级的范围,只针对普通用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -r size</span><br></pre></td></tr></table></figure><h2 id="stack-size">stack size</h2><p>指定堆叠的上限,单位为KB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -s size</span><br></pre></td></tr></table></figure><h2 id="cpu-time">cpu time</h2><p>指定CPU使用时间的上限,单位为秒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -t size</span><br></pre></td></tr></table></figure><h2 id="max-user-processes">max user processes</h2><p>限制每个用户可以fork的进程数的,这里默认是不限的,而且该参数只对普通用户有效,这个参数影响并发,比如nginx、php-fpm的fork子进程,或者mysql的最大连接数,这个参数,默认情况下是根据系统的threads-max来定的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -u size</span><br></pre></td></tr></table></figure><h2 id="virtual-memory">virtual memory</h2><p>限制进程使用虚拟内存大小,单位是KB,默认是不限制的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -v size</span><br></pre></td></tr></table></figure><h2 id="file-locks">file locks</h2><p>文件锁的限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -x size</span><br></pre></td></tr></table></figure><h1>注意</h1><ol><li>修改时，若不加H或S参数，两个参数一起变改</li><li>查询时，若不加H或S参数，默认显示的是软限制</li></ol><h1>设置ulimit的位置</h1><p>可以在以下位置进行ulimit设置:</p><ol><li>/etc/profile 所有用户有效，永久生效</li><li>~/.bash_profile 当前用户有效，永久生效</li><li>直接在控制台输入 当前用户有效，临时生效</li><li>放在程序的启动脚本中</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux环境变量</title>
      <link href="/posts/289d0c5f.html"/>
      <url>/posts/289d0c5f.html</url>
      
        <content type="html"><![CDATA[<h1>环境变量</h1><p>在Linux登录成功以后，Linux会从文件中获取一系列的数据为该次登录所用，这些数据会在某些指令或某些程序中被使用到。这些数据就称为Linux Shell运行时的环境</p><h1>环境变量分类</h1><ul><li>系统变量<ol><li>/etc/bashrc</li><li>/etc/profile</li><li>/etc/environment</li></ol></li><li>用户变量<ol><li>~/.bashrc</li><li>~/.bash_profile</li></ol></li></ul><h1>测试Linux环境变量加载顺序的方法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;echo --/etc/profile&quot; &gt;&gt;/etc/profile</span><br><span class="line">echo &quot;echo --/etc/profile.d/echo.sh&quot; &gt;&gt;/etc/profile.d/echo.sh</span><br><span class="line">echo &quot;echo --~/.bash_profile&quot; &gt;&gt;~/.bash_profile</span><br><span class="line">echo &quot;echo --~/.bashrc&quot; &gt;&gt;~/.bashrc</span><br><span class="line">echo &quot;echo --/etc/bashrc&quot; &gt;&gt;/etc/bashrc</span><br></pre></td></tr></table></figure><p>然后ssh登陆到本机就会按序输出,这里没有写environment,但毋庸置疑的是environment是第一个加载的,但我不知道怎么表现<br>我的输出结果是</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--<span class="regexp">/etc/</span>profile.d/echo.sh</span><br><span class="line">--<span class="regexp">/etc/</span>profile</span><br><span class="line">--<span class="regexp">/etc/</span>bashrc</span><br><span class="line">--~/.bashrc</span><br><span class="line">--~/.bash_profile</span><br></pre></td></tr></table></figure><h1>环境变量加载顺序</h1><p>系统环境变量 -&gt; 用户自定义环境变量</p><ol><li>/etc/environment<br>是系统在登陆时读取的第一个文件，设置整个系统的环境变量。系统使用此文件并不执行此文件中的命令，而是根据Key=Value模式的代码</li><li>/etc/profile<br>此文件是系统登陆执行的第二个文件，为系统的每个用户设置环境信息。当用户第一次登陆时，该文件执行，并从/etc/profile.d目录中的配置文件搜索shell的设置</li><li>/etc/profile.d/*.sh</li><li>/etc/bashrc<br>这个文件是针对所有用户的bash初始化文件，在此设定中的环境信息将应用与所有用户的shell中，此文件会在用户每次打开shell时执行一次</li><li>~/.bash_profile<br>是交互式login方式进入 bash 运行的</li><li>~/.bashrc<br>该文件用于bash shell的bash信息，当登录时以及每次打开新的shell时，该文件被读取</li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>limits.conf配置</title>
      <link href="/posts/a53b52db.html"/>
      <url>/posts/a53b52db.html</url>
      
        <content type="html"><![CDATA[<h1>limits.conf是什么文件?</h1><blockquote><p>limits.conf - configuration file for the pam_limits module,The pam_limits.so module applies ulimit limits, nice priority and number of simultaneous login sessions limit to user login sessions. This description of the configuration file syntax applies to the /etc/security/limits.conf file and *.conf files in the /etc/security/limits.d directory</p></blockquote><ol><li>limits.conf是限制用户进程可用的各种系统资源的数量,限制着用户可以使用的最大文件数,最大线程,最大内存等资源使用量,但是这个文件不能删除的哦!删除了系统就崩了</li></ol><h1>查看官方文档的解释</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man limits.conf</span><br></pre></td></tr></table></figure><h1>相关名词解释</h1><ul><li>软限制<br>对进程的资源数的限制的当前值(当前系统生效的设置值,警告值),小于等于硬限制,软限制对进程并不是真正的限制,soft不能比hard高</li><li>硬限制<br>进程的资源数的限制的最大值,进程增长资源数不会超过硬限制</li></ul><h1>limits.conf文件组成</h1><p>文件内容由四列组成,如下解释</p><h2 id="domain">domain</h2><ul><li>用户名</li><li>具有@group的组名</li><li>通配符*,用于默认条目</li><li>通配符%,也可以与 %group 语法一起使用，用于 maxlogin 限制</li></ul><h2 id="type">type</h2><ul><li>soft软限制</li><li>hard硬限制</li><li>短杠-</li></ul><h2 id="item">item</h2><h3 id="core">core</h3><p>limits the core file size (KB) : 限制内核文件的大小</p><p>如果其值为 0，则阻止创建核心文件。默认软限制为 0，硬限制为无限制，这意味着允许用户在需要时创建核心转储</p><p>也是在内核include/asm-generic/resource.h中被定义的</p><h3 id="data">data</h3><p>max data size (KB) : 最大数据大小</p><h3 id="fsize">fsize</h3><p>maximum filesize (KB) : 最大文件大小</p><h3 id="memlock">memlock</h3><p>max locked-in-memory address space (KB) : 最大锁定内存地址空间</p><p>是内核include/uapi/linux/resource.h里面定义的,Memlock,进程可以使用mlock锁定内存的最大字节长度,本身在内核中定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * GPG2 wants 64kB of mlocked memory, to make sure pass phrases</span></span><br><span class="line"><span class="comment"> * and other sensitive information are never written to disk.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOCK_LIMIT((PAGE_SIZE &gt; 64*1024) ? PAGE_SIZE : 64*1024)</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u010692693/article/details/103270378">memlock的一篇分析</a></p><p>这个参数得配合 <code>/proc/pid/status</code>里面的VmLck来看</p><h3 id="nofile">nofile</h3><p>max number of open file descriptors : 最大打开的文件数(以文件描叙符)</p><p>nofile是设置<code>打开的文件描述符的最大数量</code>的参数,在include/uapi/linux/fs.h定义的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INR_OPEN_CUR 1024 <span class="comment">/* Initial setting for nfile rlimits */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INR_OPEN_MAX 4096 <span class="comment">/* Hard limit for nfile rlimits */</span></span></span><br></pre></td></tr></table></figure><p>可以看出nofile硬限制为4096，软限制为1024。软限制是默认值，允许用户增加此值，直到达到硬限制</p><h4 id="注意">注意</h4><p>如果给定系统的工作负载需要增加这些限制，请注意，它本身可以受到两个内核限制的限制</p><ul><li>fs.file-max : 它确定整个系统的最大文件句柄数。默认值为内核启动时可用内存页的最大值 8192 或可用内存页的十分之一</li><li>fs.nr_open : 这表示进程可以分配的最大文件句柄数。默认值为 1024*1024 （1048576）。在某些情况下，不能超过此值</li></ul><h3 id="rss">rss</h3><p>max resident set size (KB) : 最大持久设置大小</p><h3 id="stack">stack</h3><p>max stack size (KB) : 最大栈大小</p><p>stack是堆栈的意思,限制最大堆栈大小,也是内核include/uapi/linux/resource.h里面定义的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Limit the stack by to some sane default: root can always</span></span><br><span class="line"><span class="comment"> * increase this limit if needed..  8MB seems reasonable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STK_LIM(8*1024*1024)</span></span><br></pre></td></tr></table></figure><h3 id="cpu">cpu</h3><p>max CPU time (MIN) : 最多CPU占用时间，单位为MIN分钟</p><h3 id="nproc">nproc</h3><p>max number of processes : 进程的最大数目<br>nproc是限制每个用户创建进程数的,根的默认值总是变化的，取决于内核,内核的默认值取决于内存<br>此值是在kernel/fork.c定义的(内核源码…)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init_task.signal-&gt;rlim[RLIMIT_NPROC].rlim_cur = max_threads/<span class="number">2</span>;</span><br><span class="line">init_task.signal-&gt;rlim[RLIMIT_NPROC].rlim_max = max_threads/<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>也有更简便的计算 一般root显示的就是这个值,而非root用户是limits.conf和xx-nproc.conf定义的大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(($(cat /proc/sys/kernel/threads-max)/2))</span><br></pre></td></tr></table></figure><p>在rhel6和7上面,这个参数默认对root没有限制,他是从内核继承的,对于其他用户来说就4096,是根据下面的文件设定的</p><ul><li>CentOS6中limits.d下面是90-nproc.conf</li><li>CentOS7中limits.d下面是20-nproc.conf</li><li>CentOS8之后的都没有这个文件了,并且用户的默认值继承自内核</li></ul><h4 id="注意-2">注意</h4><p>limits.conf和xx-npoc.conf都有对nproc的定义,其实是pam_limits这个模块会先读入/etc/security/limits.conf，然后读入/etc/security/limits.d/下面的文件,这是对非root来说的!</p><h3 id="as">as</h3><p>address space limit (KB) : 地址空间限制</p><h3 id="maxlogins">maxlogins</h3><p>max number of logins for this user : 此用户允许登录的最大数目</p><h3 id="maxsyslogins">maxsyslogins</h3><p>max number of logins on the system : 系统最大同时在线用户数</p><h3 id="priority">priority</h3><p>the priority to run user process with : 运行用户进程的优先级</p><h3 id="locks">locks</h3><p>max number of file locks the user can hold : 用户可以持有的文件锁的最大数量</p><h3 id="sigpending">sigpending</h3><p>max number of pending signals : 最大待处理信号数(进程可以排队的最大信号数)</p><h3 id="msgqueue">msgqueue</h3><p>max memory used by POSIX message queues (bytes) :  POSIX 消息队列使用的最大内存</p><p>在内核include/uapi/linux/mqueue.h中被定义800 KiBytes</p><h3 id="nice">nice</h3><p>max nice priority allowed to raise to values: [-20, 19] max : nice优先级允许提升到值</p><h3 id="rtprio">rtprio</h3><p>max realtime pr iority  : 最大实时效率</p><h2 id="value">value</h2><p>大小,数量</p>]]></content>
      
      
      <categories>
          
          <category> 配置解释 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置解释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之gdb</title>
      <link href="/posts/5ca85281.html"/>
      <url>/posts/5ca85281.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>调试的</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之lspci</title>
      <link href="/posts/39261f34.html"/>
      <url>/posts/39261f34.html</url>
      
        <content type="html"><![CDATA[<h1>PCI</h1><p>PCI是一种外设总线规范,lspci则是用来显示系统中所有PCI总线设备或连接到该总线上的所有设备的工具</p><h1>简单用法</h1><h2 id="输出所有的pci设备">输出所有的pci设备</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci </span><br></pre></td></tr></table></figure><p>结果就是</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">00</span>:<span class="number">00</span>.<span class="number">0</span> Host bridge: Intel Corporation <span class="number">440</span>BX/ZX/DX - <span class="number">82443</span>BX/ZX/DX Host bridge (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">01</span>.<span class="number">0</span> PCI bridge: Intel Corporation <span class="number">440</span>BX/ZX/DX - <span class="number">82443</span>BX/ZX/DX AGP bridge (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">07</span>.<span class="number">0</span> ISA bridge: Intel Corporation <span class="number">82371</span>AB/EB/MB PIIX4 ISA (rev <span class="number">08</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">07</span>.<span class="number">1</span> IDE interface: Intel Corporation <span class="number">82371</span>AB/EB/MB PIIX4 IDE (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">07</span>.<span class="number">3</span> Bridge: Intel Corporation <span class="number">82371</span>AB/EB/MB PIIX4 ACPI (rev <span class="number">08</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">07</span>.<span class="number">7</span> System peripheral: VMware Virtual Machine Communication Interface (rev <span class="number">10</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">0</span>f.<span class="number">0</span> VGA compatible controller: VMware SVGA II Adapter</span><br><span class="line"><span class="attribute">00</span>:<span class="number">10</span>.<span class="number">0</span> SCSI storage controller: LSI Logic / Symbios Logic <span class="number">53</span>c1030 PCI-X Fusion-MPT Dual Ultra320 SCSI (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">11</span>.<span class="number">0</span> PCI bridge: VMware PCI bridge (rev <span class="number">02</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">02</span>:<span class="number">00</span>.<span class="number">0</span> USB controller: VMware USB1.<span class="number">1</span> UHCI Controller</span><br><span class="line"><span class="attribute">02</span>:<span class="number">01</span>.<span class="number">0</span> Ethernet controller: Intel Corporation <span class="number">82545</span>EM Gigabit Ethernet Controller (Copper) (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">02</span>:<span class="number">02</span>.<span class="number">0</span> Ethernet controller: Intel Corporation <span class="number">82545</span>EM Gigabit Ethernet Controller (Copper) (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">02</span>:<span class="number">04</span>.<span class="number">0</span> USB controller: VMware USB2 EHCI Controller</span><br></pre></td></tr></table></figure><p>(想不到这么长,其实在服务器更长)</p><h2 id="这些都是什么意思的呢">这些都是什么意思的呢?</h2><p>要想知道得看看<code>/proc/iomem</code>这个文件, /proc/iomem描述了系统中所有的设备I/O在内存地址空间上的映射<br>比如我截取了如下一段</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">c0000000</span>-c0007fff : <span class="number">0000</span>:<span class="number">00</span>:<span class="number">0</span>f.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这是一个PCI设备，c0000000-c0007fff是它所映射的内存地址空间，占据了内存地址空间的1024 bytes的位置，而 0000:00:0f.0则是一个PCI外设的地址,它以冒号和逗号分隔为4个部分，第一个16位表示域，第二个8位表示一个总线编号，第三个5位表示一 个设备号，最后是3位，表示功能号<br>由此再来看lspci的结果就不难看出<code>第一列</code>其实就是pci的描述,第二列型号信息,这部分太深奥了,不如自己百度吧</p><h1>查看指定的设备</h1><p>一般来说这个章节就是判断驱动有没有,没有的话怎么查找驱动过程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nn | grep -i eth # -nn 显示文本和数字ID</span><br></pre></td></tr></table></figure><p>输入如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">02</span>:<span class="number">01</span>.<span class="number">0</span> Ethernet controller<span class="meta"> [0200]: Intel Corporation 82545EM Gigabit Ethernet Controller (Copper) [8086:100f] (rev 01)</span></span><br></pre></td></tr></table></figure><p>只要关注如下几个地方</p><ul><li>02:01.0</li><li>Intel Corporation 82545EM Gigabit Ethernet Controller</li><li>8086:100f</li></ul><h2 id="按pci号展示信息">按pci号展示信息</h2><p>这里的02:01.0就是-nn输出的第一列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nvs 02:01.0</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">02:01.0 0200:</span> <span class="number">8086</span><span class="string">:100f</span> <span class="string">(rev</span> <span class="number">01</span><span class="string">)</span></span><br><span class="line"><span class="attr">Subsystem:</span> <span class="string">15ad:0750</span></span><br><span class="line"><span class="attr">Physical Slot:</span> <span class="number">33</span></span><br><span class="line"><span class="attr">Flags:</span> <span class="string">bus</span> <span class="string">master,</span> <span class="string">66MHz,</span> <span class="string">medium</span> <span class="string">devsel,</span> <span class="string">latency</span> <span class="number">0</span><span class="string">,</span> <span class="string">IRQ</span> <span class="number">19</span></span><br><span class="line"><span class="string">Memory</span> <span class="string">at</span> <span class="string">fd5c0000</span> <span class="string">(64-bit,</span> <span class="string">non-prefetchable)</span> [<span class="string">size=128K</span>]</span><br><span class="line"><span class="string">Memory</span> <span class="string">at</span> <span class="string">fdff0000</span> <span class="string">(64-bit,</span> <span class="string">non-prefetchable)</span> [<span class="string">size=64K</span>]</span><br><span class="line"><span class="string">I/O</span> <span class="string">ports</span> <span class="string">at</span> <span class="number">2000</span> [<span class="string">size=64</span>]</span><br><span class="line">[<span class="string">virtual</span>] <span class="string">Expansion</span> <span class="string">ROM</span> <span class="string">at</span> <span class="string">fd500000</span> [<span class="string">disabled</span>] [<span class="string">size=64K</span>]</span><br><span class="line"><span class="attr">Capabilities:</span> [<span class="string">dc</span>] <span class="string">Power</span> <span class="string">Management</span> <span class="string">version</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Capabilities:</span> [<span class="string">e4</span>] <span class="string">PCI-X</span> <span class="string">non-bridge</span> <span class="string">device</span></span><br><span class="line"><span class="attr">Kernel driver in use:</span> <span class="string">e1000</span></span><br><span class="line"><span class="attr">Kernel modules:</span> <span class="string">e1000</span></span><br></pre></td></tr></table></figure><p>在这里就只要看1点</p><ul><li>Kernel driver in use<br>这就是代表驱动有没打上</li></ul><h2 id="假设硬件名没有显示">假设硬件名没有显示</h2><p>可以登陆如下小网站查询</p><blockquote><p><a href="https://devicehunt.com/">https://devicehunt.com/</a></p></blockquote><p>这里就要用到8086:100f这个参数,8086就是厂商id,100f就是设备id,通过这个设备id就能查到这个硬件是什么,知道硬件之后就去对应的官网下载src编译,尤其是用在显卡方面比较多,因为不是每个系统版本都能默认识别到硬件,所以要自己查</p><h1>以树形结构显示</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci –t</span><br></pre></td></tr></table></figure><h1>展示系统中所有某个厂商的设备</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lspci</span> -nn -d <span class="number">8086</span>:</span><br></pre></td></tr></table></figure><h1>更新数据库</h1><p>新设备和供应商总是在不断迭代。如果看到显示为 unknown 的设备，说明你的 PCI 设备 ID 数据库可能已过时。有两种方法可以检查更新</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -<span class="selector-tag">Q</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防火墙firewalld</title>
      <link href="/posts/4791db89.html"/>
      <url>/posts/4791db89.html</url>
      
        <content type="html"><![CDATA[<p>(谁用啊,你用吗?)<br>(我瞎说的   )</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>增加swap分区</title>
      <link href="/posts/1ee8998b.html"/>
      <url>/posts/1ee8998b.html</url>
      
        <content type="html"><![CDATA[<h1>swap是干啥的</h1><p>Linux内核为了提高读写效率与速度，会将文件在内存中进行缓存，这部分内存就是Cache Memory(缓存内存)。即使你的程序运行结束后，Cache Memory也不会自动释放。这就会导致你在Linux系统中程序频繁读写文件后，你会发现可用物理内存变少。当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap空间中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行Swap交换</p><h1>swap的主要功能</h1><p>其实上面基本已经将swap的主要功能说了，这里再来重述一下：</p><ol><li>当物理内存不足的时候，将某些在内存中所占用的程序暂时移动到swap当中，让物理内存可以被需要的程序来使用；</li><li>Linux会将内存中不常访问的数据保存到swap中，当系统需要再次调用的时候，就把它从swap加载到内存；</li><li>如果你的主机支持电源管理模式，也就是说，你的Linux主机系统可以进入&quot;休眠&quot;模式的话，那么，运行当中的程序状态则会被记录到swap中去，以作为&quot;唤醒&quot;主机状态的依据；</li><li>在某些程序运行时，本来就会利用swap特性来存放一些数据，比如在装Oracle11g的时候会检查swap size；</li></ol><h1>有没有必要用swap</h1><p>先说结论:看情况(这和没说没啥区别…)</p><ol><li>数据库系统一般都对响应延迟比较敏感，如果使用swap代替内存，数据库服务性能必然不可接受</li><li>但是swap空间到底用不用，取决于应用软件需不需要,如LibreOffice在启动的过程中会使用大量的内存，但这些内存很多时候只是在启动的时候用一下，后面的运行过程中很少再用到这些内存</li><li>比如ubuntu的休眠功能依赖于swap分区，当系统休眠的时候，会将内存中的数据保存到swap分区上，等下次系统启动的时候，再将数据加载到内存中，这样可以加快系统的启动速度，所以如果要使用休眠的功能，必须要配置swap分区</li><li>在某些情况下，物理内存有限，但又想运行耗内存的程序,可以通过配置足够的swap空间来达到目标，虽然慢一点，但至少可以运行</li><li>swap是存放在磁盘上的，磁盘的速度和内存比较起来慢了好几个数量级，如果不停的读写swap，那么对系统的性能肯定有影响，尤其是当系统内存很吃紧的时候，读写swap空间发生的频率会很高，导致系统运行很慢</li></ol><h1>swap大小如何确定</h1><p>我找了redhat的帖子</p><ul><li>2G物理内存<br>两倍于已安装的内存,如果允许休眠，则建议交换空间3倍于内存量</li><li>2G~8G物理内存<br>相同数量的内存,如果允许休眠，则建议交换空间2倍于内存量</li><li>8G~64G物理内存<br>至少4G,如果允许休眠，则建议交换空间1.5倍于内存量</li><li>64G以上物理内存<br>至少4G,如果允许休眠，不建议休眠</li><li>140个逻辑处理器或者3T ram<br>建议至少 100GB 的交换空间</li></ul><h1>如何创建swap</h1><p>一般来说在装系统阶段就已经设置好swap了,如果当时没设置只能进系统设置,如果有新的磁盘可以拿磁盘做,如果没有就只能dd,如果要实现开机就有的话需要加入fstab</p><h2 id="磁盘做">磁盘做</h2><ul><li>分区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure><ul><li>格式化</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sdb1</span><br></pre></td></tr></table></figure><ul><li>激活swap</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon  /dev/sdb1</span><br></pre></td></tr></table></figure><ul><li>写入fstab<br>这边要注意,使用的是追加,不是重定向,小心清空了fstab</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/dev/sdb1  swap  swap    defaults   0    0&quot; &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure><h2 id="dd做">dd做</h2><ul><li>创建一块文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero  of=/root/swapfile bs=1M count=16384</span><br></pre></td></tr></table></figure><ul><li>制作swap文件系统</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /root/swapfile</span><br></pre></td></tr></table></figure><ul><li>激活swap</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /root/swapfile</span><br></pre></td></tr></table></figure><h1>swap管理</h1><h2 id="查看swap分区">查看swap分区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure><h2 id="取消激活swap">取消激活swap</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff /root/swapfile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘测速</title>
      <link href="/posts/9785dd0.html"/>
      <url>/posts/9785dd0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.cnblogs.com/sylar5/p/6649009.html">Linux 中用 dd 命令来测试硬盘读写速度 - Cyril_Wu - 博客园 (cnblogs.com)</a></p></blockquote><h1>注意</h1><p>读取的时候清空缓存，保证读取是从设备读取，而不是从内存读取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &quot;sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches&quot;</span><br></pre></td></tr></table></figure><h1>基本用法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time dd if=/dev/zero  of=/dev/null bs=block_size count=number_of_blocks</span><br></pre></td></tr></table></figure><h1>参数选项</h1><ul><li>选项<ul><li>if=file  ：从 file 中读而不是标准输入</li><li>of=file ：写到 file 里去而不是标准输出</li><li>bs=bytes ：一次读和写  bytes 字节</li><li>ibs=bytes ：一次读 bytes 字节。默认是512</li><li>obs=bytes ：一次写 bytes 字节。默认是512</li><li>count=blocks ： 仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数</li><li>iflag=FLAGS   ：指定读的方式FLAGS</li><li>oflag=FLAGS  ：指定写的方式FLAGS</li></ul></li><li>FLAGS如下<ul><li>direct　　　读写数据采用直接IO方式；</li><li>directory　读写失败除非是directory；</li><li>dsync　　　读写数据采用同步IO；</li><li>sync　　　　同上，但是针对是元数据</li><li>fullblock　　堆积满block(iflag only)；</li><li>nonblock　读写数据采用非阻塞IO方式</li><li>noatime　　 读写数据不更新访问时间</li></ul></li></ul><h1>磁盘写能力测试</h1><p>/dev/zero是一个伪设备，只产生空字符流，不会产生IO，IO都会集中在of文件中，所以这个命令是测试磁盘的写能力。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=test bs=8k count=10000 oflag=direct</span><br></pre></td></tr></table></figure><h1>读取能力测试</h1><p>/dev/sdb是一个物理分区，对它的读取会产生IO，/dev/null是伪设备，是黑洞，of到该设备不会产生IO，所以，这个命令的IO只发生在/dev/sdb上，也相当于测试磁盘的读能力</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=test of=/dev/null bs=8k count=10000 iflag=direct</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁盘管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fio测速</title>
      <link href="/posts/a448d86c.html"/>
      <url>/posts/a448d86c.html</url>
      
        <content type="html"><![CDATA[<h1>什么是fio</h1><p>磁盘IO是检查磁盘性能的重要指标,测试磁盘设备的性能的工具有很多,比如FIO,他是一个可以产生很多线程或进程并执行用户指定的特定类型I/O操作的工具，典型应用场景是编写和模拟的I/O负载匹配的作业文件</p><h1>fio用到的参数</h1><ul><li>filename=/dev/mapper/dbbak-dbdata<br>测试文件名称</li><li>direct=1<br>是否使用directIO，测试过程绕过OS自带的<code>buffer</code>,使测试磁盘的结果更真实。因为Linux读写的时候，内核维护了缓存，数据先写到缓存，后面再后台写到SSD。读的时候也优先读缓存里的数据。这样速度可以加快，但是一旦掉电缓存里的数据就没了。所以有一种模式叫做DirectIO，跳过缓存，直接读写SSD</li><li>rw=randwrite<br>测试随机写的I/O</li><li>rw=randrw<br>测试随机写和读的I/O</li><li>bs=16k<br>单次io的块文件大小为16k</li><li>bsrange=512-2048<br>同上，提定数据块的大小范围</li><li>size=5G<br>每个线程读写的数据量是5GB</li><li>numjobs=1<br>每个job（任务）开1个线程，这里用了几，后面每个用-name指定的任务就开几个线程测试。所以最终线程数=任务数（几个name=jobx）* numjobs。</li><li>name=test<br>一个任务的名字</li><li>thread<br>使用pthread_create创建线程，另一种是fork创建进程。进程的开销比线程要大，一般都采用thread测试。</li><li>runtime=1000<br>测试时间为1000秒，如果不写则一直将5g文件分4k每次写完为止。</li><li>ioengine=libaio<br>指定io引擎使用libaio方式<ul><li>libaio：Linux本地异步I/O</li><li>rbd:通过librbd直接访问CEPH Rados</li></ul></li><li>iodepth=16<br>队列深度为16,如果SSD执行读写如果发生了卡顿，那有可能系统会一直不停的发命令,这样一方面SSD扛不住,另一方面这么多命令会很占内存，系统也要挂掉了</li><li>Block Devices(RBD)<br>无需使用内核RBD驱动程序(rbd.ko)</li><li>rwmixwrite=30<br>在混合读写的模式下，写占30%</li><li>group_reporting<br>关于显示结果的，汇总每个进程的信息</li><li>lockmem=1g<br>只使用1g内存进行测试。</li><li>zero_buffers<br>用0初始化系统buffer。</li><li>nrfiles=8<br>每个进程生成文件的数量</li></ul><h1>2个用过的例子</h1><ul><li>测试随机读</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/mapper/dbbak-dbdata -direct=1 -iodepth=1 -rw=randread -ioengine=libaio -bs=32k -size=5G -numjobs=16 -group_reporting -name=test -output=hddrandreadtest</span><br></pre></td></tr></table></figure><ul><li>测试随机写</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/mapper/dbbak-dbdata -direct=1 -iodepth=1 -rw=randwrite -ioengine=libaio -bs=32k -size=5G -numjobs=16 -group_reporting -name=test -output=hddrandwritetest</span><br></pre></td></tr></table></figure><h1>fio结果解释</h1><p>(我也看不懂)</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fio测速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户被锁定</title>
      <link href="/posts/10c41d09.html"/>
      <url>/posts/10c41d09.html</url>
      
        <content type="html"><![CDATA[<h1>问题阐述</h1><p>用户密码输错多次被锁定了账户</p><h1>产生原因</h1><p>在一些系统通过pam模块设定了登陆限制之后,由于输入错了密码次数过多导致的</p><h1>解决方法</h1><p>只能通过root或者whell组的拥有高级权限的账户进行解锁,如果root都被锁定了只能进入单用户解锁次数,时间要是被锁定了可以通过耐心的等待</p><h2 id="解锁次数">解锁次数</h2><ul><li>查看用户登陆失败次数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pam_tally2 --user=用户名 </span><br></pre></td></tr></table></figure><ul><li>重置用户登陆失败次数为0</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pam_tally2 --user=用户名  --reset </span><br></pre></td></tr></table></figure><h2 id="解锁时间">解锁时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faillock   --user   用户名    --reset</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之ps</title>
      <link href="/posts/9202f4ae.html"/>
      <url>/posts/9202f4ae.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之screen</title>
      <link href="/posts/c9d4ad81.html"/>
      <url>/posts/c9d4ad81.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序,但也有其他用处</p><h1>创建screen实例</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure><h1>离开实例</h1><p>在 screen 终端 下 按下 Ctrl+a d键</p><h1>显示实例</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -ls</span><br></pre></td></tr></table></figure><h1>重新链接某个实例</h1><p>连接 screen_id 为 2276 的 screen终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r 2276</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之netstat</title>
      <link href="/posts/af020bcb.html"/>
      <url>/posts/af020bcb.html</url>
      
        <content type="html"><![CDATA[<h1>TCP连接状态详解</h1><ul><li>LISTEN：     侦听来自远方的TCP端口的连接请求</li><li>SYN-SENT：   再发送连接请求后等待匹配的连接请求</li><li>SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认</li><li>ESTABLISHED：代表一个打开的连接</li><li>FIN-WAIT-1： 等待远程TCP连接中断请求，或先前的连接中断请求的确认</li><li>FIN-WAIT-2： 从远程TCP等待连接中断请求</li><li>CLOSE-WAIT： 等待从本地用户发来的连接中断请求</li><li>CLOSING：    等待远程TCP对连接中断的确认</li><li>LAST-ACK：   等待原来的发向远程TCP的连接中断请求的确认</li><li>TIME-WAIT：  等待足够的时间以确保远程TCP接收到连接中断请求的确认</li><li>CLOSED：     没有任何连接状态</li></ul><h1>命令选项</h1><ul><li>-a或–all：显示所有连线中的Socket；</li><li>-A&lt;网络类型&gt;或–&lt;网络类型&gt;：列出该网络类型连线中的相关地址；</li><li>-c或–continuous：持续列出网络状态；</li><li>-C或–cache：显示路由器配置的快取信息；</li><li>-e或–extend：显示网络其他相关信息；</li><li>-F或–fib：显示FIB；</li><li>-g或–groups：显示多重广播功能群组组员名单；</li><li>-h或–help：在线帮助；</li><li>-i或–interfaces：显示网络界面信息表单；</li><li>-l或–listening：显示监控中的服务器的Socket；</li><li>-M或–masquerade：显示伪装的网络连线；</li><li>-n或–numeric：直接使用ip地址，而不通过域名服务器；</li><li>-N或–netlink或–symbolic：显示网络硬件外围设备的符号连接名称；</li><li>-o或–timers：显示计时器；</li><li>-p或–programs：显示正在使用Socket的程序识别码和程序名称；</li><li>-r或–route：显示Routing Table；</li><li>-s或–statistice：显示网络工作信息统计表；</li><li>-t或–tcp：显示TCP传输协议的连线状况；</li><li>-u或–udp：显示UDP传输协议的连线状况；</li><li>-v或–verbose：显示指令执行过程；</li><li>-V或–version：显示版本信息；</li><li>-w或–raw：显示RAW传输协议的连线状况；</li><li>-x或–unix：此参数的效果和指定&quot;-A unix&quot;参数相同；</li><li>–ip或–inet：此参数的效果和指定&quot;-A inet&quot;参数相同。</li></ul><h1>使用方法</h1><ul><li>列出所有端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a</span><br></pre></td></tr></table></figure><ul><li>列出所有TCP或UDP端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -at</span><br><span class="line">netstat -au</span><br></pre></td></tr></table></figure><ul><li>列出所有监听状态的端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出所有</span></span><br><span class="line">netstat -l</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出TCP</span></span><br><span class="line">netstat -lt </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出UDP</span></span><br><span class="line">netstat -lu</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出监听UNIX端口</span></span><br><span class="line">netstat -lx</span><br></pre></td></tr></table></figure><ul><li>显示端口的统计信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示所有端口的统计信息</span></span><br><span class="line">netstat -s</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示TCP端口的统计信息</span></span><br><span class="line">netstat -st</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示UDP端口的统计信息</span></span><br><span class="line">netstat -su</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在netstat输出中显示 PID 和进程名称</span></span><br><span class="line">netstat -pt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在netstat输出中不显示主机，端口和用户名(host, port or user)</span></span><br><span class="line">netstat -an</span><br></pre></td></tr></table></figure><ul><li>持续输出netstat信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -c</span><br></pre></td></tr></table></figure><ul><li>显示核心路由信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure><ul><li>使用netstat -rn显示数字格式，不查询主机名称</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -rn</span><br></pre></td></tr></table></figure><ul><li>找出程序用的端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp | grep ssh</span><br></pre></td></tr></table></figure><ul><li>找出运行在指定端口的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep &quot;:80&quot;</span><br></pre></td></tr></table></figure><ul><li>通过端口找进程ID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp | grep 80 | awk &#x27;&#123;print $7&#125;&#x27; | cut -d/ -f1</span><br></pre></td></tr></table></figure><ul><li>显示网络接口列表</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -i</span><br></pre></td></tr></table></figure><ul><li>统计TCP各种状态列表</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &#x27;/^tcp/&#123;++S[$NF]&#125;END&#123;for(i in S) print i,S[i]&#125;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之nload</title>
      <link href="/posts/af020bcb.html"/>
      <url>/posts/af020bcb.html</url>
      
        <content type="html"><![CDATA[<h1>使用</h1><p>查看实时网速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nload eth0 -u g -m </span><br></pre></td></tr></table></figure><h2 id="参数">参数</h2><ol><li>-a全部数据的刷新时间周期，单位是秒，默认是300s</li><li>-i进入网卡的流量图的显示比例最大值设置，默认10240 kBit/s</li><li>-m不显示流量图，只显示统计数据</li><li>-o出去网卡的流量图的显示比例最大值设置，默认10240 kBit/s</li><li>-t显示数据的刷新时间间隔，单位是毫秒，默认500ms</li><li>-u设置右边Curr、Avg、Min、Max的数据单位，默认是h自动变的.注意大小写单位不同！</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之lsof</title>
      <link href="/posts/97f67cbd.html"/>
      <url>/posts/97f67cbd.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>lsof是List Open Files(这个是man手册说的)的缩写,它主要用来获取被进程打开文件的信息,在Linux中,一切皆文件,lsof命令可以查看所有已经打开了的文件,文件含义如下</p><ol><li>普通文件</li><li>目录</li><li>网络文件系统的文件</li><li>字符或设备文件</li><li>(函数)共享库</li><li>管道,命名管道</li><li>符号链接</li><li>网络文件(例如:NFS file、网络socket,unix域名socket)</li><li>还有其它类型的文件,等等</li></ol><h1>lsof每一列解释</h1><ul><li>COMMAND : 进程名</li><li>PID : 进程ID</li><li>TID : 任务ID</li><li>USER : 所属用户</li><li>FD : 文件描述符<ul><li>cwd : 应用程序当前工作目录,这是该应用程序启动的目录,除非它本身对这个目录进行更改</li><li>txt : 该类型的文件是程序代码,如应用程序二进制文件本身或共享库,如上列表中显示的 /sbin/init 程序</li><li>lnn : 库引用（AIX）</li><li>err : FD 信息错误</li><li>jld : 监狱目录（FreeBSD）</li><li>ltx : 共享库文本（代码和数据）</li><li>mxx : 十六进制内存映射类型号 xx</li><li>m86 : DOS合并映射文件</li><li>mem : 内存映射文件</li><li>mmap : 内存映射设备</li><li>pd : 父目录</li><li>rtd : 根目录</li><li>tr : 内核跟踪文件（OpenBSD）</li><li>v86 : VP/ix 映射文件</li><li>0 : 标准输出</li><li>1 : 标准输入</li><li>2 : 标准错误</li><li>r : 只读</li><li>w : 写入</li><li>u : 读写</li><li>空格 : 文件状态模式是unknow没锁定</li><li>短杠 : 文件状态模式是unknow且锁定</li></ul></li><li>TYPE : 文件类型,大致类型如下<ul><li>REG : 普通文件</li><li>DIR : 表示目录</li><li>CHR : 表示字符类型</li><li>BLK : 块设备类型</li><li>UNIX : UNIX 域套接字</li><li>FIFO : 先进先出队列</li><li>IPv4 : IPv4 套接字</li></ul></li><li>DEVICE : 磁盘名称</li><li>SIZE/OFF : 以字节为单位的文件的大小或文件偏移量</li><li>NODE : 索引节点</li><li>NAME : 打开文件的确切名称</li></ul><h1>用法</h1><h2 id="列出所有打开的文件">列出所有打开的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br></pre></td></tr></table></figure><h2 id="列出所有打开的文件分页显示">列出所有打开的文件分页显示</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof | more</span><br></pre></td></tr></table></figure><h2 id="查看某个特定的文件谁在用">查看某个特定的文件谁在用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /var/log/messages</span><br></pre></td></tr></table></figure><h2 id="显示指定进程打开的文件">显示指定进程打开的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsoc -c sshd</span><br></pre></td></tr></table></figure><h2 id="显示指定进程号打开的文件">显示指定进程号打开的文件</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -p <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="监听协议-端口等">监听协议,端口等</h2><p>lsof -i [46] [protocol] [@hostname] [:service|port]</p><ul><li>显示所有的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure><ul><li>显示所有tcp网络连接进程信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp</span><br></pre></td></tr></table></figure><ul><li>显示端口是80 的进程信息<br>其实这边是省略了指定协议,所以会输出所有tcp和udp的,一般用于检查端口占用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :80</span><br></pre></td></tr></table></figure><ul><li>列出端口是1-1024的文件</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -i :<span class="number">1</span>-<span class="number">1024</span></span><br></pre></td></tr></table></figure><ul><li>显示同时满足tcp且端口是22的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:22</span><br></pre></td></tr></table></figure><ul><li>显示指定用户使用的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -u root</span><br></pre></td></tr></table></figure><ul><li>显示除了某个用户之外其他用户打开的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -u ^root</span><br></pre></td></tr></table></figure><ul><li>显示所有socket文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -U</span><br></pre></td></tr></table></figure><ul><li>查看某个目录的文件信息<br>可以用于卸载磁盘时报&quot;device is busy&quot;</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /run/media/root/KylinSec</span><br></pre></td></tr></table></figure><ul><li>查看某个目录及子目录的文件信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof +D /root</span><br></pre></td></tr></table></figure><ul><li>找出打开着的但是已经被删除的文件</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof  grep deleted</span></span><br></pre></td></tr></table></figure><ul><li>列出ipv4/6的网络文件</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -i <span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE漏洞</title>
      <link href="/posts/1e0d49f9.html"/>
      <url>/posts/1e0d49f9.html</url>
      
        <content type="html"><![CDATA[<h1>CVE是什么</h1><p>CVE(Common Vulnerabilities and Exposures)的全称是公共漏洞和暴露，是公开的网络安全漏洞列表.<br>查阅CVE获取漏洞的详细信息，根据漏洞评分确定漏洞解决的优先级</p><h1>CVE号组成</h1><p>CVE编号是识别漏洞的唯一标识符,在CVE中，每个漏洞按CVE-1999-0067、CVE-2014-10001、CVE-2014-100001这样的形式编号,编号格式为&quot;CVE-年份-编号&quot;,可以在<a href="https://cve.mitre.org/">cve官网</a>找到,但不是所有漏洞都可以被录入CVE，主要根据如下规则判定是否为漏洞分配CVE编号：</p><ul><li>漏洞可独立修复，与其他漏洞没有耦合。</li><li>软件或硬件供应商承认此漏洞的存在或有书面公告。</li><li>漏洞只影响一个代码库，如果漏洞影响多个产品，则为每个产品独立分配CVE编号<br>如果可以分配编号则编写描述信息并发布到CVE网站。每个CVE条目主要包含以下信息：</li><li>描述：漏洞的来源、攻击方式等简要描述。</li><li>参考：漏洞的相关参考信息链接汇总，例如供应商的漏洞公告、紧急响应建议等。</li><li>发布的CNA：发布此CVE的CNA。</li><li>发布日期：此CVE的发布日期。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之rpm</title>
      <link href="/posts/f854f9de.html"/>
      <url>/posts/f854f9de.html</url>
      
        <content type="html"><![CDATA[<h1>安装</h1><h2 id="安装软件包">安装软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh xx.rpm</span><br></pre></td></tr></table></figure><h2 id="安装忽略依赖">安装忽略依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh xxx.rpm --nodeps </span><br></pre></td></tr></table></figure><h2 id="测试安装xx软件包">测试安装xx软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh --test xxx.rpm</span><br></pre></td></tr></table></figure><h1>卸载</h1><h2 id="卸载软件包">卸载软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e xxx</span><br></pre></td></tr></table></figure><h2 id="卸载软件包忽略依赖">卸载软件包忽略依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e xxx --nodeps</span><br></pre></td></tr></table></figure><h1>查询</h1><h2 id="查询一个软件是否安装">查询一个软件是否安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q openssh</span><br></pre></td></tr></table></figure><h2 id="查询软件包是否安装">查询软件包是否安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qpi telnet-0.17-48.kb2.ky3.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="查看已经安装的软件包">查看已经安装的软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa  </span><br></pre></td></tr></table></figure><h2 id="显示xxx功能、文件、目录是哪个软件包提供的">显示xxx功能、文件、目录是哪个软件包提供的</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf  &#x27;which ssh&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf  /opt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf /etc/ntp.conf</span><br></pre></td></tr></table></figure><h2 id="显示包的更改记录">显示包的更改记录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q --changelog ntp-4.2.8p15-28.ky3.kb5.x86_64</span><br></pre></td></tr></table></figure><h2 id="查询包的依赖关系">查询包的依赖关系</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qR ntp-4.2.8p15-28.ky3.kb5.x86_64</span><br></pre></td></tr></table></figure><h2 id="显示包的信息">显示包的信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -V pkg_name</span><br></pre></td></tr></table></figure><h2 id="查看包的详细信息">查看包的详细信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi pkg_name</span><br></pre></td></tr></table></figure><h2 id="查看包提供的文档">查看包提供的文档</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qd pkg_name</span><br></pre></td></tr></table></figure><h2 id="查看软件包的配置文件">查看软件包的配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qc pkg_name</span><br></pre></td></tr></table></figure><h2 id="查看一个软件包的安装的文件">查看一个软件包的安装的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql pkg_name</span><br></pre></td></tr></table></figure><h2 id="检查所有的rpm是否遗漏配置">检查所有的rpm是否遗漏配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Va</span><br></pre></td></tr></table></figure><h2 id="数字签名校验rpm包是否被篡改">数字签名校验rpm包是否被篡改</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">rpm</span> <span class="operator">-</span><span class="built_in">K</span> <span class="variable">xxx</span><span class="operator">.</span><span class="variable">rpm</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/LiuYanYGZ/p/9435708.html">https://www.cnblogs.com/LiuYanYGZ/p/9435708.html</a></p></blockquote><h1>升级降级</h1><h2 id="升级包">升级包</h2><p>删除旧包再装新包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh pkg_name</span><br></pre></td></tr></table></figure><h2 id="升级包-2">升级包</h2><p>在旧版本的基础上安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Fvh pkg_name</span><br></pre></td></tr></table></figure><h2 id="降级包">降级包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh pkg_name --oldpackage</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置yum源</title>
      <link href="/posts/288d0611.html"/>
      <url>/posts/288d0611.html</url>
      
        <content type="html"><![CDATA[<h1>前置要求</h1><p>配置好网络,因为软件源可以搭建本地的,也可以使用公网镜像站的,所以要求配置网络</p><h1>寻找加速站点</h1><p>默认的源指向的是centos的官网,在国内访问的速度并不是很可观,所以可以使用一些国内的镜像站作为加速,我有一篇帖子收集了一些国内的镜像站<br>这里以<a href="https://mirrors.ustc.edu.cn/">中国科学技术大学开源软件镜像站</a>为例子,是我经常用的站点</p><h1>配置基础源</h1><p>中国科学技术大学开源软件镜像站的<code>配置软件源</code>页面记录了大量软件源的配置方法,这里选到<a href="https://mirrors.ustc.edu.cn/help/centos.html">centos7配置页面</a>查看</p><h1>配置BASE源</h1><p>两种方法选一个就好了,推荐使用本地,因为大部分软件包在本地速度会快</p><ul><li>本地base<br>所谓的base就是iso文件里面的基础软件包,我们将iso挂载到机器,将baseurl指向iso挂载点即可<ul><li>挂载</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o loop xx.iso /mnt</span><br></pre></td></tr></table></figure><ul><li>修改repo</li></ul>  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Base]</span></span><br><span class="line"><span class="attr">name</span>=CentOS-<span class="variable">$releasever</span> - Base</span><br><span class="line"><span class="attr">baseurl</span>=file:///mnt</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li>网络base<br>所谓的网络base就是镜像站点已经将iso挂载到一个页面了,我们只需将base指向一个网络地址<ul><li>修改repo</li></ul>  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Base]</span></span><br><span class="line"><span class="attr">name</span>=CentOS-<span class="variable">$releasever</span> - Base</span><br><span class="line"><span class="attr">baseurl</span>=https://mirrors.ustc.edu.cn/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><h1>更新元数据</h1><ul><li>清空</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean <span class="keyword">all</span></span><br></pre></td></tr></table></figure><ul><li>缓存</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum makecache</span></span><br></pre></td></tr></table></figure><h1>配置epel源</h1><p>EPEL是由Fedora为企业Linux创建、维护和管理的一个高质量附加包集合</p><ul><li>安装epel-release<br>实质上主要就是提供了一个repo文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><ul><li>修改repo地址<br>利用sed命令替换其中的网址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;s|^metalink=|#metalink=|g&#x27; \</span><br><span class="line">         -e &#x27;s|^#baseurl=https\?://download.fedoraproject.org/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g&#x27; \</span><br><span class="line">         -e &#x27;s|^#baseurl=https\?://download.example/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g&#x27; \</span><br><span class="line">         -i.bak \</span><br><span class="line">         /etc/yum.repos.d/epel.repo</span><br></pre></td></tr></table></figure><ul><li>repo最后的内容</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[epel]</span></span><br><span class="line"><span class="attr">name</span>=Extra Packages for Enterprise Linux <span class="number">7</span> - <span class="variable">$basearch</span></span><br><span class="line"><span class="attr">baseurl</span>=https://mirrors.ustc.edu.cn/epel/<span class="number">7</span>/<span class="variable">$basearch</span></span><br><span class="line"><span class="attr">failovermethod</span>=priority</span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="section">[epel-debuginfo]</span></span><br><span class="line"><span class="attr">name</span>=Extra Packages for Enterprise Linux <span class="number">7</span> - <span class="variable">$basearch</span> - Debug</span><br><span class="line"><span class="attr">baseurl</span>=https://mirrors.ustc.edu.cn/epel/<span class="number">7</span>/<span class="variable">$basearch</span>/debug</span><br><span class="line"><span class="attr">failovermethod</span>=priority</span><br><span class="line"><span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-<span class="number">7</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="section">[epel-source]</span></span><br><span class="line"><span class="attr">name</span>=Extra Packages for Enterprise Linux <span class="number">7</span> - <span class="variable">$basearch</span> - Source</span><br><span class="line"><span class="attr">baseurl</span>=https://mirrors.ustc.edu.cn/epel/<span class="number">7</span>/SRPMS</span><br><span class="line"><span class="attr">failovermethod</span>=priority</span><br><span class="line"><span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-<span class="number">7</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>更新元数据<ul><li>清空</li></ul>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean <span class="keyword">all</span></span><br></pre></td></tr></table></figure><ul><li>缓存</li></ul>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum makecache</span></span><br></pre></td></tr></table></figure></li></ul><h1>总结</h1><p>大致的配置方法就这样,大多数站点的也就是前半段的地址不一样</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yum源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>镜像站合集</title>
      <link href="/posts/3789dae6.html"/>
      <url>/posts/3789dae6.html</url>
      
        <content type="html"><![CDATA[<h1>系统镜像站</h1><p>点击直达镜像站(排名无先后)<br><a href="https://www.centos.org/download/">centos.org官方站点</a><br><a href="https://vault.centos.org/">centos-valut站点</a><br><a href="https://mirrors.nju.edu.cn/">南京大学开源镜像站</a><br><a href="https://mirrors.ustc.edu.cn/">中国科学技术大学开源软件镜像站</a><br><a href="https://developer.aliyun.com/mirror/">阿里巴巴镜像站</a><br><a href="https://mirrors.huaweicloud.com/home">华为开源镜像站</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国内镜像站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之yum</title>
      <link href="/posts/8976e27a.html"/>
      <url>/posts/8976e27a.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>yum是包管理器,centos7以下都是用的yum,centos8以上都换成了dnf,由于yum的命令非常强大(学不会),这里只会简单的介绍基本用法</p><h1>前置要求</h1><blockquote><p>在使用yum命令之前需要配置yum源,yum源可以简单的理解为软件源</p></blockquote><h2 id="如何去学习这个命令的用法">如何去学习这个命令的用法</h2><p>看man手册或者使用–help(选项)查看相关资料</p><ul><li>使用man手册</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man yum</span><br></pre></td></tr></table></figure><ul><li>使用–help选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --help</span><br></pre></td></tr></table></figure><ul><li>使用yum的选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum help</span><br></pre></td></tr></table></figure><h2 id="yum的命令形式">yum的命令形式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package]</span><br></pre></td></tr></table></figure><h2 id="元数据">元数据</h2><p>玩yum之前需要先做好<code>元数据</code>,配置好repo文件之后就需要生成元数据,yum仓库的元数据由XML文件构成，包含了其他文件的校验（checksums）及所引用的包。</p><ul><li>清空yum缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure><ul><li>创建元数据缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h1>显示仓库</h1><p>用命令展示系统所配置的软件源</p><ul><li>显示所有源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist all</span><br></pre></td></tr></table></figure><ul><li>显示可用的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist enabled</span><br></pre></td></tr></table></figure><ul><li>显示禁止的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist disabled</span><br></pre></td></tr></table></figure><ul><li>显示当前激活的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist</span><br></pre></td></tr></table></figure><h1>列举软件包</h1><ul><li>显示源里面的所有的rpm包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list </span><br></pre></td></tr></table></figure><ul><li>列出本机安装的软件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed </span><br></pre></td></tr></table></figure><ul><li>列出yum源里面可以安装的包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list available</span><br></pre></td></tr></table></figure><ul><li>列出yum源里面可以更新的所有包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list updates</span><br></pre></td></tr></table></figure><h1>查询软件包</h1><p>search查询的结果是含有查询关键词的包名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search httpd</span><br></pre></td></tr></table></figure><h1>查询软件包的文件</h1><p>使用provides(或whatprovides)查询命令或者文件在哪个rpm包,很适合用于查询库文件或者单个命令所属包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum provides nginx</span><br></pre></td></tr></table></figure><h1>查看软件包组</h1><p>groups是软件包组,系统内集成了很多软件包组例如开发工具组,桌面组,可以实现一键安装某个组的所有软件</p><ul><li>列举groups软件组<br>用于显示软件包组,例如开发工具组,桌面组等</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groups list</span><br></pre></td></tr></table></figure><ul><li>查询group软件组的信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groups info &quot;Server with GUI&quot;</span><br></pre></td></tr></table></figure><h1>依赖问题</h1><p>rpm包之间的依赖是很头疼的</p><ul><li>列举bash软件包的依赖<br>会显示依赖什么文件,并且这些依赖在什么包里面,如果依赖都已经安装了,那么就可以单独安装该软件包,如果依赖缺失,就必须先安装依赖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum deplist bash</span><br></pre></td></tr></table></figure><h1>安装软件包</h1><ul><li>安装单个软件包<br>包名可以用search查询出来</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install 包名</span><br></pre></td></tr></table></figure><ul><li>安装软件组<br>例如直接安装开发工具,里面包括make,gcc,g++等</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groups install &quot;Development Tools&quot;</span><br></pre></td></tr></table></figure><h1>下载软件包</h1><p>在有些环境复杂的地方可能不能使用网络,所以需要将安装包下载导入到机器,可以使用yum的仅下载的选项或者yumdownloader命令实现,但需要解决好软件包的<code>依赖关系</code></p><ul><li>yum实现<ul><li>downloadonly是仅下载选项</li><li>downloaddir是指定下载位置</li><li>ansible是软件包的名字</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install --downloadonly --downloaddir=/root/ansible_rpms ansible -y</span><br></pre></td></tr></table></figure><ul><li>yumdownloader实现<ul><li>resolve是自动解决依赖</li><li>destdir是下载位置</li><li>ansible是软件包名</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumdownloader --resolve --destdir=/root/mypackages/ ansible</span><br></pre></td></tr></table></figure><h1>卸载软件包</h1><p>例如卸载openjdk 1.6版本,他会自动解决依赖关系,但是卸载的时候需要先看下哪些依赖被删除了</p><ul><li>remove</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove httpd</span><br></pre></td></tr></table></figure><ul><li>erase</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove httpd</span><br></pre></td></tr></table></figure><h1>查看yum操作历史记录</h1><p>查看 yum 事务信息，yum 是独占模式的进程，所以有时候查看事务信息还是有用的(有点高级没用会)</p><ul><li>查看 Yum 事务完整的历史记录<br>可以看见所有的yum操作历史</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum history </span><br></pre></td></tr></table></figure><ul><li>查看单独软件包的历史</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="built_in">history</span> info [事务<span class="built_in">id</span>或者包名]</span><br></pre></td></tr></table></figure><p>查看安装ansible的历史,可以看出:事务id,安装的包,作为依赖安装的包等</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> history <span class="literal">info</span> ansible</span><br></pre></td></tr></table></figure><ul><li>history子命令<br>history的子命令可以让我们撤销/重做/回滚事务<ul><li>undo:会撤销一个指定的事务</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum history undo 1</span><br></pre></td></tr></table></figure><ul><li>redo:重复一次指定的事务</li></ul>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> redo <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>rollback:撤销指定事务之后的所有事务</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum rollback 1</span><br></pre></td></tr></table></figure></li></ul><h1>更新</h1><ul><li>update<br>更新系统中的一个或多个软件包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h1>降级</h1><ul><li>downgrade<br>当包没有任何依赖关系时，降级是非常简单的,当使用这个命令产生了依赖关系的时候必须先降级依赖的版本</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> downgrade 包名</span><br></pre></td></tr></table></figure><h1>yum源属性配置</h1><p>可以用参数指定下载的源</p><ul><li>直接禁止仓库(直接)<ul><li>禁止仓库</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --disable epel</span><br></pre></td></tr></table></figure><ul><li>开启仓库</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --enable  epel </span><br></pre></td></tr></table></figure></li><li>使用选项指定  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd --enablerepo=base --disablerepo=yun</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装nvida显卡驱动</title>
      <link href="/posts/4ab62fe4.html"/>
      <url>/posts/4ab62fe4.html</url>
      
        <content type="html"><![CDATA[<h1>1.获取驱动文件</h1><ul><li>从英伟达官网下载对应显卡的驱动文件</li></ul><p><a href="http://www.nvidia.com">http://www.nvidia.com</a></p><h1>2.编辑Grub2将nouveau列入黑名单</h1><ul><li><p>编辑/etc/default/grub并将以下内容添加到grub_CMDLINE_LINUX行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe.blacklist=nouveau</span><br></pre></td></tr></table></figure></li><li><p>判断你的引导方式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -d  /sys/firmware/efi  ]  &amp;&amp;  echo UEFI  ||  echo  BIOS</span><br></pre></td></tr></table></figure><ul><li><p>重建grub配置并重新启动系统</p><ul><li><p>在BIOS-based的机器上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure></li><li><p>在UEFI-based的机器上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/efi/EFI/名字/grub.cfg</span><br></pre></td></tr></table></figure></li></ul></li><li><p>重启系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></li><li><p>重启验证nouveau是否存在,如果没东西输出才是对的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep -i nouveau</span><br></pre></td></tr></table></figure></li></ul><h1>3.安装显卡驱动</h1><ul><li><p>确保开发工具已经安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc make kernel-headers kernel-devel acpid libglvnd-glx libglvnd-</span><br><span class="line">opengl libglvnd-devel pkgconfig</span><br></pre></td></tr></table></figure></li><li><p>在X server服务运行的时候是无法成功安装驱动的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 3</span><br></pre></td></tr></table></figure></li><li><p>安装显卡驱动，遇到yes选yes就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh nvida.run</span><br></pre></td></tr></table></figure></li></ul><h1>4. 重建initramfs</h1><ul><li><p>备份当前的initramfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r)-nouveau.img</span><br></pre></td></tr></table></figure></li><li><p>重建一个新的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dracut /boot/initramfs-$(uname -r).img $(uname -r)</span><br></pre></td></tr></table></figure></li></ul><h1>5.重启系统验证</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安装部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grub修复-UEFI篇</title>
      <link href="/posts/e5a0e4e9.html"/>
      <url>/posts/e5a0e4e9.html</url>
      
        <content type="html"><![CDATA[<h1>grub.cfg文件误删</h1><ul><li>手动引导进入系统修复<br>开机显示grub&gt;</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls #显示分区</span><br><span class="line">set root=(hd0,gpt2) #设置boot目录，假如不知道一个个试试，在下面可以按tap自动补全</span><br><span class="line">linuxefi /vmlinuz-(uname -r) root=/dev/mapper/kylinsec-root ro rd.lvm.lv=kylinsec/root rd.lvm.lv=kylinsec/swap rhgb #设置linuxefi找到vmlinuz，并设置根分区路径以及其他参数，根分区的路径一般都是这个，如果不知道可以参考其他机器的文件</span><br><span class="line">initrdefi /initramfs-(uname -r).img #设置initrdefi</span><br><span class="line">boot # 引导</span><br><span class="line">grub2-mkconfig -o /boot/efi/EFI/kylin/grub.cfg #重新生成grub.cfg文件</span><br><span class="line">reboot #重启验证</span><br></pre></td></tr></table></figure><ul><li>进入救援盘修复</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/efi/EFI/kylin/grub.cfg #重新生成grub.cfg文件</span><br></pre></td></tr></table></figure><h1>删除/boot分区</h1><p>系统无引导，会一直卡在启动界面，区别于grub&gt;,所以可以直接进入救援模式然后chroot，将光盘挂载到系统,配置yum来重装kernel和grub2-efi和shim，如果双内核的话需要进系统调整下内核启动顺序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum reinstall kernel #有几个内核就装几个包，时间会长一点</span><br><span class="line">yum reinstall grub2-efi shim #里面包含了/boot下的文件</span><br><span class="line">grub2-mkconfig -o /boot/efi/EFI/kylin/grub.cfg #重新生成grub.cfg文件</span><br></pre></td></tr></table></figure><h1>vmlinuz被删</h1><p>直接提示vmlinuz不见<br>可以利用其他内核或者救援模式俩钟途径，修复有2种办法。</p><ul><li>重装内核法（建议）<br>把对应的内核包强制安装一遍<br>如果有第三方驱动打入的，此时需要重新打入一遍，比如ngbe之类的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh kernel-xxx  --force</span><br></pre></td></tr></table></figure><ul><li>解压内核包法（不建议）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir kernel-4.18 #创建一个目录用于解压rpm包</span><br><span class="line">cp kernel-kek-4.18.0-147.ky3.kb19.pg.x86_64.rpm kernel-4.18 #将rpm包拷贝进去</span><br><span class="line">rpm2cpio kernel-kek-4.18.0-147.ky3.kb19.pg.x86_64.rpm | cpio -idmv</span><br><span class="line">cp boot/vmlinuz** /boot #将此文件拷贝过去</span><br></pre></td></tr></table></figure><h1>initramfs被删</h1><p>直接提示initramfs不见<br>可以利用其他内核或者救援模式修复，修复有2种办法</p><ul><li>dracut方法（建议）<br>可以看看当前系统有几个内核（比如4.18,3.10，rescue），选择其中一个内核进入重新创建，缺失的内核版本可以在/boot下找到。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dracut /boot/initramfs-4.18.0-147.ky3.kb19.pg.x86_64.img 4.18.0-147.ky3.kb19.pg.x86_64</span><br></pre></td></tr></table></figure><ul><li>重装内核法（不建议）<br>如果有第三方驱动打入的，此时需要重新打入一遍，比如ngbe之类的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh kernel-xxx  --force</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inode节点爆满处理</title>
      <link href="/posts/e5a0e4e9.html"/>
      <url>/posts/e5a0e4e9.html</url>
      
        <content type="html"><![CDATA[<h1>问题阐述</h1><p>磁盘容量没有满但是不能创建文件</p><h1>产生原因</h1><p>inode资源耗尽</p><h1>解决方法</h1><p>##查看inode节点状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -i</span><br></pre></td></tr></table></figure><p>可以看出根目录的inode占用率是100%,此时已经无法创建新的文件</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Filesystem Inodes  IUsed   IFree  IUse% Mounted on </span><br><span class="line">root       4964352 4964352  0     100%  /</span><br></pre></td></tr></table></figure><h2 id="删除无用的临时文件，释放inode">删除无用的临时文件，释放inode</h2><ul><li>find检查<br>使用find遍历将大小是0的文件列出来,为了防止误删,建议先查看文件是否需要</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp -type f -size 0</span><br></pre></td></tr></table></figure><p>如果确认某个目录下的文件不需要了可以加入exec一次删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp/log -type f -size 0 -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><ul><li>for循环<br>使用for循环查看某个目录下的文件数量,当定位到某个路径之后继续深挖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in /var/*; do echo $i; find $i | wc -l; done </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之df</title>
      <link href="/posts/d171c710.html"/>
      <url>/posts/d171c710.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>来自于英文词组&quot;Disk Free&quot;的缩写，其功能是用于显示系统上磁盘空间的使用量情况。</p><h1>选项</h1><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-a, --<span class="built_in">all</span>             显示所有系统文件</span><br><span class="line">-B, --<span class="keyword">block</span>-<span class="built_in">size</span>=<span class="built_in">SIZE</span> 指定显示时的块大小</span><br><span class="line">    --<span class="keyword">direct</span>          show statistics for a <span class="keyword">file</span> instead of mount point</span><br><span class="line">    --total           produce a grand total</span><br><span class="line">-h, --human-readable  以容易阅读的方式显示<span class="number">1024</span></span><br><span class="line">-H, --si              以容易阅读的方式显示<span class="number">1000</span></span><br><span class="line">-i, --inodes      显示inode 信息而非块使用量</span><br><span class="line">-k      即--<span class="keyword">block</span>-<span class="built_in">size</span>=<span class="number">1</span>K,指定块大小为<span class="number">1</span>KB</span><br><span class="line">-l, --<span class="keyword">local</span>           只显示本机的文件系统</span><br><span class="line">    --no-<span class="built_in">sync</span>      取得使用量数据前不进行同步动作(默认)</span><br><span class="line">    --output[=FIELD_LIST]  <span class="keyword">use</span> the output <span class="keyword">format</span> defined by FIELD_LIST,</span><br><span class="line">                             or <span class="built_in">print</span> <span class="built_in">all</span> fields <span class="keyword">if</span> FIELD_LIST is omitted.</span><br><span class="line">-P, --portability     <span class="keyword">use</span> the POSIX output <span class="keyword">format</span></span><br><span class="line">    --<span class="built_in">sync</span>            在取得磁盘使用信息前，先执行<span class="built_in">sync</span>命令</span><br><span class="line">-t, --<span class="keyword">type</span>=<span class="keyword">TYPE</span>       只显示指定类型的文件系统</span><br><span class="line">-T, --<span class="built_in">print</span>-<span class="keyword">type</span>      输出时显示文件系统类型</span><br><span class="line">-x, --exclude-<span class="keyword">type</span>=<span class="keyword">TYPE</span>   limit listing to <span class="keyword">file</span> systems not of <span class="keyword">type</span> <span class="keyword">TYPE</span></span><br><span class="line">-v                    (ignored)</span><br><span class="line">--help              显示此帮助信息并退出</span><br><span class="line">--version      显示版本信息并退出</span><br></pre></td></tr></table></figure><h1>用法</h1><h2 id="查看与挂载点有关的信息">查看与挂载点有关的信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -Th  # h是1024换算的</span><br></pre></td></tr></table></figure><h2 id="查看与挂载点有关的信息-2">查看与挂载点有关的信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -TH  # h是1000换算的</span><br></pre></td></tr></table></figure><h2 id="显示单个挂载点的信息">显示单个挂载点的信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -Th /</span><br></pre></td></tr></table></figure><h2 id="显示ext4的文件系统">显示ext4的文件系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h -t ext4</span><br></pre></td></tr></table></figure><h2 id="查看inode节点信息">查看inode节点信息</h2><blockquote><p>如果inode节点满了将无法继续创建文件,但可能此时磁盘还没有占满,所以需要更多关注inode节点相关信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之crontab</title>
      <link href="/posts/9191c4a8.html"/>
      <url>/posts/9191c4a8.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>周期性定时任务</p><h1>crontab语法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   #每（分时日月周）执行</span><br><span class="line">[a-b] #在a到b的时间段执行</span><br><span class="line">*/n #每n(分时日月周)执行一次</span><br><span class="line">[a,b,c] #第(分时日月周)执行</span><br></pre></td></tr></table></figure><h1>案例</h1><p>只要收录了一些时间用法，具体的执行的内容都用A代替</p><ul><li>每一分钟执行一次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*****A</span><br></pre></td></tr></table></figure><ul><li>在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span><span class="number">6</span>-<span class="number">12</span>/<span class="number">3</span>*<span class="number">12</span>*A</span><br></pre></td></tr></table></figure><ul><li>周一到周五每天下午 5:00 执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span><span class="number">17</span>**<span class="number">1</span>-<span class="number">5</span>A</span><br></pre></td></tr></table></figure><ul><li>每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分…执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">20</span><span class="number">0</span>-<span class="number">24</span>/<span class="number">2</span>***A</span><br></pre></td></tr></table></figure><ul><li>每两个小时执行</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span><span class="emphasis">*/2*</span>**  A</span><br></pre></td></tr></table></figure><ul><li>每天7：50执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">50</span><span class="number">7</span>***A</span><br></pre></td></tr></table></figure><ul><li>每天22：50执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">50</span><span class="number">22</span>***A</span><br></pre></td></tr></table></figure><ul><li>每月1号和15号执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span><span class="number">0</span><span class="number">1</span>,<span class="number">15</span>**A</span><br></pre></td></tr></table></figure><ul><li>每小时的第一分执行</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>**** <span class="selector-tag">A</span></span><br></pre></td></tr></table></figure><ul><li>每月的1、11、21、31日是的6：30执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">30</span><span class="number">6</span>*/<span class="number">10</span>**A</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
