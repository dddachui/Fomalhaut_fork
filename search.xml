<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>好用的软件</title>
      <link href="/posts/3df4b4e4.html"/>
      <url>/posts/3df4b4e4.html</url>
      
        <content type="html"><![CDATA[<h1>开源软件(持续更新)</h1><h2 id="RSS软件">RSS软件</h2><p><a href="https://github.com/yang991178/fluent-reader">https://github.com/yang991178/fluent-reader</a></p><h2 id="ssh工具windterm">ssh工具windterm</h2><p>运维人的工具不嫌多<br><a href="https://github.com/kingToolbox/WindTerm">https://github.com/kingToolbox/WindTerm</a></p><h2 id="代码片段管理工具massCode">代码片段管理工具massCode</h2><p><a href="https://github.com/massCodeIO/massCode">https://github.com/massCodeIO/massCode</a></p><h2 id="远程桌面rustdesk">远程桌面rustdesk</h2><p><a href="https://github.com/rustdesk/rustdesk">https://github.com/rustdesk/rustdesk</a></p><h2 id="局域网网盘alist">局域网网盘alist</h2><p>在linux发行版搭建服务器,挂载各大网盘或者本地文件,有好看的ui<br><a href="https://github.com/alist-org/alist">https://github.com/alist-org/alist</a></p><h2 id="洛雪">洛雪</h2><p>懂得都懂<br><a href="https://github.com/lyswhut/lx-music-desktop">https://github.com/lyswhut/lx-music-desktop</a></p><h2 id="linux查看markdown命令">linux查看markdown命令</h2><p><a href="https://github.com/charmbracelet/glow">https://github.com/charmbracelet/glow</a></p><h1>其他软件</h1><h2 id="卡饭输入法">卡饭输入法</h2><p><a href="https://input.kfsafe.cn/">https://input.kfsafe.cn/</a></p><h2 id="Obsidian-markdown笔记">Obsidian(markdown笔记)</h2><p>这个软件一直在更新就不放链接了<br><a href="https://obsidian.md/">https://obsidian.md/</a></p><h1>获取软件下载地址(蓝奏云)</h1><ul><li>windterm<br><a href="https://dddachui.lanzouy.com/iDzcV0a4znoh">https://dddachui.lanzouy.com/iDzcV0a4znoh</a></li><li>massCode<br><a href="https://dddachui.lanzouy.com/iwAFI0a50h0d">https://dddachui.lanzouy.com/iwAFI0a50h0d</a></li><li>rustdesk<br><a href="https://dddachui.lanzouy.com/ii2TA0a50htc">https://dddachui.lanzouy.com/ii2TA0a50htc</a></li><li>alist<br><a href="https://dddachui.lanzouy.com/iF7pT0a506kh">https://dddachui.lanzouy.com/iF7pT0a506kh</a></li><li>glow<br><a href="https://dddachui.lanzouy.com/iIe1b0eh537c">https://dddachui.lanzouy.com/iIe1b0eh537c</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客图片使用记录</title>
      <link href="/posts/6b240272.html"/>
      <url>/posts/6b240272.html</url>
      
        <content type="html"><![CDATA[<h1>使用记录</h1><h2 id="背景图">背景图</h2><ul><li>9</li><li>19</li><li>29</li><li>39</li></ul><h2 id="文章图">文章图</h2><ul><li>学习目标 1</li><li>好用的软件 2</li><li>crontab 3</li><li>博客图片使用记录 4</li><li>局域网ip冲突解决方法 5</li><li>linux的驱动问题 6</li><li>系统资源异常处理思路 7</li><li>用户被锁定 8</li><li>在Centos中检查RPM包的依赖性 10</li><li>git拉取总是需要密码 11</li><li>inode节点爆满处理 12</li><li>Linux好用命令之at 13</li><li>Linux好用命令之bizp2 14</li><li>Linux好用命令之dd 15</li><li>Linux好用命令之df 16</li><li>Linux好用命令之dnf 17</li><li>Linux好用命令之dos2unix 18</li><li>Linux好用命令之ethtool 20</li><li>Linux好用命令之free 21</li><li>Linux好用命令之gdb 22</li><li>Linux好用命令之git 23</li><li>Linux好用命令之gzip 24</li><li>Linux好用命令之iostat 25</li><li>Linux好用命令之lscpu 26</li><li>Linux好用命令之lsof 27</li><li>Linux好用命令之lspci 28</li><li>Linux好用命令之md5sum 30</li><li>Linux好用命令之netstat 31</li><li>Linux好用命令之nmcli 32</li><li>Linux好用命令之pidstat 33</li><li>Linux好用命令之ps 34</li><li>Linux好用命令之rpm 35</li><li>Linux好用命令之rsync 36</li><li>Linux好用命令之screen 37</li><li>Linux好用命令之strace 38</li><li>Linux好用命令之systemctl 40</li><li>Linux好用命令之tar 41</li><li>Linux好用命令之top 42</li><li>Linux好用命令之ulimit 43</li><li>Linux好用命令之xz 44</li><li>Linux好用命令之yum 45</li><li>Linux好用命令之zip 46</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023目标</title>
      <link href="/posts/7169e9ad.html"/>
      <url>/posts/7169e9ad.html</url>
      
        <content type="html"><![CDATA[<h1>学习Flag</h1><ol><li>考完驾照！</li><li>学习rpm打包方法</li><li>学习ks文件使用，包括文件编写、pxe自动安装、封装镜像</li><li>rub原理学习(修复legacy、uefi引导、基本操作)</li><li>linux双网卡使用NetworkManager服务访问资源问题解决</li><li>高并发文档精简</li></ol><h1>人生目标</h1><ol><li>找个对象</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之ethtool</title>
      <link href="/posts/c0d4357c.html"/>
      <url>/posts/c0d4357c.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>查看网口用的</p><h1>查看网卡信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool eth0</span><br></pre></td></tr></table></figure><ul><li>网卡信息如下<br>可以看出网卡的很多信息,包括网卡速率是百兆还是千兆</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Settings for enp2s0:</span><br><span class="line">        Supported ports: [ TP    MII ]</span><br><span class="line">        Supported link modes:   10baseT/Half 10baseT/Full</span><br><span class="line">                                100baseT/Half 100baseT/Full</span><br><span class="line">                                1000baseT/Half 1000baseT/Full</span><br><span class="line">        Supported pause frame use: Symmetric Receive-only</span><br><span class="line">        Supports auto-negotiation: Yes</span><br><span class="line">        Supported FEC modes: Not reported</span><br><span class="line">        Advertised link modes:  10baseT/Half 10baseT/Full</span><br><span class="line">                                100baseT/Half 100baseT/Full</span><br><span class="line">                                1000baseT/Half 1000baseT/Full</span><br><span class="line">        Advertised pause frame use: Symmetric Receive-only</span><br><span class="line">        Advertised auto-negotiation: Yes</span><br><span class="line">        Advertised FEC modes: Not reported</span><br><span class="line">        Link partner advertised link modes:  10baseT/Half 10baseT/Full</span><br><span class="line">                                             100baseT/Half 100baseT/Full</span><br><span class="line">                                             1000baseT/Full</span><br><span class="line">        Link partner advertised pause frame use: Symmetric</span><br><span class="line">        Link partner advertised auto-negotiation: Yes</span><br><span class="line">        Link partner advertised FEC modes: Not reported</span><br><span class="line">        Speed: 1000Mb/s</span><br><span class="line">        Duplex: Full</span><br><span class="line">        Auto-negotiation: on</span><br><span class="line">        master-slave cfg: preferred slave</span><br><span class="line">        master-slave status: slave</span><br><span class="line">        Port: Twisted Pair</span><br><span class="line">        PHYAD: 0</span><br><span class="line">        Transceiver: external</span><br><span class="line">        MDI-X: Unknown</span><br><span class="line">        Supports Wake-on: pumbg</span><br><span class="line">        Wake-on: d</span><br><span class="line">        Link detected: yes</span><br></pre></td></tr></table></figure><h1>把网卡指示灯打开</h1><p>在网卡支持这种功能的前提下,使用此命令会使网卡的指示灯闪烁,但需要注意,有些系统会持续闪烁,但有些版本会闪烁几秒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -p eth0</span><br></pre></td></tr></table></figure><h1>查看错误信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -S eth0 | grep error</span><br></pre></td></tr></table></figure><p>同时，使用<code>ifconfig</code> 也可以看错误信息</p><h1>错误信息</h1><ul><li>RX errors<br>表示总的收包的错误数量，这包括 too-long-frames 错误，Ring Buffer 溢出错误，crc 校验错误，帧同步错误，fifo overruns 以及 missed pkg 等等</li><li>RX dropped<br>表示数据包已经进入了 Ring Buffer，但是由于内存不够等系统原因，导致在拷贝到内存的过程中被丢弃</li><li>RX overruns<br>表示了 fifo 的 overruns，这是由于 Ring Buffer(aka Driver Queue) 传输的 IO 大于 kernel 能够处理的 IO 导致的，而 Ring Buffer 则是指在发起 IRQ 请求之前的那块 buffer。很明显，overruns 的增大意味着数据包没到 Ring Buffer 就被网卡物理层给丢弃了(就是ring buffer满之后先有drop收到的，再overrun没收的)，而 CPU 无法即使的处理中断是造成 Ring Buffer 满的原因之一</li><li>RX frame<br>表示 misaligned 的 frames</li></ul><h1>rx_crc_errors</h1><p>在大多数情况下，增加rx_crc_errors的值意味着该问题出在网络模型的第1层，当在接口上接收到数据包时，它将经历数据完整性检查，这称为循环冗余检查。 如果数据包在该检查中失败，则将其标记为rx_crc_errors<br>1.更换电缆。<br>2.检查交换机配置。<br>3.更换网络接口卡。</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之dd</title>
      <link href="/posts/3f7fa63c.html"/>
      <url>/posts/3f7fa63c.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><blockquote><p><a href="https://www.cnblogs.com/sylar5/p/6649009.html">Linux 中用 dd 命令来测试硬盘读写速度 - Cyril_Wu - 博客园 (cnblogs.com)</a></p></blockquote><h1>基本用法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time dd if=/dev/zero  of=/dev/null bs=block_size count=number_of_blocks</span><br></pre></td></tr></table></figure><h1>参数选项</h1><ul><li>选项<ul><li>if=file  ：从 file 中读而不是标准输入</li><li>of=file ：写到 file 里去而不是标准输出</li><li>bs=bytes ：一次读和写  bytes 字节</li><li>ibs=bytes ：一次读 bytes 字节。默认是512</li><li>obs=bytes ：一次写 bytes 字节。默认是512</li><li>count=blocks ： 仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数</li><li>iflag=FLAGS   ：指定读的方式FLAGS</li><li>oflag=FLAGS  ：指定写的方式FLAGS</li></ul></li><li>FLAGS如下<ul><li>direct　　　读写数据采用直接IO方式；</li><li>directory　读写失败除非是directory；</li><li>dsync　　　读写数据采用同步IO；</li><li>sync　　　　同上，但是针对是元数据</li><li>fullblock　　堆积满block(iflag only)；</li><li>nonblock　读写数据采用非阻塞IO方式</li><li>noatime　　 读写数据不更新访问时间</li></ul></li></ul><h1>磁盘写能力测试</h1><p>/dev/zero是一个伪设备，只产生空字符流，不会产生IO，IO都会集中在of文件中，所以这个命令是测试磁盘的写能力。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=test bs=8k count=10000 oflag=direct</span><br></pre></td></tr></table></figure><h1>读取能力测试</h1><p>/dev/sdb是一个物理分区，对它的读取会产生IO，/dev/null是伪设备，是黑洞，of到该设备不会产生IO，所以，这个命令的IO只发生在/dev/sdb上，也相当于测试磁盘的读能力</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=test of=/dev/null bs=8k count=10000 iflag=direct</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之rsync</title>
      <link href="/posts/bc5c9a0b.html"/>
      <url>/posts/bc5c9a0b.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>同步的手段</p><h1>简单用法</h1><p>静态文件部署，一般会用到此命令，完整命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --progress -e &#x27;ssh -p 2022&#x27; --exclude=&#x27;testfile&#x27; --delete $&#123;WORKSPACE&#125;/  root@192.168.42.100:/data/</span><br></pre></td></tr></table></figure><h1>参数可用</h1><ul><li>-a：–archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD</li><li>-v：输出详细过程</li><li>-z：对正在备份的文件进行压缩处理</li><li>-r：对子目录以递归模式处理</li><li>-l：保留软连接</li><li>-p：保持文件权限</li><li>-t：保持文件时间信息</li><li>-g：保持文件属组信息</li><li>-o：保持文件属主信息</li><li>-D：保持设备文件信息</li><li>-e： –rsh=command 指定使用rsh、ssh方式进行数据同步，一般使用ssh</li><li>exclude: 排除某文件的同步，可以多个。</li><li>–delete：删除那些DST中SRC没有的文件。</li><li>–progress：显示每个文件传输的进度。知道是否有大型文件正在备份可能是有用的</li></ul><h1>几个坑</h1><ul><li><p>将dirA的所有文件同步到dirB内，并删除dirB内多余的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --delete dirA/ dirB/ </span><br></pre></td></tr></table></figure></li></ul><blockquote><p>源目录和目标目录结构一定要一致！！</p><p>不能是dirA/* dirB/ 或者dirA/ dirB/* 或者 dirA/* dirB/*，如果不遵守，那么就不会删除。</p></blockquote><ul><li><p>将dirA的所有文件同步到dirB，但是在dirB内除了fileB3.txt这个文件不删之外，其他的都删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --delete --exclude &quot;fileB3.txt&quot; dirA/ dirB/</span><br></pre></td></tr></table></figure></li><li><p>将dirA目录内的fileA1.txt和fileA2.txt不同步到dirB目录内</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude=&quot;fileA1.txt&quot; --exclude=&quot;fileA2.txt&quot; dirA/ dirB/</span><br></pre></td></tr></table></figure></li><li><p>将dirA目录内的fileA1.txt和fileA2.txt不同步到dirB目录内，并且在dirB目录内删除多余的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude=&quot;fileA1.txt&quot; --exclude=&quot;fileA2.txt&quot; --delete dirA/ dirB/</span><br></pre></td></tr></table></figure></li><li><p>将dirA目录内的fileA1.txt和fileA2.txt不同步到dirB目录内，并且在dirB目录内删除多余的文件，同时，如果dirB内有fileA2.txt和fileA1.txt这两个被排除同步的文件，仍然将其删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude=&quot;fileA1.txt&quot; --exclude=&quot;fileA2.txt&quot; --delete-excluded dirA/ dirB/</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Centos中检查RPM包的依赖性</title>
      <link href="/posts/179557ff.html"/>
      <url>/posts/179557ff.html</url>
      
        <content type="html"><![CDATA[<h1>产生原因</h1><ol><li>定制本地yum源的时候漏了几个依赖包,导致软件无法安装</li><li>配置的仓库包不完整,下载的软件的时候缺少几个包</li><li>由于网络环境,无法配置外网源,只能导入rpm包,但是缺少了几个依赖</li></ol><blockquote><p>很多场景下，是不允许配置yum源的</p></blockquote><h1>一个简单的栗子</h1><ul><li>安装zabbix的时候缺少依赖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh zabbix-server-mysql-3.4.4-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error: Failed dependencies:</span><br><span class="line">libOpenIPMI.so<span class="number">.0</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libOpenIPMIposix.so<span class="number">.0</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libevent-<span class="number">2.0</span>.so<span class="number">.5</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libiksemel.so<span class="number">.3</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libnetsnmp.so<span class="number">.31</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libodbc.so<span class="number">.2</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br></pre></td></tr></table></figure><p>显然是机器导入的rpm缺少依赖包导致的,但我们只能看到文件,无法看到这个文件在什么包</p><ul><li>查询在哪个rpm包</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> whatprovides libOpenIPMI.so.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>结果如下,可以看到这文件是OpenIPMI-libs提供的,我们可以直接yum安装,或者由于网络问题,可以下载了导入机器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos, versionlock</span><br><span class="line">OpenIPMI-libs-2.0.27-1.el7.i686 : The OpenIPMI runtime libraries</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Provides    : libOpenIPMI.so.0</span><br></pre></td></tr></table></figure><ul><li><p>安装</p><ul><li><p>直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y OpenIPMI-libs-2.0.27-1.el7.i686</span><br></pre></td></tr></table></figure></li><li><p>下载导入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yumdownloader</span> --destdir=.   OpenIPMI-libs-<span class="number">2</span>.<span class="number">0</span>.<span class="number">27</span>-<span class="number">1</span>.el7.i686</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>优化解决依赖手法1</h1><p>除了<code>yum whatprovides libOpenIPMI.so.0</code>这种粗暴方式,其实我们有更好的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum deplist  zabbix50-5.0.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>输出如下.可以看到什么包需要什么,由谁提供</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos, versionlock</span><br><span class="line">package: zabbix50.x86_64 5.0.21-1.el7</span><br><span class="line">  dependency: config(zabbix50) = 5.0.21-1.el7</span><br><span class="line">   provider: zabbix50.x86_64 5.0.21-1.el7</span><br><span class="line">  dependency: libc.so.6()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.11)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.14)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.15)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.17)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.2.5)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.3)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.3.4)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.4)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.7)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libcrypto.so.10()(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcrypto.so.10(OPENSSL_1.0.1_EC)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcrypto.so.10(OPENSSL_1.0.2)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcrypto.so.10(libcrypto.so.10)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcurl.so.4()(64bit)</span><br><span class="line">   provider: libcurl.x86_64 7.29.0-59.el7_9.1</span><br><span class="line">  dependency: libdl.so.2()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libm.so.6()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libm.so.6(GLIBC_2.2.5)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libpcre.so.1()(64bit)</span><br><span class="line">   provider: pcre.x86_64 8.32-17.el7</span><br><span class="line">  dependency: libpthread.so.0()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libpthread.so.0(GLIBC_2.2.5)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libresolv.so.2()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libssl.so.10()(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libssl.so.10(libssl.so.10)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libz.so.1()(64bit)</span><br><span class="line">   provider: zlib.x86_64 1.2.7-20.el7_9</span><br><span class="line">  dependency: libz.so.1(ZLIB_1.2.0)(64bit)</span><br><span class="line">   provider: zlib.x86_64 1.2.7-20.el7_9</span><br><span class="line">  dependency: logrotate</span><br><span class="line">   provider: logrotate.x86_64 3.8.6-19.el7</span><br><span class="line">  dependency: rtld(GNU_HASH)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">   provider: glibc.i686 2.17-326.el7_9</span><br></pre></td></tr></table></figure><h1>优化解决依赖手法2</h1><p>配置一台和生产测试一样的虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zabbix50-5.0.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>使用yum install会自己查询依赖，如下所示，我们可以直接得到需要的依赖关系</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">正在安装</span><br><span class="line">ansible</span><br><span class="line">为依赖而安装</span><br><span class="line"><span class="keyword">python</span>-babel</span><br><span class="line"><span class="keyword">python</span>-httplib2</span><br><span class="line"><span class="keyword">python</span>-jinja2</span><br><span class="line"><span class="keyword">python</span>-paramiko</span><br><span class="line">python2-jmespath</span><br></pre></td></tr></table></figure><p>我们再次用<code>yumdownloader</code>命令进行下载包</p><h1>优化解决依赖手法3</h1><p>我常用的方法,但<code>需要注意</code>的是,使用<code>yumdownloader</code>的时候,他会检测本机的rpm包,然后下载软件缺失的依赖包,那么就是说,如果我本机和目的rpm列表有出入,可能我本机的包更多,那么我下载的依赖可能更少,那么导入目标机器结果依赖可能还是没解决,所以我们这个手法还是需要保持俩台机器的环境一致</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumdownloader --destdir=<span class="regexp">/root/</span>Desktop/rpms --resolve ansible</span><br></pre></td></tr></table></figure><h1>小工具-rpmreaper</h1><p>本来是用作清理系统中无用以及它们所依赖的包，它有很直观的ncurses界面来展示已安装的包和它们依赖关系的树形图</p><ul><li>安装</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> rpmreaper</span><br></pre></td></tr></table></figure><ul><li>运行</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rpmreaper</span></span><br></pre></td></tr></table></figure><p>rpmrepater会向用户显示已安装包的列表</p><ol><li><p>你可以使用上/下箭头来滚动屏幕</p></li><li><p>你可以在指定包上使用&quot;r&quot;键来显示其依赖关系，循环在指定包上按下&quot;r&quot;键可以展示出余下的信息</p></li><li><p>&quot;L&quot;标志的意思是说这个包是一片“孤叶”，意思说说没有任何包依赖它</p></li><li><p>&quot;o&quot;标志是说这个包是整个依赖链的中间部分</p></li><li><p>按下&quot;b&quot;键会显示其他依赖于该包的其他包</p></li></ol><h1>小工具-yumex</h1><p>yum Extender (简称 yumex ) , 是 yum 的图形化操作界面。可以通过 yumex 方便的查看软件包，安装、卸载软件包。对于对命令行不熟的人简直就是神奇，管理软件包很方便</p><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install yumex</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumex --root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局域网ip冲突解决方法</title>
      <link href="/posts/771f3e87.html"/>
      <url>/posts/771f3e87.html</url>
      
        <content type="html"><![CDATA[<h1>问题描述</h1><p>由于在一个网段下面ip地址是唯一的,当产生2个一样的ip的时候就会出现网络故障,可以hi使用一个工具<code>arp-scan</code>来扫描它们，这个工具会在本地网络发送ARP（Address Resolution Protocol）(地址解析协议)包来收集地址。如果有多个MAC地址声称拥有相同的IP地址，那么就存在冲突</p><h1>安装软件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y arp-scan</span><br></pre></td></tr></table></figure><h1>冲突检测</h1><p>指定eth1网卡进行检测</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan  --interface=eth1 -l</span><br></pre></td></tr></table></figure><h1>输出结果</h1><p>虚拟机不是很准,实际上是可以看到<code>DUP</code>的报错</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">1</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:c0:<span class="number">00</span>:<span class="number">08</span>VMware, Inc.</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">2</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:e1:<span class="number">0</span>b:edVMware, Inc.</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">254</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:e4:eb:<span class="number">75</span>VMware, Inc.</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">2</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:e1:<span class="number">0</span>b:edVMware, Inc. (DUP: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之tar</title>
      <link href="/posts/2208ab89.html"/>
      <url>/posts/2208ab89.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>Unix和<a href="https://baike.baidu.com/item/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F/4336219?fromModule=lemma_inlink">类Unix系统</a>上的压缩打包工具，可以将多个文件合并为一个文件，打包后的文件后缀亦为<strong>tar</strong></p><h1>参数</h1><h2 id="功能">功能</h2><ul><li>-c 创建压缩文件</li><li>-x  解压缩,提取</li><li>-t  查看压缩包内容</li><li>-r  附加新的文件到tar文件中</li><li>-u 用已打包的文件的较新版本更新tar文件</li><li>-A 将tar文件作为一个整体追加到另一个tar文件中</li><li>-d,–compare 将文件系统里的文件和tar文件里的文件进行比较</li><li>–delete  删除tar文件里的文件</li></ul><h2 id="常用选项">常用选项</h2><ul><li>-v 啰嗦模式,展示过程</li><li>-z 通过gzip指令压缩/解压缩文件,文件后缀名自己加<code>*.tar.gz</code></li><li>-p 保留原来的文件权限与属性</li><li>–exclude= 排除</li><li>-C 仅压缩指定目录里的内容或解压缩到指定目录</li></ul><h1>打包压缩</h1><ul><li>经典打包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf test.tar.gz  shell/  a.txt   b.sh</span><br></pre></td></tr></table></figure><ul><li>压缩带属性</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvpf log31.tar.gz log2014.log log2015.log log2016.log</span><br></pre></td></tr></table></figure><ul><li>压缩排除某些文件夹</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --exclude=/opt/test/a -czvf test.tar.gz /opt/test</span><br></pre></td></tr></table></figure><h1>列举查看压缩包</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf test<span class="selector-class">.tar</span><span class="selector-class">.gz</span> </span><br></pre></td></tr></table></figure><h1>解压缩</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf test.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压部分文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf  log.tar.gz  test/a.log</span><br></pre></td></tr></table></figure><blockquote><p>这个要先用-tvf列举出具体路径,不然找不到我示例的test/a.log</p></blockquote><ul><li>解压到指定位置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf a.tar.gz -C /opt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的驱动问题</title>
      <link href="/posts/8715157e.html"/>
      <url>/posts/8715157e.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>安装windows系统一般都会下载<code>驱动总裁</code>或者<code>鲁大师</code>,又或者通过微软的自动更新来更新系统的驱动,但在Linux里面,驱动一般是集成在linux内核里面的,如果我们有一个pci设备没有驱动且内核不支持该怎么处理?</p><h1>查看设备驱动</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lspci -k</span> </span><br></pre></td></tr></table></figure><p>可以先浏览一遍所有的pci设备,只需要关注每个设备是否有<code>Kernel driver in use</code>等字样,如果有的话就代表该设备可以驱动</p><ul><li>举个例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">02</span>:<span class="number">01.0</span> Ethernet controller: Intel Corporation 82545EM Gigabit Ethernet <span class="title function_">Controller</span> <span class="params">(Copper)</span> (rev <span class="number">01</span>)</span><br><span class="line">DeviceName: Ethernet0</span><br><span class="line">Subsystem: VMware PRO/<span class="number">1000</span> MT Single Port Adapter</span><br><span class="line">Kernel driver in use: e1000</span><br><span class="line">Kernel modules: e1000</span><br></pre></td></tr></table></figure><p>例如我有一个网卡,他成功加载了e1000的驱动,这样就代表我们可以使用该网卡</p><h1>没有驱动的处理</h1><p>如果没有<code>Kernel driver in use</code>字样,处理手段一般是<code>确认硬件型号</code>-&gt;<code>搜寻源代码</code>-&gt;<code>编译安装</code>来解决的</p><h2 id="确定型号">确定型号</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -<span class="keyword">nn</span> | <span class="keyword">grep</span> -i eth</span><br></pre></td></tr></table></figure><p>我们通过<code>-nn</code>参数来将<code>厂商号:设备号</code>输出如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">02</span>:<span class="number">01</span>.<span class="number">0</span> Ethernet : Intel Corporation <span class="number">82545</span>EM Gigabit <span class="meta"> [8086:100f] (rev 01)</span></span><br></pre></td></tr></table></figure><p>其中,我们只需要关注<code>[8086:100f]</code>这组数据就可以了</p><h2 id="含义">含义</h2><p><code>8086</code>是厂商号,代表某家厂商,<code>100f</code>是设备号,代表该厂商的产品</p><p>一般来说,如果内核完全不认网卡的话我们只能看出产品名字写的是<code>Ethernet</code>,也有一部分系统<code>可以认出全名</code>,如果能认出全名我们直接搜索全名就可以了,但如果没有全名我们只能依赖<code>厂商号:设备号</code>来定位设备</p><h2 id="网页搜索">网页搜索</h2><p>登陆<a href="https://devicehunt.com/">devicehunt网站</a>,我们只需要将我们的<code>device id</code>,即我例子中的<code>100f</code>填入搜索框,他就会将该设备的名字查询出来,类似这种网站的还有很多,比如 <a href="http://pci-ids.ucw.cz/read/PC/8088/0107">pci-ids.ucw.cz</a></p><h2 id="查找驱动">查找驱动</h2><p>既然已经知道型号了,那么就可以搜索对应的驱动源代码,一般找的网站有如下</p><ol><li>各个产品的官网</li><li>github或者gitee</li><li>我不知道了</li></ol><p>假设我们成功的找到的某个产品的驱动源代码,我们只需要导入我们的<code>linux发行版</code>进行编译安装</p><h1>编译安装</h1><p>例如我成功在<code>INTEL</code>官网下载了<code>e1000e-3.8.7.tar.gz</code>源码包</p><ul><li>解压源码包</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf e1000e-<span class="number">3</span>.<span class="number">8</span>.<span class="number">7</span>.tar.gz</span><br></pre></td></tr></table></figure><ul><li>查看README</li></ul><p>每个产品都会有类似的<code>README</code>文档来指导你如何使用,例如有如下2种方式,第一种就是让我们用<code>rpmbuild</code>来自己生成一个<code>rpm</code>包,第二种会让我生成一个<code>ko</code>文件,然后安装到内核里面去,然后我们再去使用<code>lspci</code>查看驱动的办法来验证是否记载驱动就可以了</p><ol><li><code>rpmbuild -tb e1000e-&lt;x.x.x&gt;.tar.gz</code></li><li>手动编译<ol><li>查看具体步骤,是否要先./configure</li><li>make编译</li><li>insmod xx.ko 手动加载驱动</li><li>使用lspci -nvs 01:00.0这种来看设备的驱动是否加载</li><li>如果加载成功就make install</li></ol></li></ol><blockquote><ol><li>makera,centos这些系统有的命令</li><li>make,gcc,g++这种命令属于开发工具,如果系统没有的话需要自己安装</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之strace</title>
      <link href="/posts/dd9530c1.html"/>
      <url>/posts/dd9530c1.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>strace是用来诊断,调试的linux用户空间跟踪器,来监视用户空间进程和内核交互,比如系统调用,信号传递,进程状态变更</p><h1>示例</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -tt -T -v -f -e [close|openat|execve] -o log  ./ceshi.sh -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><h1>常用选项</h1><ul><li>-tt : 显示毫秒级别</li><li>-T : 显示每次系统调用所消耗的时间</li><li>-v : 对于某些相关的调用,展示完整的环境变量,文件stat结构</li><li>-f : 跟踪目标进程以及目标进程创建的子进程</li><li>-e : 控制要跟踪的时间和跟踪行为,比如指定要跟踪的系统调用名称</li><li>-o : 把strace输出单独写到文件</li><li>-s : 系统调用某个参数是字符串的四行,最多输出指定长度的内容,默认32字节</li><li>-p : 指定要跟踪的进程pid 多个pid写多个-p</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统资源异常处理思路</title>
      <link href="/posts/e853bb7.html"/>
      <url>/posts/e853bb7.html</url>
      
        <content type="html"><![CDATA[<h1>常见资源问题</h1><ol><li>系统操作卡顿</li><li>cpu,内存资源占用过高</li><li>进程占用资源高</li><li>系统异常重启或宕机</li><li>开机时间长</li></ol><h1>资源异常处理思路</h1><h2 id="日志分析">日志分析</h2><ul><li>dmesg</li><li>/var/log/*</li><li>串口调试</li><li>~/.xsession-errors</li></ul><h2 id="卡顿分析">卡顿分析</h2><ul><li>本地卡顿还是远程卡顿</li></ul><h2 id="异常进程">异常进程</h2><ul><li>strace进程跟踪</li><li>pstack进程跟踪</li><li>jstack进程跟踪(针对java)</li></ul><h2 id="更换用户测试">更换用户测试</h2><ul><li>切换用户没有问题则考虑~/.conf  ~/.cache 环境变量</li></ul><h2 id="是否和显卡有关系">是否和显卡有关系</h2><ul><li>是否有硬件加速</li><li>更换硬件</li><li>xdriinfo或Xorg.0.log日志分析</li></ul><h2 id="内核或驱动">内核或驱动</h2><ul><li>升级驱动(<a href="http://kernel.org">kernel.org</a>)</li><li>升级内核</li></ul><h2 id="core文件">core文件</h2><ul><li>tmp目录下是否有core,或者第三方程序下是否有</li><li>gdb调试</li></ul><h2 id="是否与桌面图形相关">是否与桌面图形相关</h2><ul><li>top看图形进程占用</li><li>关闭图形是否临时解决</li><li>lightdm/gdm服务状态</li></ul><h1>linux性能分析工具</h1><h2 id="cpu">cpu</h2><ul><li>top :  显示系统和进程cpu,内存关系</li><li>uptime :  系统平均负载</li><li>vmstat :  报告和采样内存,io,cpu信息</li><li>procinfo :  cpu和中断信息</li><li>mpstat :  分析cpu</li><li>sar :  分析cpu</li><li>oprofile :  分析系统,进程的消耗</li><li>perf :  分析cpu调用路径和消耗</li><li>time :  进程cpu使用信息</li><li>strace :  系统调用信息</li><li>lstrace :  库函数调用信息和耗时</li><li>ps :  对特定进程分析</li><li>pidstat :  分析进程对cpu的占用</li></ul><h2 id="内存">内存</h2><ul><li>vmstat :  分析内存,io,cpu</li><li>free :  展示系统和进程cpu,内存,使用情况</li><li>slabtop :  内核缓存分配和使用情况</li><li>sar -r :  内存信息</li><li>/proc/memoryinfo :  内存信息</li><li>ps  :  进程和内存关系</li><li>/proc/<pid>/mem :  进程内存信息</li><li>memprof :  图形化内存分析</li><li>kcachegnnd :  图形化内存分析</li><li>/proc/iomem :  物理地址分配信息</li><li>pmap :  进程内存映射信息</li></ul><h2 id="磁盘">磁盘</h2><ul><li>iostat :  统计设备和分区磁盘IO信息</li><li>iotop :  列出进程磁盘IO信息</li><li>sar -d :  报告磁盘IO相关信息</li><li>blktrace :  跟踪磁盘IO时间</li><li>lsof :  列出进程打开文件,目录信息</li><li>pidstat -d  :  进程磁盘io统计信息</li><li>dd :  测速</li><li>dstat :  全能的系统信息统计工具</li><li>fio :  测速</li><li>mount :  挂载</li><li>badblocks :  检查磁盘损坏的区块</li></ul><h2 id="网络">网络</h2><ul><li>nmcli :  网络配置工具</li><li>ifconfig :  网络接口和统计</li><li>iperf :  流量检测</li><li>tcpdump :  抓包</li><li>wireshark :  图形化抓包</li><li>ss :  套接字分析</li><li>netstat :  统计网络协议和接口信息</li><li>ethtool :  统计以太网设备信息</li><li>ping :  万能的ping检测</li><li>tracerout :  跟踪路由</li><li>route :  显示路由</li></ul><h1>进程分析</h1><h2 id="进程的相关知识">进程的相关知识</h2><h2 id="进程含义">进程含义</h2><ul><li><p>运行中的程序副本(指令加数据)</p></li><li><p>理想状态下是70%CPU时间用户模式+30%CPU时间内核模式.</p></li><li><p>进程需要内存来存放自己的指令和代码，需要cpu来运行指令并完成对数据的加工，此然也需要内存把自己所输出的数据及处理的结果给保存下来等等。事实上我们运行中的进程数量是远远多余cpu核心数量的</p></li><li><p>假如只有1个cpu,他要么在执行用户代码,要么执行内核代码,不能同时执行2个</p></li><li><p>内核为了追踪每个进程,必须实现每一个进程可随时调入和调出,准备很多数据结构来保存这些数据,这个过程即为<code>任务列表</code>,每个进程都有一个task,每一个task在内核中都有一个专门的数据格式来存放相关信息,包括进程id,进程的线程,在调度上进程和线程没有区别</p></li><li><p>io过程,进程运行的过程中,需要请求的数据如果不在内存里面,就会请求内核吧数据从磁盘载入内存,从而供程序访问,io就被分成了2段,第一段是内核将磁盘数据加载到内核内存,然后再从内核内存复制到进程内存</p></li></ul><h2 id="常用命令">常用命令</h2><ul><li>大致看进程使用全部内存,包括共享内存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | awk &#x27;&#123;total +=$6&#125;END&#123;print total&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>大致看进程易用内存,比aux精确</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep Pss /proc/[1-9]*/smaps | awk &#x27;&#123;total+=$2&#125;END&#123;print total&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>cpu占用最高的10个进程,以pid排序</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k3nr | head -n 10</span><br></pre></td></tr></table></figure><ul><li>内存占用最高的10个进程,以pid排序</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k4nr | head -n 10</span><br></pre></td></tr></table></figure><ul><li>树形看进程,但不能看内核进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -axjf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree</span><br></pre></td></tr></table></figure><ul><li>查看进程下的所有线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -efL | grep &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>查看进程下有哪些线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -T -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>top/htop<ul><li>top -Hp [pid]</li><li>top 然后按P或M</li><li>top 然后按F</li></ul></li><li>vmstat n m</li><li>mpstat nm</li><li>sar工具</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -u -h -f /var/log/saxxx</span><br></pre></td></tr></table></figure><ul><li>指定命令固定在某个cpu上</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -c 3 top</span><br></pre></td></tr></table></figure><ul><li>显示进程是否固定在某个cpu上</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">taskset -c -p &lt;pid&gt;</span><br><span class="line">ps -o pid,psr,comm -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><h1>java进程占用问题思路</h1><ul><li>找出占用最高的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top 按M</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k3nr | awk &#x27;&#123;print $3 &quot;\t&quot; $11&#125;&#x27; | head -n 10</span><br></pre></td></tr></table></figure><ul><li>找出进程占用最高的线程ID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top  -Hp &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>找出cpu占用最高的线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -mp 2688 -o &quot;THREAD,tid,time&quot;</span><br></pre></td></tr></table></figure><ul><li>十进制线程号转换成十六进制线程号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%x\n&quot; &lt;tid&gt;</span><br></pre></td></tr></table></figure><ul><li>jstack找出问题代码</li></ul><p>tid(16进制西那才ID小写英文)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstack -l &lt;pid&gt;</span><br><span class="line">jstack -f &lt;pid&gt;</span><br><span class="line">jstack -l &lt;pid&gt; | grep tid -A 30</span><br></pre></td></tr></table></figure><blockquote><p>如果是java代码问题,应该找研发</p><p>如果是java虚拟机或者系统问题,应该继续查</p></blockquote><h1>其他进程占用cpu问题思路</h1><h2 id="top大法">top大法</h2><h3 id="用户态">用户态</h3><p>%us+%sy &gt; 70 ,用户态是否有可疑进程</p><h3 id="中断">中断</h3><ul><li>硬中断 hi</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -d cat <span class="regexp">/proc/i</span>nterrupts</span><br></pre></td></tr></table></figure><ul><li>软中断 si</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">watch</span> -n <span class="number">1</span> <span class="string">&quot;cat /proc/softirqs&quot;</span></span><br></pre></td></tr></table></figure><h3 id="灵异进程">灵异进程</h3><p>cpu占用很高但找不到</p><ul><li>关注<code>running</code>进程,是否有什么在不停的重启</li><li>关注<code>D</code>状态进程,不可中断的睡眠状态,该状态的进程无法kill,更不能自行退出,只能重启或恢复他依赖的资源来解决</li></ul><h2 id="uptime或w">uptime或w</h2><p>load average 越高,说明任务队列越长,处于等待的任务越多</p><h2 id="vmstat">vmstat</h2><ul><li>cs  上下文切换次数陡增或者和正常差别很大</li><li>in  中断次数较多</li><li>r  就绪队列长度一直高于最大cpu个数,考虑cpu竞争</li><li>wa  op等待cpu时间,值越大,磁盘大量做随机访问造成的,磁盘性能有瓶颈</li></ul><h2 id="pidstat">pidstat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -p &lt;pid&gt; -wt 1 10</span><br></pre></td></tr></table></figure><ul><li>Cswch/s 每秒主动任务上下文切换数量</li><li>Nvcswch/s 每秒被动任务上下文切换数量,值越大活吗进程被强制调度,就是争抢cpu,cpu时间片不足</li></ul><h2 id="sar">sar</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -q #查看近段时间cpu负载</span><br></pre></td></tr></table></figure><h2 id="判断是否是系统进程">判断是否是系统进程</h2><ul><li>U系</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S</span><br></pre></td></tr></table></figure><ul><li>R系</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf</span><br></pre></td></tr></table></figure><h2 id="显卡相关">显卡相关</h2><p>涉及到显卡硬件加速相关,有些应用可能需要用到,但可能走的是cpu软实现,并没有用到硬件</p><h2 id="是否程序不断自启动">是否程序不断自启动</h2><p>有些程序利用定时任务不断拉起服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rni &quot;进程&quot; /etc</span><br></pre></td></tr></table></figure><h2 id="对比其他机器">对比其他机器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -c top -d 1 -n 5</span><br></pre></td></tr></table></figure><h1>内存分析</h1><p>linux内存管理子系统架构<code>用户空间</code>,<code>内核空间</code>,<code>机器硬件</code></p><h2 id="查看配置">查看配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure><p>关注如下</p><ol><li>MemTotal 物理大小</li><li>MemFree 空闲</li><li>MemAvailabe 可用</li><li>Buffers 给文件做缓冲的</li><li>Cached 高速缓冲控制器</li><li>SwapCacaed</li><li>Active 活跃使用的bufferf或cache</li><li>Inactive 不经常用的大小</li><li>Slab</li><li>Sreclaimable  可回收slab</li><li>Sunreclaim 不可回收slab</li></ol><h2 id="检查现有的">检查现有的</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><p>应用可用内存~free+buffers+cached</p><p>Mem:avaiable~/proc/meminfo的MenAvailable</p><h1>smem</h1><ul><li>VSS</li></ul><p>虚拟耗用内存,包含共享库使用的内存</p><ul><li>RSS</li></ul><p>实际使用内存,包含共享库占用的,用top可以查到,最常用的内存指标,是进程占用的物理内存大小,Rss包含进程间共享的内存,所以累加起来会超出系统的内存消耗</p><ul><li>PSS</li></ul><p>所有使用某共享库的程序均分该共享库占用的内存时,每个进程占用的内存,所有进程的PSS之和就是系统的内存使用量,更精确,是将共享内存平均分摊到各个进程中的</p><ul><li>USS</li></ul><p>进程独自占用的物理内存,是PSS中自己的部分,只计算进程独自占用的</p><h2 id="常用命令-2">常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure><ul><li>实时显示内核slab缓冲区信息</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">slabtop</span></span><br></pre></td></tr></table></figure><ul><li>是否有内存限制或预留内存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cmdline</span><br></pre></td></tr></table></figure><ul><li>查看进程总内存是否正常</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | awk &#x27;&#123;total+=$6&#125;END&#123;print total/1024&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>日志分析超出内存或alloc的问题</li></ul><ol><li>dmesg</li><li>kernel.log</li><li>syslog</li></ol><ul><li>近段时间内存分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -r -h -f /var/log/sa/saxx</span><br></pre></td></tr></table></figure><ul><li>串口调试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启,引导加入console=ttyS0,115200n8</span></span><br></pre></td></tr></table></figure><h2 id="对比测试">对比测试</h2><ol><li>和centos对比</li><li>重新部署程序或和正常机器对比</li><li>换个用户排除环境变量问题</li><li>异常和正常的机器硬件,系统,bios,主板,硬盘,cpu,内存,包,是否一致</li><li>内存泄露问题,meminfo取多份对比,看看是在内核还是用户进程</li></ol><h2 id="核内内存问题">核内内存问题</h2><ol><li>MemFree和MemAvailable,定位内存消耗的方向是内核还是用户</li><li>slabtop实时观察哪个slab一直增高</li><li>对比看slab增长情况</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo  | grep -Ei &quot;slab|reclaim&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>定位具体的slab问题</li></ol><p>取多份slabinfo对比,带着/sys/kernel/slab分析</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>slabinfo</span><br></pre></td></tr></table></figure><p>如果dentry高,判断下是否进程对文件频繁读写,可以用strace分析</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -fp &lt;pid&gt; -e trace=<span class="keyword">open</span>,<span class="keyword">stat</span>,<span class="keyword">close</span>,<span class="keyword">unlink</span></span><br></pre></td></tr></table></figure><ol start="5"><li>内核问题一般是驱动问题<ol><li>lsmod对比</li><li>卸载驱动</li><li>驱动分析</li></ol></li><li>找到驱动地址</li></ol><p>可以看到函数对应的地址,通过地址找到驱动,也可以通过驱动找到地址</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/i</span>omem</span><br></pre></td></tr></table></figure><h2 id="核外内存问题">核外内存问题</h2><ol><li><p>top按M查看占用最大的</p></li><li><p>ps大法</p></li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ps</span> -aux | awk <span class="string">&#x27;&#123;total+=<span class="variable">$6</span>&#125;END&#123;print total/1024&#125;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux --<span class="built_in">sort</span> -rss | <span class="built_in">head</span></span><br></pre></td></tr></table></figure><ol start="3"><li>ps_mem</li><li>dstat</li></ol><p>动态展示进程内存占用</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat <span class="comment">--top-mem</span></span><br></pre></td></tr></table></figure><ol start="5"><li>进程内存分析</li></ol><ul><li>查看smaps</li></ul><p>smaps展示了一个进程的内存消耗</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/&lt;pid&gt;/smaps</span><br></pre></td></tr></table></figure><ul><li>内存泄露</li></ul><p>VIRT/VSZ或者writeable/private,如果在重复操作中一直问题,那么应该是内存泄露</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pmap -d &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>strace调试</li></ul><h2 id="pid是否超过限度">pid是否超过限度</h2><p><code>fork:cannot allocate memory</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | wc -l</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat  /proc/sys/kernel/pid_max</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysc &amp;&amp; echo3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><p>linux下频繁存取文件之后,物理内存会被消耗完,程序结束之后不会立即被正常释放的</p><h1>磁盘问题</h1><ul><li>磁盘整体使用情况</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -i</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/fstab</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid</span><br></pre></td></tr></table></figure><ul><li>是否开启读写缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cache</span><br></pre></td></tr></table></figure><ul><li>查看队列模式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/block/&lt;磁盘名&gt;/queue/scheduler </span><br></pre></td></tr></table></figure><ul><li>设置队列模式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &lt;队列模式&gt; &gt;&gt;  /sys/block/&lt;磁盘名&gt;/queue/scheduler </span><br><span class="line">echo  mq-deadline &gt;&gt;  /sys/block/&lt;磁盘名&gt;/queue/scheduler </span><br></pre></td></tr></table></figure><p>grub加入scsi_mod.use_blk_mq=0 elevator=deadline 修改算法</p><ul><li>查看磁盘调度算法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i scheduler</span><br></pre></td></tr></table></figure><ul><li>查看io</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x -N -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat -d</span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat -d <span class="comment">--top-io</span></span><br></pre></td></tr></table></figure><ul><li>io性能测试</li></ul><ol><li>blktrace</li><li>fio</li><li>dd</li></ol><ul><li>检测磁盘健康</li></ul><ol><li>badblocks</li><li>e2fsck</li><li>fsck</li><li>xfs_repair</li></ol><ul><li>判断磁盘类型</li></ul><p>1=HDD</p><p>0=SSD</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/sys/</span>block<span class="regexp">/&lt;磁盘名&gt;/</span>queue/rotational  </span><br></pre></td></tr></table></figure><ul><li>是否开启缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cache | grep -i read #读缓存</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cache | grep -i write #读缓存</span><br></pre></td></tr></table></figure><h2 id="磁盘分析工具">磁盘分析工具</h2><h3 id="dd">dd</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试写速率,请求直接变成io指令发到磁盘</span></span><br><span class="line">time dd if=/dev/zero of=test bs=4k count=100000 oflag=direct status=progress</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试写速率,规避cache</span></span><br><span class="line">time dd if=test  of=/dev/null bs=4k count=100000 oflag=direct status=progress</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试读速率,规避cache</span></span><br><span class="line">time dd if=/dev/xxx  of=/dev/null bs=4k count=100000 oflag=direct status=progress</span><br></pre></td></tr></table></figure><h3 id="blktrace">blktrace</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.采集信息,根据cpu个数生成文件个数,名字是&#123;device&#125;.blktrace.&#123;cpu&#125;</span></span><br><span class="line">blktrace -d /dev/sdX  [-o /tmp/sda ]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.合并信息,执行btt就要先把blktrace生成的文件合并</span></span><br><span class="line">blkparse -i sda -d sda.blkparse.bin</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.统计信息,将合并的信息分解程很多歌名字相关的文件信息</span></span><br><span class="line">btt -i sda.blkparse.bin -o sda.btt</span><br></pre></td></tr></table></figure><h2 id="磁盘检查修复工具">磁盘检查修复工具</h2><h3 id="badblocks">badblocks</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.扫描</span></span><br><span class="line">badblocks -s -v /dev/xxx</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.如果找到了坏道,可以进行写入扫描进行修复,写入扫描遇到坏道的时候自动重映射,扫描会覆盖原有数据,要备份的,写入扫描速度很低,所以应该扫描只读扫描时候发现错误的地方</span></span><br><span class="line">badblocks -w -s -v /dev/xxx [END] [START]</span><br></pre></td></tr></table></figure><h3 id="fstrim">fstrim</h3><p>回收已经挂载的文件系统未使用的块</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fstrim -av</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之pidstat</title>
      <link href="/posts/33b1a077.html"/>
      <url>/posts/33b1a077.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之iostat</title>
      <link href="/posts/84a73f90.html"/>
      <url>/posts/84a73f90.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>分析io性能</p><h1>概述</h1><p>在衡量磁盘性能时的基本指标：<code>利用率</code>、<code>饱和度</code>、<code>IOPS</code>、<code>吞吐量</code>和<code>响应时间</code></p><ol><li>利用率(Utilization):磁盘处理I/O的时间百分比,过度使用<code>(如超过 80%)</code>通常意味着磁盘I/O存在性能瓶颈</li><li>饱和度(Saturation):指磁盘处理I/O的繁忙程度,过度饱和意味着磁盘存在严重的性能瓶颈,当饱和度为100%时,磁盘无法接受新的I/O请求</li><li>IOPS(Input/Output Per Second):指每秒I/O请求的数量</li><li>吞吐量(Throughput):每秒I/O请求的大小</li><li>响应时间(Response time):指发送I/O请求和接收响应之间的间隔时间</li></ol><blockquote><p>一般面对IO问题,我们先考虑<code>是否产生了IO问题</code>,在安装系统之后一般都是要对磁盘进行一个测试的,常用的工具有<code>dd</code>,<code>fio</code>等,目的是要检验出磁盘的<code>随机读</code>、<code>顺序读</code>、<code>随机写</code>、<code>顺序写</code><br>等性能(通常是 512B ~ 1MB 之间),以判断是否能够满足应用的需求</p></blockquote><h1>命令参数</h1><p><strong>-c：</strong> 显示CPU使用情况<br><strong>-d：</strong> 显示磁盘使用情况<br><strong>-N：</strong> 显示磁盘阵列(LVM) 信息<br><strong>-n：</strong> 显示NFS 使用情况<br><strong>-k：</strong> 以 KB 为单位显示<br><strong>-m：</strong> 以 M 为单位显示<br><strong>-t：</strong> 报告每秒向终端读取和写入的字符数和CPU的信息<br><strong>-V：</strong> 显示版本信息<br><strong>-x：</strong> 显示详细信息<br><strong>-p：</strong>[磁盘] 显示磁盘和分区的情况</p><h1>多种用法简介</h1><ul><li>间隔1秒，总共显示5次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat 1 5</span><br></pre></td></tr></table></figure><ul><li>每隔2秒,显示一次设备统计信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d 2</span><br></pre></td></tr></table></figure><ul><li>每隔2秒,显示一次设备统计信息.总共输出3次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d 2 3</span><br></pre></td></tr></table></figure><ul><li>每隔2秒显示一次sda, sdb两个设备的扩展统计信息,共输出3次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x sda sdb 2 3</span><br></pre></td></tr></table></figure><ul><li>每隔2秒显示一次sda及上面所有分区的统计信息,共输出3次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -p sda 2 3</span><br></pre></td></tr></table></figure><ul><li>以M为单位显示所有信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -m</span><br></pre></td></tr></table></figure><ul><li>报告每秒向终端读取和写入的字符数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -t</span><br></pre></td></tr></table></figure><ul><li>显示指定硬盘信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d sda</span><br></pre></td></tr></table></figure><ul><li>查看TPS和吞吐量信息</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">iostat</span> -d -k <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>查看设备使用率和响应时间</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">iostat</span> -d -k <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h1>简单使用方法</h1><p>直接使用,显示所有设备负载情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat</span><br></pre></td></tr></table></figure><p>下面是输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.30    0.00    0.07    0.01    0.00   99.62</span><br><span class="line"></span><br><span class="line">Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd</span><br><span class="line">dm-0              3.40        67.65         6.81         0.00     492797      49628          0</span><br><span class="line">dm-1              0.01         0.30         0.00         0.00       2216          0          0</span><br><span class="line">sda               1.89        84.39         6.52         0.00     614737      47473          0</span><br><span class="line">sdb               0.02         0.35         0.00         0.00       2569          4          0</span><br></pre></td></tr></table></figure><ul><li>含义解释</li></ul><ol><li>%user：CPU在<code>用户模式</code>下的时间百分比</li><li>%nice：CPU在带NICE值的用户模式下的时间百分比</li><li>%system：CPU在系统模式下的时间百分比</li><li>%iowait：CPU等待输入输出完成时间的百分比</li><li>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比</li><li>%idle：CPU<code>空闲时间</code>百分比</li><li>device:磁盘名称</li><li>tps：每秒钟发送到的I/O请求数</li><li>Blk_read/s：每秒读取的block数</li><li>Blk_wrtn/s：每秒写入的block数</li><li>Blk_read：读入的block总数</li><li>Blk_wrtn：写入的block总数</li></ol><blockquote><p>%iowait的值过高，表示硬盘存在I/O瓶颈<br>%idle值高，表示CPU较空闲<br>%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量<br>%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。</p></blockquote><h1>整体磁盘I/O观察(重点)</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x -N -p</span><br></pre></td></tr></table></figure><p>iostat 是最常用的磁盘 I/O 性能观察工具。它提供了各种常用性能指标，例如每个磁盘的利用率、IOPS 和吞吐量<br>下面是<code>iostat</code>的输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">scd0              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">dm-0              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">dm-1              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br></pre></td></tr></table></figure><p>每一列都对应了之前说的<code>基本指标</code></p><ul><li><code>%util</code> 是我们前面提到的磁盘I/O使用情况,</li><li><code>r/s</code> 和 <code>w/s</code> 是 IOPS</li><li><code>rkB/s</code> 和 <code>wkB/s</code> 是吞吐量</li><li><code>r_await</code> 和 <code>w_await</code> 是响应时间</li></ul><blockquote><p>关于磁盘饱和度,可以利用<code>平均请求队列长度</code>或<code>完成读写请求的等待时间</code>与<code>基准测试（例如通过 fio）的结果</code>进行比较</p><p>从iostat无法得出磁盘的饱和度,饱和度反应的是磁盘处理io的繁忙程度,过高的饱意味着磁盘有严重的io问题,饱和度100%时候无法接受新的io请求</p></blockquote><h1>查看设备使用率,响应时间</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x 1 1</span><br></pre></td></tr></table></figure><p>以下是输出结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Device</span>            r/s     rkB/s   rrqm/s  %rrqm r_await rareq-sz     w/s     wkB/s   wrqm/s  %wrqm w_await wareq-sz     d/s     dkB/s   drqm/s  %drqm d_await dareq-sz     f/s f_await  aqu-sz  %util</span><br><span class="line"><span class="attribute">dm</span>-<span class="number">0</span>             <span class="number">1</span>.<span class="number">70</span>     <span class="number">67</span>.<span class="number">07</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">2</span>.<span class="number">90</span>    <span class="number">39</span>.<span class="number">45</span>    <span class="number">1</span>.<span class="number">68</span>      <span class="number">6</span>.<span class="number">80</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">38</span>     <span class="number">4</span>.<span class="number">04</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">01</span>   <span class="number">0</span>.<span class="number">11</span></span><br><span class="line"><span class="attribute">dm</span>-<span class="number">1</span>             <span class="number">0</span>.<span class="number">01</span>      <span class="number">0</span>.<span class="number">30</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">2</span>.<span class="number">32</span>    <span class="number">22</span>.<span class="number">85</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span></span><br><span class="line"><span class="attribute">sda</span>              <span class="number">1</span>.<span class="number">10</span>     <span class="number">83</span>.<span class="number">67</span>     <span class="number">0</span>.<span class="number">82</span>  <span class="number">42</span>.<span class="number">71</span>    <span class="number">2</span>.<span class="number">38</span>    <span class="number">76</span>.<span class="number">10</span>    <span class="number">0</span>.<span class="number">78</span>      <span class="number">6</span>.<span class="number">50</span>     <span class="number">0</span>.<span class="number">91</span>  <span class="number">53</span>.<span class="number">78</span>    <span class="number">0</span>.<span class="number">66</span>     <span class="number">8</span>.<span class="number">34</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">15</span>    <span class="number">1</span>.<span class="number">66</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">11</span></span><br><span class="line"><span class="attribute">sdb</span>              <span class="number">0</span>.<span class="number">02</span>      <span class="number">0</span>.<span class="number">35</span>     <span class="number">0</span>.<span class="number">02</span>  <span class="number">43</span>.<span class="number">12</span>   <span class="number">15</span>.<span class="number">22</span>    <span class="number">16</span>.<span class="number">79</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">8</span>.<span class="number">75</span>     <span class="number">1</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">8</span>.<span class="number">75</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">03</span></span><br></pre></td></tr></table></figure><ol><li><strong>rrqm/s:</strong>  每秒进行 merge 的读操作数目。即 rmerge/s</li><li><strong>wrqm/s:</strong>  每秒进行 merge 的写操作数目。即 wmerge/s</li><li><strong>r/s:</strong>  每秒完成的读 I/O 设备次数。即 rio/s</li><li><strong>w/s:</strong>  每秒完成的写 I/O 设备次数。即 wio/s</li><li><strong>rkB/s:</strong>  每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</li><li><strong>wkB/s:</strong>  每秒写K字节数。是 wsect/s 的一半。</li><li><strong>avgrq-sz:</strong>  平均每次设备I/O操作的数据大小 (扇区)。</li><li><strong>avgqu-sz:</strong>  平均I/O队列长度。</li><li><strong>rsec/s:</strong>  每秒读扇区数。即 rsect/s</li><li><strong>wsec/s:</strong>  每秒写扇区数。即 wsect/s</li><li>**r_await:**每个读操作平均所需的时间</li><li>不仅包括硬盘设备读操作的时间，还包括了在kernel队列中等待的时间。</li><li>**w_await:**每个写操作平均所需的时间</li><li>不仅包括硬盘设备写操作的时间，还包括了在kernel队列中等待的时间。</li><li><strong>await:</strong> 平均每次设备I/O操作的等待时间 (毫秒)。</li><li><strong>svctm:</strong> 平均每次设备I/O操作的服务时间 (毫秒)。</li><li><strong>%util:</strong>  一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</li></ol><blockquote><p>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。</p><p>如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间</p><p>如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化</p><p>如果avgqu-sz比较大，也表示有当量io在等待。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件描述符和进程数调优</title>
      <link href="/posts/b379b34f.html"/>
      <url>/posts/b379b34f.html</url>
      
        <content type="html"><![CDATA[<h1>问题描述</h1><ul><li><p>文件描述符</p><p><code>Too many open files</code>是Linux系统中常见的错误,从字面意思上看就是说程序打开的文件数过多,其实files不单是文件的意思,也包括打开的通讯链接(比如socket),正在监听的端口等等,也可以叫做句柄(handle),这个错误通常也可以叫做<code>句柄数超出系统限制</code></p></li><li><p>用户打开进程数</p><p><code>no more progres</code>或者是<code>Resource temporarily unavailable</code>,是没有更多的进程可用,产生的原因可能有</p><ol><li>用户的nproc达到限制，无法创建新的进程</li><li>系统没有可分配的的pid，即进程号已经达到内核参数kernel.pid_max的限制</li><li>系统可用内存低，新的进程无法申请到内存导致不能启动</li></ol><p>nproc是操作系统级别对每个用户创建的进程数的限制,在Linux下运行多线程时,每个线程的实现其实是一个轻量级的进程,对应的术语是:light weight process(LWP)</p></li></ul><h1>产生的原因</h1><p>Linux操作系统中利用<code>ulimit</code>限制shell启动进程占用的资源,ulimit支持对用户的<code>打开进程数</code>、<code>进程打开文件句柄数</code>、<code>进程打开文件的大小</code>、进程coredump文件`大小等资源进行限制，从而防止某个用户进程过度占用系统资源，避免影响整个操作系统和其他应用的正常运行。但是使用ulimit进行限制后，当用户资源超限制时会出现各种各样的报错</p><h1>文件描述符达到上限</h1><h2 id="修改上限file-max">修改上限file-max</h2><p>这是<code>系统级</code>参数,file-max是查看所有进程的打开文件数量的系统范围限制,即系统可打开的最大数量,但日志里面报&quot;file-max reached&quot;的时候才去修改</p><ul><li>查看file-max数值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max  </span><br></pre></td></tr></table></figure><p>file-max的值也也和下面有近似</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r MemTotal /proc/meminfo | awk &#x27;&#123;printf(&quot;%d&quot;,$2/10)&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="修改方法">修改方法</h3><ul><li>写入sysctl.conf</li></ul><p>重启生效,建议先用临时设定确定一个值之后写入配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;fs.file-max = 6553560&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><p>重启恢复默认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo  6553560 &gt; /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w &quot;fs.file-max=6553560&quot;</span><br></pre></td></tr></table></figure><h2 id="修改nr-open">修改nr_open</h2><p>这是<code>进程级</code>的参数,查看单个进程可以打开的最大文件数</p><ul><li>查看</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/nr_open   #输出1048576即是1024*1024,正好是100万</span><br></pre></td></tr></table></figure><h3 id="修改方法-2">修改方法</h3><ul><li>写入sysctl.conf</li></ul><p>重启生效,建议先用临时设定确定一个值之后写入配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;fs.nr_open=100000000&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><p>,重启恢复默认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo  100000000 &gt; /proc/sys/fs/nr_open</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><p>重启恢复默认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w &quot;fs.nr_open=100000000&quot;</span><br></pre></td></tr></table></figure><h2 id="查看file-nr">查看file-nr</h2><p>他其实就是一个统计,输出<code>当前打开的文件数</code>,<code>空闲文件句柄数量</code>,<code>文件句柄的最大数量(file-max)</code>三列值,这是一个只读文件,是拿来看资源的,不用修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-nr   #输出55040195620</span><br></pre></td></tr></table></figure><h2 id="修改limits-conf">修改limits.conf</h2><p>既可以用<code>ulimit命令</code>来修改,也可以<code>写进系统的配置文件</code></p><blockquote><p>注意</p><ol><li><p>nofile是打开最大文件数, 对应limits.conf的nofile参数,重启生效</p></li><li><p>soft要小于hard</p></li><li><p>nofile的值需要小于等于nr_open的值</p></li></ol></blockquote><ul><li>修改成如下</li></ul><p>将所有用户的对<code>文件描述符</code>的限制都改成6553500</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 6553500</span><br><span class="line">* hard nofile 6553500</span><br></pre></td></tr></table></figure><h2 id="分析系统">分析系统</h2><p>其实<code>调优</code>只是释放资源的一种手段,更重要的是找出原因,可能是业务某个时间段业务量激增,也可能是应用触发了某个bug</p><ul><li>统计各命令打开句柄数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure><ul><li>统计各进程打开句柄数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &#x27;&#123;print $2&#125;&#x27; | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure><ul><li>统计各用户打开句柄数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &#x27;&#123;print $3&#125;&#x27; | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure><h2 id="复现方法">复现方法</h2><p>将我们的资源临时改成<code>6</code>,此时类似<code>top</code>或者<code>lsof</code>等命令就已经不能用了,因为他们产生的句柄会很多,而我们只限制只能打开<code>6</code></p><ul><li>临时修改nofile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 6</span><br></pre></td></tr></table></figure><ul><li>随便输入某些命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><ul><li>触发报错</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span>: failed <span class="attribute">openproc</span>: Too many open files</span><br></pre></td></tr></table></figure><h1>用户最大进程数量达到上限</h1><p>在rhel6和7上面,这个参数默认对root没有限制,他是从内核继承的,对于其他用户来说就4096,是根据下面的文件设定的</p><ul><li>CentOS6中limits.d下面是90-nproc.conf</li><li>CentOS7中limits.d下面是20-nproc.conf</li></ul><h2 id="如何查看">如何查看</h2><ul><li>查看所有用户创建的进程数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps h -Led -o user | sort | uniq -c | sort -n</span><br></pre></td></tr></table></figure><ul><li>指定某个用户查看创建的进程数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o nlwp,pid,lwp,args -u root | sort -n</span><br></pre></td></tr></table></figure><h2 id="修改xx-nproc-conf文件">修改xx-nproc.conf文件</h2><p>将第一行的nproc的值放大,我一般是改成4096,如果还不够继续放大</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*          soft    nproc     1024</span><br><span class="line">root       soft    nproc     unlimite</span><br></pre></td></tr></table></figure><h2 id="如何生效">如何生效</h2><p>有2种方法如下,任选其中之一</p><ul><li>本地注销桌面或者退出终端重新登陆</li><li>重启最好</li></ul><h2 id="验证结果">验证结果</h2><h3 id="对于bash用户">对于bash用户</h3><ul><li>查看方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><p>修改的是<code>nproc</code>参数,对应<code>max user processes</code>字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">real-time non-blocking time  (microseconds, -R) unlimited</span><br><span class="line">core file size              (blocks, -c) unlimited</span><br><span class="line">data seg size               (kbytes, -d) unlimited</span><br><span class="line">scheduling priority                 (-e) 0</span><br><span class="line">file size                   (blocks, -f) unlimited</span><br><span class="line">pending signals                     (-i) 61604</span><br><span class="line">max locked memory           (kbytes, -l) 64</span><br><span class="line">max memory size             (kbytes, -m) unlimited</span><br><span class="line">open files                          (-n) 65535</span><br><span class="line">pipe size                (512 bytes, -p) 8</span><br><span class="line">POSIX message queues         (bytes, -q) 819200</span><br><span class="line">real-time priority                  (-r) 0</span><br><span class="line">stack size                  (kbytes, -s) 8192</span><br><span class="line">cpu time                   (seconds, -t) unlimited</span><br><span class="line">max user processes                  (-u) 61604</span><br><span class="line">virtual memory              (kbytes, -v) unlimited</span><br><span class="line">file locks                          (-x) unlimited</span><br></pre></td></tr></table></figure><h3 id="对于tcsh用户">对于tcsh用户</h3><ul><li>查看方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><p>修改的是<code>nproc</code>参数,对应<code>maxproc</code>字段</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cputime</span>      unlimited</span><br><span class="line"><span class="attribute">filesize</span>     unlimited</span><br><span class="line"><span class="attribute">datasize</span>     unlimited</span><br><span class="line"><span class="attribute">stacksize</span>    <span class="number">8192</span> kbytes</span><br><span class="line"><span class="attribute">coredumpsize</span> unlimited</span><br><span class="line"><span class="attribute">memoryuse</span>    unlimited</span><br><span class="line"><span class="attribute">vmemoryuse</span>   unlimited</span><br><span class="line"><span class="attribute">descriptors</span>  <span class="number">65535</span> </span><br><span class="line"><span class="attribute">memorylocked</span> <span class="number">64</span> kbytes</span><br><span class="line"><span class="attribute">maxproc</span>      <span class="number">61604</span> </span><br><span class="line"><span class="attribute">maxlocks</span>     unlimited</span><br><span class="line"><span class="attribute">maxsignal</span>    <span class="number">61604</span> </span><br><span class="line"><span class="attribute">maxmessage</span>   <span class="number">819200</span> </span><br><span class="line"><span class="attribute">maxnice</span>      <span class="number">0</span> </span><br><span class="line"><span class="attribute">maxrtprio</span>    <span class="number">0</span> </span><br><span class="line"><span class="attribute">maxrttime</span>    unlimited</span><br></pre></td></tr></table></figure><h2 id="复现方法-2">复现方法</h2><ul><li>将普通用户的nproc临时修改</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ulimit</span> -u  <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>简单写个test.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        pid=fork();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count= %d\n&quot;</span>,count);&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="keyword">test</span>.c -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><ul><li>执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure><ul><li>报错</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: fork: retry: 资源暂时不可用</span><br></pre></td></tr></table></figure><h1>想法</h1><ul><li><p>[x] <code>limits.conf和xx-nproc.conf都支持修改</code>nproc<code>,为什么就改xx-nproc.conf? </code>因为/etc/security/limits.d/里面的文件里面的配置会覆盖/etc/security/limits.conf的配置</p></li><li><p>[x] <code>顺序</code>?soft&lt;hard&lt;nr_open&lt;file-max</p></li><li><p>[ ] <code>文件描述符的上限在哪?</code></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for  V in `seq  100000  10000000` ; do ulimit -n $V ; [[ $? != 0 ]] &amp;&amp; break;done</span><br></pre></td></tr></table></figure><ul><li><p>[x] <code>lsof是否可以用来排查这俩个报错?</code>lsof可以看打开的文件数量,用ps看进程数量</p></li><li><p>[x] <code>file-max的上限在哪里呢?</code>只要你的内存足够大，file-max的值可以非常大(大概这么说)</p></li><li><p>[x] <code>nproc的最大是在哪里?</code></p></li></ul><p>这个数字在centos8(不包括8)是和配置显示一致的,在8之后由内核决定,通过下面的命令,可以计算出我们可以配置的最大的nproc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(($(cat /proc/sys/kernel/threads-max)/2))</span><br></pre></td></tr></table></figure><ul><li>[x] 之前一直拿root做实验,其实得用普通用户来验证所有的效果,就比如nproc,root和普通用户看到是不一样的,明显默认root就会多一点,而普通用户是根据配置来的</li></ul><h1>推荐阅读</h1><ol><li><a href="https://xie.infoq.cn/article/30eeb766ecfac245cc96c45c6">https://xie.infoq.cn/article/30eeb766ecfac245cc96c45c6</a></li><li><a href="https://www.cnblogs.com/Chary/p/15842219.html">https://www.cnblogs.com/Chary/p/15842219.html</a></li><li><a href="https://blog.csdn.net/cnbird2008/article/details/8666620">https://blog.csdn.net/cnbird2008/article/details/8666620</a></li><li><a href="https://elixir.bootlin.com/linux/latest/source">linux内核代码</a></li><li><a href="https://elixir.bootlin.com/linux/v5.10.143/source/kernel/fork.c#L2523">kernel/forc.c,内核定义的nproc最大值,810行左右</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git拉取总是需要密码</title>
      <link href="/posts/e07e5f84.html"/>
      <url>/posts/e07e5f84.html</url>
      
        <content type="html"><![CDATA[<h1>解决办法</h1><ul><li>先在本地git仓库下执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><ul><li>然后拉取</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><ul><li>此时他会提示输入密码,完成验证之后就可以了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之nmcli</title>
      <link href="/posts/6ad86d1e.html"/>
      <url>/posts/6ad86d1e.html</url>
      
        <content type="html"><![CDATA[<h1>NetworkManager</h1><ol><li>NetworkManager服务是管理和监控网络设置的守护进程,Centos7之前的版本都是通过network.service管理网络配置</li><li>到了Centos7就同时支持network.service和NetworkManager.service</li><li>在RHEL 8/Centos 8上已废弃network.service（默认不安装）,只能通过NetworkManager进行网络配置。</li><li>NetworkManager主要管理2个对象 <code>Connection</code>（网卡连接配置） 和 <code>Device</code>（网卡设备）,他们之间是多对一的关系,但是同一时刻只能有一个Connection对于Device才生效</li></ol><h1>启动方法</h1><p>启动+开机自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now NetworkManager</span><br></pre></td></tr></table></figure><h1>三种方法配置网络</h1><ol><li>通过nmcli connection add命令配置,会自动生成ifcfg文件</li><li>手动配置ifcfg文件,通过nmcli connection reload来加载生效</li><li>手动配置ifcfg文件,通过传统network.service来加载生效</li></ol><h1>nmcli基操</h1><p>NetworkManager在系统中的管理工具为nmcli,这个命令<code>嘎嘎好用</code></p><h2 id="查看所有连接">查看所有连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show </span><br></pre></td></tr></table></figure><h2 id="查看所有激活的连接">查看所有激活的连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show --active</span><br></pre></td></tr></table></figure><h2 id="查看指定的网口的连接">查看指定的网口的连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show eth0</span><br></pre></td></tr></table></figure><h2 id="关闭连接">关闭连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection down eth0</span><br></pre></td></tr></table></figure><h2 id="启用连接">启用连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up eth0</span><br></pre></td></tr></table></figure><h1>nmcli配置网络实例-dhcp</h1><h2 id="新增连接">新增连接</h2><ul><li>创建一个连接名<code>dachui</code>,使用ens33设备</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui type Ethernet ifname ens33</span><br></pre></td></tr></table></figure><h2 id="展示创建后的效果">展示创建后的效果</h2><p>(实在不想配图)<br>可以看出只有一个行<code>NAME</code>是ens33是激活的(因为激活的连接在终端显示绿色,或者用–active可以看出来)</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME    UUID                                  TYPE      DEVICE </span><br><span class="line">ens33   c96bc909-188e-ec64-3a96-6a90982b08ad  ethernet  ens33  </span><br><span class="line">dachui  4b27c0d3-17d5-434b-90d1-5ac57a0f6147  ethernet  --     </span><br><span class="line">ens34   94aea789-efb3-ef4c-81b0-e8b18ecc9797  ethernet  -- </span><br></pre></td></tr></table></figure><h2 id="查看dachui的配置">查看<code>dachui</code>的配置</h2><p>如果不加<code>grep</code>,他会显示很多信息,但我们只需要关注ipv4的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show dachui | grep ipv4</span><br></pre></td></tr></table></figure><h2 id="配置展示">配置展示</h2><p>可以看出第一行<code>ipv4.method</code>的是<code>auto</code>,他代表<code>dachui</code>这个连接是用<code>dhcp</code>的方式获取ip的</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ipv4.method:                            auto</span><br><span class="line">ipv4.dns:                               --</span><br><span class="line">ipv4.dns-search:                        --</span><br><span class="line">ipv4.dns-options:                       &quot;&quot;</span><br><span class="line">ipv4.dns-priority:                      0</span><br><span class="line">ipv4.addresses:                         --</span><br><span class="line">ipv4.gateway:                           --</span><br><span class="line">ipv4.routes:                            --</span><br><span class="line">ipv4.route-metric:                      -1</span><br><span class="line">ipv4.route-table:                       0 (unspec)</span><br><span class="line">ipv4.routing-rules:                     --</span><br><span class="line">ipv4.ignore-auto-routes:                否</span><br><span class="line">ipv4.ignore-auto-dns:                   否</span><br><span class="line">ipv4.dhcp-client-id:                    --</span><br><span class="line">ipv4.dhcp-timeout:                      0 (default)</span><br><span class="line">ipv4.dhcp-send-hostname:                是</span><br><span class="line">ipv4.dhcp-hostname:                     --</span><br><span class="line">ipv4.dhcp-fqdn:                         --</span><br><span class="line">ipv4.never-default:                     否</span><br><span class="line">ipv4.may-fail:                          是</span><br><span class="line">ipv4.dad-timeout:                       -1 (default)</span><br></pre></td></tr></table></figure><h2 id="激活dhcp">激活dhcp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con show ens33 | grep IP4</span><br></pre></td></tr></table></figure><ul><li>激活的结果<br>可以看出这边ipv4的地址已经自动获取了</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP4.ADDRESS[1]:                         192.168.42.135/24</span><br><span class="line">IP4.GATEWAY:                            192.168.42.2</span><br><span class="line">IP4.ROUTE[1]:                           dst = 0.0.0.0/0, nh = 192.168.42.2, mt = 102</span><br><span class="line">IP4.ROUTE[2]:                           dst = 192.168.42.0/24, nh = 0.0.0.0, mt = 102</span><br><span class="line">IP4.DNS[1]:                             192.168.42.2</span><br><span class="line">IP4.DOMAIN[1]:                          localdomain</span><br></pre></td></tr></table></figure><h1>nmcli配置网络实例-static</h1><p>刚才是展示的新增一个连接,使用默认的<code>dhcp</code>方式配置网络,但实际项目中需要使用静态ip的方式,配置静态的手段有很多,可以对现在有<code>连接</code>进行系iu改,也可以再创建一个<code>连接</code>并且同时指定他的ip地址</p><h2 id="一次性创建">一次性创建</h2><p>乍一看命令<code>嘎嘎</code>长,其实很简单</p><ul><li><code>嘎嘎</code>长的命令,其实可以更长</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui-static type ethernet ifname ens33 ipv4.method manual ipv4.address 192.168.42.5/24 ipv4.gateway 192.168.42.2</span><br></pre></td></tr></table></figure><blockquote><p>我拆开两部分分析</p></blockquote><ol><li>创建连接,指定模式<br>这边就是创建了<code>dahcui-static</code>的连接,使用<code>type</code>指定此连接为<code>ethernet</code>(以太网),并且设备是<code>ens33</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui-static type ethernet ifname ens33</span><br></pre></td></tr></table></figure><ol start="2"><li>配置网络要素<br>一个ip地址至少需要指定一个<code>ip</code>和<code>子网掩码</code>才可以生效,网关也是需要配置的,还有指定是手动</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ipv4</span>.method manual ipv4.address <span class="number">192.168.42.5</span>/<span class="number">24</span> ipv4.gateway <span class="number">192.168.42.2</span></span><br></pre></td></tr></table></figure><ul><li>激活连接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static | grep IP4</span><br></pre></td></tr></table></figure><blockquote><p>输出为下面的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP4.ADDRESS[1]:                         192.168.42.5/24</span><br><span class="line">IP4.GATEWAY:                            192.168.42.2</span><br><span class="line">IP4.ROUTE[1]:                           dst = 0.0.0.0/0, nh = 192.168.42.2, mt = 102</span><br><span class="line">IP4.ROUTE[2]:                           dst = 192.168.42.0/24, nh = 0.0.0.0, mt = 102</span><br><span class="line">IP4.DNS[1]:                             192.168.42.2</span><br><span class="line">IP4.DOMAIN[1]:                          localdomain</span><br></pre></td></tr></table></figure><h2 id="编辑连接">编辑连接</h2><p>如果之前是创建好了多个连接,但是需要修改,可以通过modify的方法</p><ul><li>提示一点<br>如果要修改,请看好原先的<code>连接</code>是<code>自动获取</code>还是<code>手动获取</code>,如果是自动,需要改模式</li></ul><blockquote><p>可以一并加入修改的,我只是拆开提示一下,遇到过一次改了半天没生效,一看连接方式是dhcp</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static ipv4.method manual </span><br></pre></td></tr></table></figure><ul><li>修改ip<br>也可以修改其他的,在输入<code>dachui-static</code>之后按<code>tap</code>会列举出所有的<code>配置项</code>,然后根据语法修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static ipv4.address 192.168.42.200/24</span><br></pre></td></tr></table></figure><ul><li>重启网卡<br>修改之后需要激活一下才能生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static</span><br></pre></td></tr></table></figure><blockquote><p>这样一个基本的nmlci创建连接就结束了</p></blockquote><h1>其他基操</h1><h2 id="增加路由">增加路由</h2><p>内网环境下,机器可能有多个网段,那么加路由肯定是必须的,比如我这需要访问<code>10.10.10.0/24</code>的机器,那么通过如下方法进行配置</p><ul><li>加路由</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static +ipv4.routes &quot;10.10.10.0/24 192.168.42.2&quot;</span><br></pre></td></tr></table></figure><ul><li>激活看信息</li></ul><ol><li>配置信息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP4.ROUTE[5]:                           dst = 10.10.10.0/24, nh = 192.168.42.2, mt = 102</span><br></pre></td></tr></table></figure><ol start="2"><li>路由信息</li></ol><ul><li>route展示</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><ul><li>输出结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.42.2    0.0.0.0         UG    102    0        0 ens33</span><br><span class="line">10.10.10.0      192.168.42.2    255.255.255.0   UG    102    0        0 ens33</span><br></pre></td></tr></table></figure><h2 id="删除路由">删除路由</h2><p>学会增加,也要学会删除</p><ul><li><code>乍一看</code>是不是一样的?其实将<code>+</code>改成<code>-</code>,然后<code>重新激活</code>就可以了</li></ul><blockquote><p>所以修改的逻辑很简单的,<code>+</code>就增加,<code>-</code>就是删除,<code>什么都不加</code>就是修改</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static -ipv4.routes &quot;10.10.10.0/24 192.168.42.2&quot;</span><br></pre></td></tr></table></figure><h2 id="增加ip">增加ip</h2><p>有时候需要在一个连接上加多个ip地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static +ipv4.addresses 2.2.2.2/16</span><br></pre></td></tr></table></figure><h2 id="删除连接">删除连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection delete dachui-static</span><br></pre></td></tr></table></figure><h2 id="网卡开机自启动">网卡开机自启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static autoconnect yes</span><br></pre></td></tr></table></figure><h1>nmtui</h1><p>其实nmcli的玩法有很多,但其实还有一个工具<code>nmtui</code>,他是<code>NetworkManager-tui</code>的一个工具,通过字符图形化配置网络</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之top</title>
      <link href="/posts/5285e72b.html"/>
      <url>/posts/5285e72b.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>top命令的功能是用于实时显示系统运行状态，包含处理器、内存、服务、进程等重要资源信息</p><h1>语法格式</h1><p>top [参数]</p><h1>用法</h1><h2 id="基本用法">基本用法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><h2 id="指定刷新时间">指定刷新时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -d 1</span><br></pre></td></tr></table></figure><h2 id="显示进程的命令行参数">显示进程的命令行参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -c</span><br></pre></td></tr></table></figure><h2 id="监视指定进程">监视指定进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 5201 -p 54231</span><br></pre></td></tr></table></figure><h2 id="显示指定用户">显示指定用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -u root</span><br></pre></td></tr></table></figure><blockquote><p>我的top输出</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 23:15:06 up 21 min,  3 users,  load average: 1.19, 0.72, 0.32</span><br><span class="line">Tasks: 191 total,   3 running, 144 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  1.5 us,  3.0 sy,  0.0 ni, 95.0 <span class="built_in">id</span>,  0.0 wa,  0.5 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  4009048 total,  2791500 free,   493780 used,   723768 buff/cache</span><br><span class="line">KiB Swap:   839676 total,   839676 free,        0 used.  3218592 avail Mem </span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                        </span><br><span class="line">8671 root      20   0  511852 105736  43568 S   4.0  2.6   0:04.58 X                                                                                              </span><br><span class="line">9872 root      20   0  702884  46780  35292 S   2.0  1.2   0:00.81 mate-terminal                                                                                        </span><br></pre></td></tr></table></figure><h1>top的交互功能</h1><ul><li>在top基本视图中，敲击c键，可以显示进程的路径</li><li>在top基本视图中，敲击k键，可以在不退出top命令的情况下杀死某个正在运行的进程</li><li>在top基本视图中，敲击1键，可监控每个逻辑CPU的状况</li><li>在top基本视图中，敲击上下键，可以增减显示的进程数目</li></ul><h1>top输出解释</h1><h2 id="第一行-基本信息">第一行-基本信息</h2><h3 id="系统当前时间">系统当前时间</h3><p>top - 23:15:06</p><h3 id="系统运行时间">系统运行时间</h3><p>up 21 min</p><h3 id="当前登录用户数量">当前登录用户数量</h3><p>3 users</p><h3 id="负载均衡情况">负载均衡情况</h3><p>load average: 1.19, 0.72, 0.32<br>三个数分别是1分钟、5分钟、15分钟的负载情况</p><blockquote><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以<code>逻辑CPU</code>的数量，结果高于5的时候就表明系统在超负荷运转了</p></blockquote><h2 id="第二行-进程">第二行-进程</h2><h3 id="总进程">总进程</h3><p>Tasks: 191 total</p><h3 id="当前运行进程数量">当前运行进程数量</h3><p>3 running</p><h3 id="休眠进程数量">休眠进程数量</h3><p>144 sleeping</p><h3 id="停止进程数量">停止进程数量</h3><p>0 stopped,</p><h3 id="僵尸进程数量">僵尸进程数量</h3><p>0 zombie</p><blockquote><p>在unix/linux中，正常情况下,子进程是通过父进程创建的,子进程在创建新的进程,子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束.当一个进程完成它的工作终止之后,它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态</p></blockquote><ul><li>孤儿进程<br>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li><li>僵尸进程<br>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</li></ul><h2 id="第三行-cpu状态">第三行-cpu状态</h2><h3 id="us">us</h3><p>用户空间占用CPU的百分比</p><h3 id="sy">sy</h3><p>内核空间占用CPU的百分比</p><h3 id="ni">ni</h3><p>改变过优先级的进程占用CPU的百分比</p><h3 id="id">id</h3><p>空闲CPU百分比</p><h3 id="wa">wa</h3><p>IO等待占用CPU的百分比</p><h3 id="hi">hi</h3><p>硬中断占用CPU的百分比</p><h3 id="si">si</h3><p>软中断占用CPU的百分比</p><h3 id="st">st</h3><p>当Linux系统是在虚拟机中运行时，等待CPU资源的时间占比</p><blockquote><p>简单说，Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p></blockquote><ul><li>Kernel space<br>用户空间可以执行任意命令，调用系统的一切资源；</li><li>User space<br>内核空间只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令</li></ul><h2 id="第四行-内存状态">第四行-内存状态</h2><h3 id="total">total</h3><p>总内存量4009048</p><h3 id="free">free</h3><p>空闲内存2791500</p><h3 id="used">used</h3><p>已用内存493780</p><h3 id="buff-cache">buff/cache</h3><p>缓存内存723768</p><blockquote><p>KiB Mem：Kib表示描述单位，MEM表示内存</p></blockquote><h2 id="第五行-swap状态">第五行-swap状态</h2><h3 id="total-2">total</h3><p>总内存量839676</p><h3 id="free-2">free</h3><p>空闲内存839676</p><h3 id="used-2">used</h3><p>已用内存0</p><h3 id="avail-Mem">avail Mem</h3><p>可用内存3218592</p><ul><li>free 是真正尚未被使用的物理内存数量。</li><li>available 是应用程序认为可用内存数量，available = free + buffer + cache (注：只是大概的计算方法)</li></ul><h2 id="第六行-进程监控">第六行-进程监控</h2><ul><li>PID — 进程id</li><li>USER — 进程所有者</li><li>PR — 进程优先级</li><li>NI — nice值。负值表示高优先级，正值表示低优先级</li><li>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li><li>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li><li>SHR — 共享内存大小，单位kb</li><li>S — 进程状态。D=不可中断的睡眠状态；R=运行；S=睡眠；T=跟踪/停止；Z=僵尸进程</li><li>%CPU — 上次更新到现在的CPU时间占用百分比</li><li>%MEM — 进程使用的物理内存百分比</li><li>TIME+ — 进程使用的CPU时间总计，单位1/100秒</li><li>COMMAND — 进程名称（命令名/命令行）</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之systemctl</title>
      <link href="/posts/5154c07a.html"/>
      <url>/posts/5154c07a.html</url>
      
        <content type="html"><![CDATA[<h1>概念</h1><ul><li>systemd<br>systemd是与SysV和LSB初始化脚本兼容的系统和服务管理器,开启systemd服务,可以基于守护进程按需启动策略<br>systemd服务支持快照和系统状态恢复,维护挂载和自动挂载点,服务之间的从属关系也有逻辑控制</li><li>systemd unit<br>system服务的开启和监督系统是基于unit的,unit就是一个与配置文件对应的名称和类型组成,unit的类型如下</li></ul><ol><li>service unit 系统服务</li><li>Target unit 一组systemd units</li><li>Automount unit 文件系统挂载点</li><li>Device unit  内核识别的设备文件</li><li>Mount unit   文件系统挂载点</li><li>Path unit    一个文件系统中的文件或目录</li><li>Scope unit  外部创建的进程</li><li>Snapshot unit   systemd manager  的保存状态</li></ol><ul><li>systemd的特性</li></ul><ol><li>更快的启动速度</li><li>按需启动能力</li><li>采用cgroup特性跟踪和管理进程的生命周期</li><li>采用挂载点和自动挂载的管理</li><li>实现事务依赖性关系管理</li><li>与SysV初始化脚本兼容</li><li>对系统进程快照和恢复</li></ol><h1>管理服务</h1><p>用systemctl命令管理进行 运行 启动 重启 显示 自启动 关闭自启动 等</p><h1>基操</h1><h2 id="显示运行的服务">显示运行的服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type service</span><br></pre></td></tr></table></figure><h2 id="显示所有的服务">显示所有的服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type service --all</span><br></pre></td></tr></table></figure><h2 id="查看服务状态">查看服务状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status httpd</span><br></pre></td></tr></table></figure><ul><li>显示指标<br>loaded: 说明服务是否被加载,同时显示对应的绝对路径是否启用<br>active: 是否运行<br>main pid: 进程pid<br>cgroup: 相关控制组的其他信息</li></ul><h2 id="管理服务的基操">管理服务的基操</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start sshd</span><br><span class="line">systemctl stop  sshd</span><br><span class="line">systemctl restart sshd</span><br><span class="line">systemctl enable sshd</span><br><span class="line">systemctl disable sshd</span><br></pre></td></tr></table></figure><h2 id="操作系统电源">操作系统电源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl poweroff  #关闭系统,下电</span><br><span class="line">systemctl halt      #关闭系统,不下电</span><br><span class="line">systemctl reboot    #重启</span><br><span class="line">systemctl suspend   #待机</span><br><span class="line">systemctl hibernate  #休眠</span><br><span class="line">systemctl hybrid-sleep #待机+休眠</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之dnf</title>
      <link href="/posts/a36cc04b.html"/>
      <url>/posts/a36cc04b.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>DNF:Dandified YUM,是基于RPM的Linux发行版的软件包管理器,它用于在 Fedora / RHEL / CentOS操作系统中安装,更新和删除软件包,目前 DNF 命令和yum命令相互兼容,软件包仓库依旧使用 YUM 仓库。</p><h1>注意</h1><p>dnf和yum的基础命令都是兼容的,但是dnf默认安装了很多插件,后会出一个插件的学习记录</p><h1>配置dnf</h1><ul><li>dnf主要配置文件<br>/etc/dnf/dnf.conf<br>在rockylinux和centos9stream系统中/etc/yum.conf是指向dnf.conf的软链接,内容如下</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">installonly_limit</span>=<span class="number">3</span></span><br><span class="line"><span class="attr">clean_requirements_on_remove</span>=<span class="literal">True</span></span><br><span class="line"><span class="attr">best</span>=<span class="literal">True</span></span><br><span class="line"><span class="attr">skip_if_unavailable</span>=<span class="literal">False</span></span><br></pre></td></tr></table></figure><p>参数说明</p><ol><li>cachedir:缓存目录,存储rpm包和数据库文件(默认没写,在其他路径)</li><li>best: 升级包的时候总是尝试安装最高版本,如果最高不能装就停止并显示原因</li><li>installonly_limit: 同时安装&quot;installonlypkgs&quot; 指令列出包的数量,默认3,不建议降低</li><li>clean_requirements_on_remove:删除dnf remove期间不在使用的依赖项,即是dnf连带安装的依赖,只能通过此参数为true来删除</li></ol><h1>设置仓库</h1><h2 id="修改dnf源文件">修改dnf源文件</h2><p>还是修改/etc/yum.repos.d下面的repo文件,配置和yum一样</p><h2 id="创建本地源仓库">创建本地源仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install createrepo</span><br></pre></td></tr></table></figure><ul><li>将软件包放在该目录下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createrepo --database /mnt/test </span><br></pre></td></tr></table></figure><h2 id="命令添加源">命令添加源</h2><p>会在/etc/yum.repo.d下生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --add-repo repo_url</span><br></pre></td></tr></table></figure><h1>查看源</h1><ul><li>查看本机配置的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf repolist</span><br></pre></td></tr></table></figure><ul><li>查看具体的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf repolist base</span><br></pre></td></tr></table></figure><h1>启停源</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --set-enable repo_name</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --set-disable repo_name</span><br></pre></td></tr></table></figure><h1>基操</h1><p>基本没yum没有区别</p><ul><li>查</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf search ssh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf provides ssh</span><br></pre></td></tr></table></figure><ul><li>列举安装的包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf list all</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf list openssh</span><br></pre></td></tr></table></figure><ul><li>查看包的信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf info openssh</span><br></pre></td></tr></table></figure><h1>光下载不安装</h1><p>这是一个dnf插件实现的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf download package_name</span><br></pre></td></tr></table></figure><h1>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install httpd</span><br></pre></td></tr></table></figure><h1>卸载软件包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf remove httpd</span><br></pre></td></tr></table></figure><h1>列出详细的组信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf  groups info &quot;开发工具&quot;</span><br></pre></td></tr></table></figure><h1>安装卸载软件包组</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf groups install 软件包组/id</span><br><span class="line">dnf groups remove 软件包组/id</span><br></pre></td></tr></table></figure><h1>检查更新</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf check-update</span><br></pre></td></tr></table></figure><h1>升级软件包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf update</span><br></pre></td></tr></table></figure><h1>升级单独的</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf update 包名</span><br></pre></td></tr></table></figure><h1>升级组</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf group update group_name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之xz</title>
      <link href="/posts/2307c602.html"/>
      <url>/posts/2307c602.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>用来压缩文件的命令</p><h1>用法</h1><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -Jcf a.tar.xz  shell/</span><br></pre></td></tr></table></figure><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xz -z a.txt</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -Jxf a.tar.xz</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xz -d  a.tar.xz</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之zip</title>
      <link href="/posts/e416da7.html"/>
      <url>/posts/e416da7.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>日常工作中,我们在linux发行版直接一般不用zip,但为了和windows一起分享资料,可以用zip打包</p><h1>压缩</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip a.zip  shell/</span><br></pre></td></tr></table></figure><h1>解压</h1><p>unzip a.zip</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之bizp2</title>
      <link href="/posts/29735a96.html"/>
      <url>/posts/29735a96.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>压缩的,不能压缩文件夹</p><h1>用法</h1><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 a.txt</span><br></pre></td></tr></table></figure><ul><li>覆盖原文件压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -f a.txt</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -dv a.txt.bz2</span><br></pre></td></tr></table></figure><ul><li>模拟解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -tv a.txt.bz2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之gzip</title>
      <link href="/posts/eda8d2e4.html"/>
      <url>/posts/eda8d2e4.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>可以压缩文件节省磁盘 60%~70%的压缩率,但不能压文件夹</p><h1>操作</h1><ul><li>压缩文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -v a.txt</span><br></pre></td></tr></table></figure><ul><li>解压文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dv  a.txt.gz</span><br></pre></td></tr></table></figure><ul><li>列出压缩文件内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -l a.txt.gz</span><br></pre></td></tr></table></figure><ul><li>递归压缩(不是压缩文件,是分别压缩文件夹下的文件)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -r shell/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之at</title>
      <link href="/posts/5fbf421d.html"/>
      <url>/posts/5fbf421d.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>额,暂时没用到,一次性的定时任务</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之dos2unix</title>
      <link href="/posts/816f4133.html"/>
      <url>/posts/816f4133.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>由于windows上文件的结束符和linux上的不同，那么在windows上编写的文件或者是脚本在Linux上就会遇到类似于下面的错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh^M: bad interpreter: No such file or directory</span><br></pre></td></tr></table></figure><h1>使用方法</h1><h2 id="转换单个文件">转换单个文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dos2unix demo.sh</span><br></pre></td></tr></table></figure><h2 id="转换多个文件">转换多个文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.shell&quot; | xargs dos2unix</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之lscpu</title>
      <link href="/posts/52a81fc0.html"/>
      <url>/posts/52a81fc0.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>查看cpu信息</p><h1>lscpu输出</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Architecture:          x86_64 <span class="comment">#架构，这里的64指的位处理器</span></span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit <span class="comment">#CPU支持的模式：32位、64位</span></span><br><span class="line">Byte Order:            Little Endian <span class="comment">#字节排序的模式，常用小端模式</span></span><br><span class="line">CPU(s):                2 <span class="comment">#逻辑CPU数量</span></span><br><span class="line">On-line CPU(s) list:   0,1 <span class="comment">#在线的cpu数量 有些时候为了省电或者过热的时候，某些CPU会停止运行</span></span><br><span class="line">Thread(s) per core:    2 <span class="comment">#每个核心支持的线程数</span></span><br><span class="line">Core(s) per socket:    1 <span class="comment">#每颗物理cpu的核数</span></span><br><span class="line">Socket(s):             1 <span class="comment">#主板上插CPU的槽的数量，即物理cpu数量</span></span><br><span class="line">NUMA node(s):          1</span><br><span class="line">Vendor ID:             GenuineIntel <span class="comment">#cpu厂商ID</span></span><br><span class="line">CPU family:            6 <span class="comment">#CPU系列</span></span><br><span class="line">Model:                 85 <span class="comment">#CPU型号</span></span><br><span class="line">Model name:            Intel(R) Xeon(R) Gold 6271C CPU @ 2.60GHz</span><br><span class="line">Stepping:              7</span><br><span class="line">CPU MHz:               2593.906 <span class="comment">#cpu主频</span></span><br><span class="line">BogoMIPS:              5187.81 <span class="comment">#MIPS是每秒百万条指令,Bogo是Bogus(伪)的意思，这里是估算MIPS值</span></span><br><span class="line">Hypervisor vendor:     KVM  <span class="comment">#cpu支持的虚拟化技术</span></span><br><span class="line">Virtualization type:   full</span><br><span class="line">L1d cache:             32K <span class="comment">#一级高速缓存 dcache 用来存储数据</span></span><br><span class="line">L1i cache:             32K <span class="comment">#一级高速缓存 icache 用来存储指</span></span><br><span class="line">L2 cache:              1024K <span class="comment">#二级缓存</span></span><br><span class="line">L3 cache:              33792K <span class="comment">#三级缓存 缓存速度上 L1 &gt; L2 &gt; L3 &gt; DDR(内存)</span></span><br><span class="line">NUMA node0 CPU(s):     0,1</span><br><span class="line">Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat umip pku ospke avx512_vnni spec_ctrl</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之git</title>
      <link href="/posts/1dd2999d.html"/>
      <url>/posts/1dd2999d.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理,也是Linus Torvalds(大佬)为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件#</p><h1>先说一个坑</h1><p>千万不要用windows来开发shell脚本,就算是要开发也要用好空格(LF),不然到linux就是会报错的,所以用git的时候会将你的代码上传到云端的库,这样别人用的时候要是遇到这个坑心态可能崩溃</p><h1>git架构</h1><h1>git的用法</h1><h2 id="开局操作">开局操作</h2><h3 id="初始化仓库">初始化仓库</h3><p>可以用git创建出一个目录也可以使用一个现有的文件夹做为repo</p><ul><li>指定一个目录作为仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init newrepo  </span><br></pre></td></tr></table></figure><ul><li>又或者是在当前目录下初始化</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">init</span></span><br></pre></td></tr></table></figure><h3 id="添加新文件">添加新文件</h3><p>在仓库编辑保存之后git就会跟踪,此时要把文件提交暂存区,一般是不会输出什么的,不输出就是好事</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add filename</span><br></pre></td></tr></table></figure><h3 id="提交版本">提交版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;写点注释划划水&quot;</span><br></pre></td></tr></table></figure><h2 id="git配置个人信息">git配置个人信息</h2><p>接下来要和平台进行联动,所以要配置一下自己的信息,才能代表你是你</p><h3 id="用户名">用户名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;dddachui&quot;</span><br></pre></td></tr></table></figure><h3 id="email">email</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;xx@xx.com&quot;</span><br></pre></td></tr></table></figure><h2 id="和git服务器联动">和git服务器联动</h2><p>一般来说,如果云端已经有这个项目了,一般是clone这个项目而不是自己新建,也就是说,我们其实可以直接去gitlab,gitee,github,gogs这种平台新建一个仓库,然后在本地克隆,不建议拿自己本地库通过init之后,设置一个远端的仓库然后推送,这样就会导致代码错乱</p><ul><li>克隆仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/xxx/xxx.git</span><br></pre></td></tr></table></figure><p><code>然后自己add和commit之后就可以推送到平台了</code></p><ul><li>推送</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之free</title>
      <link href="/posts/9a6f4fde.html"/>
      <url>/posts/9a6f4fde.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>显示系统中可用和已用内存的量</p><h1>输出的结果</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        total       used        free        shared      buff/cache      available</span><br><span class="line">Mem:    1978        399         223          32         1355            1323</span><br><span class="line">Swap:   2047        0           2047</span><br></pre></td></tr></table></figure><h1>分析下每一列的含义</h1><h2 id="total">total</h2><p>是安装的总内存大小,MemTotal和SwapTotal可以在<code>/proc/meminfo</code>中查看</p><h2 id="used">used</h2><p>使用的内存大小</p><p>used=total - free - buffers - cache</p><h2 id="free">free</h2><p>没有使用的内存,Mem free和Swap free可以在<code>/proc/meminfo</code>中查看,真正尚未被使用的物理内存数量</p><h2 id="shared">shared</h2><p>表示进程共享的内存,大部分被tmpfs用了,在<code>/proc/meminfo</code>中查看Shmem</p><h2 id="buff">buff</h2><p>内核缓冲区使用的内存,在<code>/proc/meminfo</code>中查看Buffers</p><h2 id="cache">cache</h2><p>页面缓存和slabs使用的内存,在<code>/proc/meminfo</code>中查看Cached和Slab</p><h2 id="buff-cache">buff/cache</h2><p>buff+cacahe</p><h2 id="available">available</h2><p>估计有多少内存可用于<code>启动新应用程序</code>，而不进行交换,应用程序认为可用内存数量</p><p>available = free + buffer/cache - 不可被回收内存(共享内存段、tmpfs、ramfs等)。</p><h2 id="buffers-cache">-buffers/cache</h2><p>表示一个应用程序认为系统被用掉多少内存</p><p>-buffers/cache = used - buffers - cached</p><h2 id="buffers-cache-2">+buffers/cache</h2><p>表示一个应用程序认为系统还有多少内存；<br>+buffers/cache = free + buffers + cached</p><h1>混淆点</h1><h2 id="free和available应该看哪个">free和available应该看哪个</h2><p>Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache,所以对于内核来说，buffer 和 cache 都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，available = free + buffer + cache 这个计算不大可靠,但可以得出这两个是不一样的</p><h1>常用命令</h1><ul><li>free里面以不同单位显示换算是1024哦!</li></ul><h2 id="以Byte显示内存使用情况">以Byte显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -b</span><br></pre></td></tr></table></figure><h2 id="以kb为单位显示内存使用情况">以kb为单位显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -k</span><br></pre></td></tr></table></figure><h2 id="以mb为单位显示内存使用情况">以mb为单位显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><h2 id="以gb为单位显示内存使用情况">以gb为单位显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -g</span><br></pre></td></tr></table></figure><h2 id="持续显示内存">持续显示内存</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -s</span><br></pre></td></tr></table></figure><h2 id="显示内存使用总合">显示内存使用总合</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -t</span><br></pre></td></tr></table></figure><h2 id="以易读的单位显示内存使用情况">以易读的单位显示内存使用情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之md5sum</title>
      <link href="/posts/99132266.html"/>
      <url>/posts/99132266.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>md5sum计算并检查MD5消息摘要</p><h1>常用选项</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-b, --binary       以二进制模式读取文件</span><br><span class="line">-c, --check        从文件中读取MD5的校验值并予以检查</span><br><span class="line">-t, --text   以文本模式读入文件内容</span><br><span class="line">--quiet            只会输出校验不通过的文件</span><br><span class="line">--status           校验完成后，不生成错误或正确的提示信息，可以通过命令的返回值来判断echo $?</span><br><span class="line">--strict           对于格式不正确的校验和行，退出非零</span><br><span class="line">-w, --warn         检查输入的md5信息有没有非法行，若有则输出相应信息</span><br><span class="line">--help   显示此帮助信息并退出</span><br><span class="line">--version   显示版本信息并退出</span><br></pre></td></tr></table></figure><h1>基本用法</h1><h2 id="计算文件的md5">计算文件的md5</h2><p>直接计算文件的md5值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum 文件</span><br></pre></td></tr></table></figure><h2 id="利用md5文件校验">利用md5文件校验</h2><ul><li>计算文件的md5并写入文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum 文件 &gt; file.md5</span><br></pre></td></tr></table></figure><ul><li>使用文件校验<br>如果校验成功会提示,不成功的也会提示</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum -c file.md5</span><br></pre></td></tr></table></figure><h1>其他用法</h1><p>除了直接计算和指定md5文件之外还有其他选项</p><ul><li>计算的时候只输出不符合的文件</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum -c <span class="built_in">file</span>.md5  <span class="comment">--quiet</span></span><br></pre></td></tr></table></figure><ul><li>计算md5之后根据$?来判断是否正确<br>echo $?的返回值0或1</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum -c <span class="built_in">file</span>.md5  <span class="comment">--status</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之pssh</title>
      <link href="/posts/8cf6e4c0.html"/>
      <url>/posts/8cf6e4c0.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>pssh命令是一个python编写可以在多台服务器上执行命令的工具，同时文件的并行复制，杀掉远程主机上的进程等<br>要使用pssh之前,必须配置本地主机和被管理的远程主机之间ssh单向的免秘钥认证,这一点和ansible类似</p><h1>安装</h1><p>配置好软件源之后就可以安装这个工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pssh</span><br></pre></td></tr></table></figure><h1>命令使用</h1><p>安装完pssh之后默认有5个命令</p><ul><li>pssh 在多台远程主机上并行执行命令</li><li>pscp或pscp.pssh 把文件并行复制到多台远程主机上</li><li>pslurp 把文件从多台远程主机上复制到本地</li><li>pnuke 在多台远程主机上并行杀掉某一进程（类似于killall命令）</li><li>prsync 使用rsync协议将文件从本地主机同步到多台远程主机上</li></ul><h2 id="pssh">pssh</h2><p>在多台远程主机上并行执行命令</p><h3 id="常用参数">常用参数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  <span class="comment">--version             显示pssh程序的版本</span></span><br><span class="line">  <span class="comment">--help                显示ssh的命令帮助页面</span></span><br><span class="line">  <span class="operator">-</span>h HOST_FILE, <span class="comment">--hosts=HOST_FILE</span></span><br><span class="line">                        hosts file (每行这么写root<span class="variable">@192</span><span class="number">.168</span><span class="number">.42</span><span class="number">.10</span>:<span class="number">22</span>即[<span class="keyword">user</span>@]host[:port])</span><br><span class="line">  <span class="operator">-</span>H HOST_STRING, <span class="comment">--host=HOST_STRING</span></span><br><span class="line">                        主机字符串(root<span class="variable">@192</span><span class="number">.168</span><span class="number">.42</span><span class="number">.10</span>:<span class="number">22</span>即[<span class="keyword">user</span>@]host[:port])</span><br><span class="line">  <span class="operator">-</span>l <span class="keyword">USER</span>, <span class="comment">--user=USER  远程机器的用户名</span></span><br><span class="line">  <span class="operator">-</span>p PAR, <span class="comment">--par=PAR     一次最大允许多少连接</span></span><br><span class="line">  <span class="operator">-</span>o OUTDIR, <span class="comment">--outdir=OUTDIR</span></span><br><span class="line">                        将输出的内容保持到指定文件中</span><br><span class="line">  <span class="operator">-</span>e ERRDIR, <span class="comment">--errdir=ERRDIR</span></span><br><span class="line">                        错误文件的输出路径</span><br><span class="line">  <span class="operator">-</span>t TIMEOUT, <span class="comment">--timeout=TIMEOUT</span></span><br><span class="line">                        TIMEOUT 超时时间设置，<span class="number">0</span>是无限制</span><br><span class="line">  <span class="operator">-</span>O OPTION, <span class="comment">--option=OPTION</span></span><br><span class="line">                        设置ssh参数的具体配置，参照ssh_config配置文件</span><br><span class="line">  <span class="operator">-</span>v, <span class="comment">--verbose         详细模式</span></span><br><span class="line">  <span class="operator">-</span>A, <span class="comment">--askpass         提示输入密码并且把密码传递给ssh（注意这个参数添加后只是提示作用，随便输入或者不输入直接回车都可以）</span></span><br><span class="line">  <span class="operator">-</span>x ARGS, <span class="comment">--extra-args=ARGS</span></span><br><span class="line">                        传递多个SSH 命令，多个命令用空格分开，用引号括起来</span><br><span class="line">  <span class="operator">-</span>X ARG, <span class="comment">--extra-arg=ARG</span></span><br><span class="line">                        同<span class="operator">-</span>x 但是一次只能传递一个命令</span><br><span class="line">  <span class="operator">-</span>i, <span class="comment">--inline          显示命令执行的标准输出和错误输出</span></span><br><span class="line">  <span class="comment">--inline-stdout       inline standard output for each server</span></span><br><span class="line">  <span class="operator">-</span>I, <span class="comment">--send-input      从标准输入读取并作为输入发送到 ssh</span></span><br><span class="line">  <span class="operator">-</span>P, <span class="comment">--print           显示命令结果</span></span><br></pre></td></tr></table></figure><h3 id="操作单个主机">操作单个主机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -H root@yun -P uptime</span><br></pre></td></tr></table></figure><p>输入结果如下,会显示yun这个机器的执行结果,并反馈执行的状态</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:  21:26:50 up  6:56,  5 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line"><span class="section">[1]</span> 21:26:50 <span class="section">[SUCCESS]</span> 127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="操作多台主机">操作多台主机</h3><ul><li>首先编写host文件</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@node1:22</span><br><span class="line">root@node2:22</span><br></pre></td></tr></table></figure><ul><li>然后执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -h host -i uptime</span><br></pre></td></tr></table></figure><ul><li>执行结果</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[1]</span> 21:27:32 <span class="section">[SUCCESS]</span> 127.0.0.1</span><br><span class="line"> 21:27:32 up  6:57,  5 users,  load average: 0.08, 0.04, 0.05</span><br><span class="line"><span class="section">[2]</span> 21:27:32 <span class="section">[SUCCESS]</span> yun</span><br><span class="line"> 21:27:32 up 34 days,  7:47,  1 user,  load average: 0.03, 0.04, 0.05</span><br></pre></td></tr></table></figure><h3 id="保存每台运行的结果">保存每台运行的结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -h hosts -i -o /tmp/pssh/ uptime</span><br></pre></td></tr></table></figure><p>执行之后他会将每个主机的执行结果分别存入对应主机名的文件之中</p><h2 id="pscp或pscp-pssh">pscp或pscp.pssh</h2><p>把文件并行复制到多台远程主机上</p><h3 id="常用参数-2">常用参数</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  其他的解释和pssh一致,多了一个-r</span><br><span class="line">  -r, <span class="comment">--recursive       递归复制目录</span></span><br></pre></td></tr></table></figure><h3 id="同步单个文件到多个主机">同步单个文件到多个主机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pscp.pssh -h host /etc/hosts /etc</span><br></pre></td></tr></table></figure><h3 id="同步目录到多个主机">同步目录到多个主机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pscp -h host -r /usr/local/test  /tmp</span><br></pre></td></tr></table></figure><h2 id="pslurp">pslurp</h2><p>把文件并行复制到多台远程主机上</p><h3 id="常用参数-3">常用参数</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其他的解释和pssh一致</span><br><span class="line">-r, <span class="comment">--recursive       递归复制目录</span></span><br><span class="line">-L LOCALDIR, <span class="comment">--localdir=LOCALDIR</span></span><br><span class="line">                      将文件从远程主机复制到给定的本地目录</span><br></pre></td></tr></table></figure><h3 id="拷贝远端到本地">拷贝远端到本地</h3><p>将远端的/etc/hosts拷贝到本地/etc/并改名为hosts(不是很会,感觉会出问题)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pslurp -h host -L /etc/hosts /etc hosts</span><br></pre></td></tr></table></figure><h2 id="pnuke">pnuke</h2><p>在多台远程主机上并行杀掉某一进程（类似于killall命令）</p><h3 id="常用参数-4">常用参数</h3><p>和pssh一致</p><h3 id="杀死远程的nginx">杀死远程的nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnuke -h host nginx</span><br></pre></td></tr></table></figure><h2 id="prsync">prsync</h2><p>使用rsync协议将文件从本地主机同步到多台远程主机上</p><h3 id="常用参数-5">常用参数</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">其他解释一致</span><br><span class="line">-r, <span class="comment">--recursive       递归复制目录</span></span><br><span class="line">-<span class="keyword">a</span>, <span class="comment">--archive         use rsync -a (archive mode) (OPTIONAL)</span></span><br><span class="line">-z, <span class="comment">--compress        use rsync compression (OPTIONAL)</span></span><br><span class="line">-S ARGS, <span class="comment">--ssh-args=ARGS</span></span><br><span class="line">                      extra arguments <span class="keyword">for</span> ssh</span><br></pre></td></tr></table></figure><h3 id="传文件">传文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prsync -h host test.txt /tmp/dir</span><br></pre></td></tr></table></figure><h3 id="传目录">传目录</h3><p>这个得注意下目录…感觉和rsync差不多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prsync -r -h host /data/ /data</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之ulimit</title>
      <link href="/posts/4501ee1d.html"/>
      <url>/posts/4501ee1d.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>ulimit提供对shell和由它启动的进程可用的资源的控制。<code>ulimit</code>这个命令貌似是bash才可以用的,如果使用的是csh或者tcsh这个命令对应的是limit</p><blockquote><p>man手册:Provides control over the resources available to the shell and to processes started by it, on systems that allow such control.  The -H and -S options specify that the hard or soft limit is set for the given resource. A hard limit cannot be increased by a non-root user once it is set; a soft limit may be increased up to the value of the hard limit.  If neither -H nor -S is specified, both the soft and  hard  limits  are  set.   The  value  of limit can be a number in the unit specified for the resource or one of the special values hard, soft, or unlimited, which stand for the current hard limit, the current soft limit, and no limit, respectively. If limit is omitted, the current value of the soft limit of the resource is printed, unless the -H option is given.</p></blockquote><h1>注意</h1><ol><li>ulimit这个命令是对<code>单一程序</code>的限制,当前终端修改之后生效,但打开其他终端就还是默认的大小</li><li>ulimit主要限制的包括打开文件描述符数量、用户的最大进程数量、coredump文件的大小等,他是一个临时的开关,如果需要重启生效必须在limits.conf设置</li></ol><h1>如何查看当前系统限制</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@dddachui ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 15695</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 65535</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 15695</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><h1>首先分析下ulimit输出的参数是什么</h1><h2 id="core-file-size">core file size</h2><p>限制core文件的大小,默认情况下是0就是没有打开的,使用如下命令快速查看此配置,单位是blocks,一个blocks是1024个字节</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c size</span><br></pre></td></tr></table></figure><h2 id="data-seg-size">data seg size</h2><p>限制进程使用数据段的大小,这个限制会影响程序调用brk(系统调用)和sbrk(库函数)调用malloc,如果发现vm不够了,就会用brk去内核申请,一般不做限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -d size</span><br></pre></td></tr></table></figure><h2 id="scheduling-priority">scheduling priority</h2><p>限制进程优先级的,就是进程的NICE值,scheduling priority默认值为0,这个值只对<code>普通用户</code>起作用,对root用户不起作用,nice值的范围为-20到20,优先级从高到底,-20最高</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -e size</span><br></pre></td></tr></table></figure><h2 id="file-size">file size</h2><p>限制进程产生的文件大小,默认情况不限制,单位是blocks,1个blocks=1kb,如果设置了 100kb,那么将不n创建大于100KB的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -f size</span><br></pre></td></tr></table></figure><h2 id="pending-signals">pending signals</h2><p>主要是表示可以被挂起/阻塞的最大信号数量,linux下信号有64种,可以通过下面的kill查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@dddachui ~]# kill -l</span><br><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL10) SIGUSR1</span><br><span class="line">11) SIGSEGV12) SIGUSR213) SIGPIPE14) SIGALRM15) SIGTERM</span><br><span class="line">16) SIGSTKFLT17) SIGCHLD18) SIGCONT19) SIGSTOP20) SIGTSTP</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGURG24) SIGXCPU25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM27) SIGPROF28) SIGWINCH29) SIGIO30) SIGPWR</span><br><span class="line">31) SIGSYS34) SIGRTMIN35) SIGRTMIN+136) SIGRTMIN+237) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+439) SIGRTMIN+540) SIGRTMIN+641) SIGRTMIN+742) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+944) SIGRTMIN+1045) SIGRTMIN+1146) SIGRTMIN+1247) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+1449) SIGRTMIN+1550) SIGRTMAX-1451) SIGRTMAX-1352) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-1154) SIGRTMAX-1055) SIGRTMAX-956) SIGRTMAX-857) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-659) SIGRTMAX-560) SIGRTMAX-461) SIGRTMAX-362) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-164) SIGRTMAX</span><br></pre></td></tr></table></figure><p>编号为1-31的信号为传统unix支持的信号,是不可靠信号(非实时的),编号为32-64的信号是后来扩充的,称作可靠信号(实时信号)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -i size</span><br></pre></td></tr></table></figure><h2 id="max-locked-memory">max locked memory</h2><p>限制内存锁定,只对<code>普通用户</code>起作用,对root用户不起作用,linux对内存是分页管理的,内存中的数据,当不再需要时,会被从物理内存交换到swap或磁盘上,有需要时会被交换到物理内存,因为内存的换入/换出有一定的性能损耗,所以有时候会需要将数据锁定到物理内存,比如数据库等,或安全角度考虑的,比如用户名、密码等,被交换到swap或磁盘会有泄密的可能,所以一直锁定再内存中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -l size</span><br></pre></td></tr></table></figure><h2 id="max-memory-size">max memory size</h2><p>指定可使用内存的上限,单位为KB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -m size</span><br></pre></td></tr></table></figure><h2 id="open-files">open files</h2><p>打开的文件描述符的最大数量,这个值是针对<code>所有用户</code>的,表示可以在进程中打开文件的数量,默认是1024,但这个默认值太小,经常会遇到<code>Too many open files</code>的问题,但不能光顾着改大参数,还得检查程序是否正常释放资源,产生这个<code>Too many open files</code>问题大多是单进程使用文件句柄超过ulimit -n的值</p><h2 id="pipe-size">pipe size</h2><p>指定管道缓冲区的大小,单位512字节</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -p size</span><br></pre></td></tr></table></figure><h2 id="POSIX-message-queues">POSIX message queues</h2><p>限制可以创建使用POSIX消息队列的大小的,单位是bytes,默认是800KB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -q size</span><br></pre></td></tr></table></figure><h2 id="real-time-priority">real-time priority</h2><p>real-time priority是限制程序实时优先级的范围,只针对普通用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -r size</span><br></pre></td></tr></table></figure><h2 id="stack-size">stack size</h2><p>指定堆叠的上限,单位为KB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -s size</span><br></pre></td></tr></table></figure><h2 id="cpu-time">cpu time</h2><p>指定CPU使用时间的上限,单位为秒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -t size</span><br></pre></td></tr></table></figure><h2 id="max-user-processes">max user processes</h2><p>限制每个用户可以fork的进程数的,这里默认是不限的,而且该参数只对普通用户有效,这个参数影响并发,比如nginx、php-fpm的fork子进程,或者mysql的最大连接数,这个参数,默认情况下是根据系统的threads-max来定的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -u size</span><br></pre></td></tr></table></figure><h2 id="virtual-memory">virtual memory</h2><p>限制进程使用虚拟内存大小,单位是KB,默认是不限制的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -v size</span><br></pre></td></tr></table></figure><h2 id="file-locks">file locks</h2><p>文件锁的限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -x size</span><br></pre></td></tr></table></figure><h1>注意</h1><ol><li>修改时，若不加H或S参数，两个参数一起变改</li><li>查询时，若不加H或S参数，默认显示的是软限制</li></ol><h1>设置ulimit的位置</h1><p>可以在以下位置进行ulimit设置:</p><ol><li>/etc/profile 所有用户有效，永久生效</li><li>~/.bash_profile 当前用户有效，永久生效</li><li>直接在控制台输入 当前用户有效，临时生效</li><li>放在程序的启动脚本中</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之gdb</title>
      <link href="/posts/5ca85281.html"/>
      <url>/posts/5ca85281.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>调试的</p>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之lspci</title>
      <link href="/posts/39261f34.html"/>
      <url>/posts/39261f34.html</url>
      
        <content type="html"><![CDATA[<h1>PCI</h1><p>PCI是一种外设总线规范,lspci则是用来显示系统中所有PCI总线设备或连接到该总线上的所有设备的工具</p><h1>简单用法</h1><h2 id="输出所有的pci设备">输出所有的pci设备</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci </span><br></pre></td></tr></table></figure><p>结果就是</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">00</span>:<span class="number">00</span>.<span class="number">0</span> Host bridge: Intel Corporation <span class="number">440</span>BX/ZX/DX - <span class="number">82443</span>BX/ZX/DX Host bridge (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">01</span>.<span class="number">0</span> PCI bridge: Intel Corporation <span class="number">440</span>BX/ZX/DX - <span class="number">82443</span>BX/ZX/DX AGP bridge (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">07</span>.<span class="number">0</span> ISA bridge: Intel Corporation <span class="number">82371</span>AB/EB/MB PIIX4 ISA (rev <span class="number">08</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">07</span>.<span class="number">1</span> IDE interface: Intel Corporation <span class="number">82371</span>AB/EB/MB PIIX4 IDE (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">07</span>.<span class="number">3</span> Bridge: Intel Corporation <span class="number">82371</span>AB/EB/MB PIIX4 ACPI (rev <span class="number">08</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">07</span>.<span class="number">7</span> System peripheral: VMware Virtual Machine Communication Interface (rev <span class="number">10</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">0</span>f.<span class="number">0</span> VGA compatible controller: VMware SVGA II Adapter</span><br><span class="line"><span class="attribute">00</span>:<span class="number">10</span>.<span class="number">0</span> SCSI storage controller: LSI Logic / Symbios Logic <span class="number">53</span>c1030 PCI-X Fusion-MPT Dual Ultra320 SCSI (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">11</span>.<span class="number">0</span> PCI bridge: VMware PCI bridge (rev <span class="number">02</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">15</span>.<span class="number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">16</span>.<span class="number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">17</span>.<span class="number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">00</span>:<span class="number">18</span>.<span class="number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">02</span>:<span class="number">00</span>.<span class="number">0</span> USB controller: VMware USB1.<span class="number">1</span> UHCI Controller</span><br><span class="line"><span class="attribute">02</span>:<span class="number">01</span>.<span class="number">0</span> Ethernet controller: Intel Corporation <span class="number">82545</span>EM Gigabit Ethernet Controller (Copper) (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">02</span>:<span class="number">02</span>.<span class="number">0</span> Ethernet controller: Intel Corporation <span class="number">82545</span>EM Gigabit Ethernet Controller (Copper) (rev <span class="number">01</span>)</span><br><span class="line"><span class="attribute">02</span>:<span class="number">04</span>.<span class="number">0</span> USB controller: VMware USB2 EHCI Controller</span><br></pre></td></tr></table></figure><p>(想不到这么长,其实在服务器更长)</p><h2 id="这些都是什么意思的呢">这些都是什么意思的呢?</h2><p>要想知道得看看<code>/proc/iomem</code>这个文件, /proc/iomem描述了系统中所有的设备I/O在内存地址空间上的映射<br>比如我截取了如下一段</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">c0000000</span>-c0007fff : <span class="number">0000</span>:<span class="number">00</span>:<span class="number">0</span>f.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这是一个PCI设备，c0000000-c0007fff是它所映射的内存地址空间，占据了内存地址空间的1024 bytes的位置，而 0000:00:0f.0则是一个PCI外设的地址,它以冒号和逗号分隔为4个部分，第一个16位表示域，第二个8位表示一个总线编号，第三个5位表示一 个设备号，最后是3位，表示功能号<br>由此再来看lspci的结果就不难看出<code>第一列</code>其实就是pci的描述,第二列型号信息,这部分太深奥了,不如自己百度吧</p><h1>查看指定的设备</h1><p>一般来说这个章节就是判断驱动有没有,没有的话怎么查找驱动过程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nn | grep -i eth # -nn 显示文本和数字ID</span><br></pre></td></tr></table></figure><p>输入如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">02</span>:<span class="number">01</span>.<span class="number">0</span> Ethernet controller<span class="meta"> [0200]: Intel Corporation 82545EM Gigabit Ethernet Controller (Copper) [8086:100f] (rev 01)</span></span><br></pre></td></tr></table></figure><p>只要关注如下几个地方</p><ul><li>02:01.0</li><li>Intel Corporation 82545EM Gigabit Ethernet Controller</li><li>8086:100f</li></ul><h2 id="按pci号展示信息">按pci号展示信息</h2><p>这里的02:01.0就是-nn输出的第一列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nvs 02:01.0</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">02:01.0 0200:</span> <span class="number">8086</span><span class="string">:100f</span> <span class="string">(rev</span> <span class="number">01</span><span class="string">)</span></span><br><span class="line"><span class="attr">Subsystem:</span> <span class="string">15ad:0750</span></span><br><span class="line"><span class="attr">Physical Slot:</span> <span class="number">33</span></span><br><span class="line"><span class="attr">Flags:</span> <span class="string">bus</span> <span class="string">master,</span> <span class="string">66MHz,</span> <span class="string">medium</span> <span class="string">devsel,</span> <span class="string">latency</span> <span class="number">0</span><span class="string">,</span> <span class="string">IRQ</span> <span class="number">19</span></span><br><span class="line"><span class="string">Memory</span> <span class="string">at</span> <span class="string">fd5c0000</span> <span class="string">(64-bit,</span> <span class="string">non-prefetchable)</span> [<span class="string">size=128K</span>]</span><br><span class="line"><span class="string">Memory</span> <span class="string">at</span> <span class="string">fdff0000</span> <span class="string">(64-bit,</span> <span class="string">non-prefetchable)</span> [<span class="string">size=64K</span>]</span><br><span class="line"><span class="string">I/O</span> <span class="string">ports</span> <span class="string">at</span> <span class="number">2000</span> [<span class="string">size=64</span>]</span><br><span class="line">[<span class="string">virtual</span>] <span class="string">Expansion</span> <span class="string">ROM</span> <span class="string">at</span> <span class="string">fd500000</span> [<span class="string">disabled</span>] [<span class="string">size=64K</span>]</span><br><span class="line"><span class="attr">Capabilities:</span> [<span class="string">dc</span>] <span class="string">Power</span> <span class="string">Management</span> <span class="string">version</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Capabilities:</span> [<span class="string">e4</span>] <span class="string">PCI-X</span> <span class="string">non-bridge</span> <span class="string">device</span></span><br><span class="line"><span class="attr">Kernel driver in use:</span> <span class="string">e1000</span></span><br><span class="line"><span class="attr">Kernel modules:</span> <span class="string">e1000</span></span><br></pre></td></tr></table></figure><p>在这里就只要看1点</p><ul><li>Kernel driver in use<br>这就是代表驱动有没打上</li></ul><h2 id="假设硬件名没有显示">假设硬件名没有显示</h2><p>可以登陆如下小网站查询</p><blockquote><p><a href="https://devicehunt.com/">https://devicehunt.com/</a></p></blockquote><p>这里就要用到8086:100f这个参数,8086就是厂商id,100f就是设备id,通过这个设备id就能查到这个硬件是什么,知道硬件之后就去对应的官网下载src编译,尤其是用在显卡方面比较多,因为不是每个系统版本都能默认识别到硬件,所以要自己查</p><h1>以树形结构显示</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci –t</span><br></pre></td></tr></table></figure><h1>展示系统中所有某个厂商的设备</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lspci</span> -nn -d <span class="number">8086</span>:</span><br></pre></td></tr></table></figure><h1>更新数据库</h1><p>新设备和供应商总是在不断迭代。如果看到显示为 unknown 的设备，说明你的 PCI 设备 ID 数据库可能已过时。有两种方法可以检查更新</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -<span class="selector-tag">Q</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户被锁定</title>
      <link href="/posts/10c41d09.html"/>
      <url>/posts/10c41d09.html</url>
      
        <content type="html"><![CDATA[<h1>问题阐述</h1><p>用户密码输错多次被锁定了账户</p><h1>产生原因</h1><p>在一些系统通过pam模块设定了登陆限制之后,由于输入错了密码次数过多导致的</p><h1>解决方法</h1><p>只能通过root或者whell组的拥有高级权限的账户进行解锁,如果root都被锁定了只能进入单用户解锁次数,时间要是被锁定了可以通过耐心的等待</p><h2 id="解锁次数">解锁次数</h2><ul><li>查看用户登陆失败次数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pam_tally2 --user=用户名 </span><br></pre></td></tr></table></figure><ul><li>重置用户登陆失败次数为0</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pam_tally2 --user=用户名  --reset </span><br></pre></td></tr></table></figure><h2 id="解锁时间">解锁时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faillock   --user   用户名    --reset</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之ps</title>
      <link href="/posts/9202f4ae.html"/>
      <url>/posts/9202f4ae.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之screen</title>
      <link href="/posts/c9d4ad81.html"/>
      <url>/posts/c9d4ad81.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序,但也有其他用处</p><h1>创建screen实例</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure><h1>离开实例</h1><p>在 screen 终端 下 按下 Ctrl+a d键</p><h1>显示实例</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -ls</span><br></pre></td></tr></table></figure><h1>重新链接某个实例</h1><p>连接 screen_id 为 2276 的 screen终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r 2276</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之netstat</title>
      <link href="/posts/af020bcb.html"/>
      <url>/posts/af020bcb.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之lsof</title>
      <link href="/posts/97f67cbd.html"/>
      <url>/posts/97f67cbd.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>lsof是List Open Files(这个是man手册说的)的缩写,它主要用来获取被进程打开文件的信息,在Linux中,一切皆文件,lsof命令可以查看所有已经打开了的文件,文件含义如下</p><ol><li>普通文件</li><li>目录</li><li>网络文件系统的文件</li><li>字符或设备文件</li><li>(函数)共享库</li><li>管道,命名管道</li><li>符号链接</li><li>网络文件(例如:NFS file、网络socket,unix域名socket)</li><li>还有其它类型的文件,等等</li></ol><h1>lsof每一列解释</h1><ul><li>COMMAND : 进程名</li><li>PID : 进程ID</li><li>TID : 任务ID</li><li>USER : 所属用户</li><li>FD : 文件描述符<ul><li>cwd : 应用程序当前工作目录,这是该应用程序启动的目录,除非它本身对这个目录进行更改</li><li>txt : 该类型的文件是程序代码,如应用程序二进制文件本身或共享库,如上列表中显示的 /sbin/init 程序</li><li>lnn : 库引用（AIX）</li><li>err : FD 信息错误</li><li>jld : 监狱目录（FreeBSD）</li><li>ltx : 共享库文本（代码和数据）</li><li>mxx : 十六进制内存映射类型号 xx</li><li>m86 : DOS合并映射文件</li><li>mem : 内存映射文件</li><li>mmap : 内存映射设备</li><li>pd : 父目录</li><li>rtd : 根目录</li><li>tr : 内核跟踪文件（OpenBSD）</li><li>v86 : VP/ix 映射文件</li><li>0 : 标准输出</li><li>1 : 标准输入</li><li>2 : 标准错误</li><li>r : 只读</li><li>w : 写入</li><li>u : 读写</li><li>空格 : 文件状态模式是unknow没锁定</li><li>短杠 : 文件状态模式是unknow且锁定</li></ul></li><li>TYPE : 文件类型,大致类型如下<ul><li>REG : 普通文件</li><li>DIR : 表示目录</li><li>CHR : 表示字符类型</li><li>BLK : 块设备类型</li><li>UNIX : UNIX 域套接字</li><li>FIFO : 先进先出队列</li><li>IPv4 : IPv4 套接字</li></ul></li><li>DEVICE : 磁盘名称</li><li>SIZE/OFF : 以字节为单位的文件的大小或文件偏移量</li><li>NODE : 索引节点</li><li>NAME : 打开文件的确切名称</li></ul><h1>用法</h1><h2 id="列出所有打开的文件">列出所有打开的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br></pre></td></tr></table></figure><h2 id="列出所有打开的文件分页显示">列出所有打开的文件分页显示</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof | more</span><br></pre></td></tr></table></figure><h2 id="查看某个特定的文件谁在用">查看某个特定的文件谁在用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /var/log/messages</span><br></pre></td></tr></table></figure><h2 id="显示指定进程打开的文件">显示指定进程打开的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsoc -c sshd</span><br></pre></td></tr></table></figure><h2 id="显示指定进程号打开的文件">显示指定进程号打开的文件</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -p <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="监听协议-端口等">监听协议,端口等</h2><p>lsof -i [46] [protocol] [@hostname] [:service|port]</p><ul><li>显示所有的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure><ul><li>显示所有tcp网络连接进程信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp</span><br></pre></td></tr></table></figure><ul><li>显示端口是80 的进程信息<br>其实这边是省略了指定协议,所以会输出所有tcp和udp的,一般用于检查端口占用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :80</span><br></pre></td></tr></table></figure><ul><li>列出端口是1-1024的文件</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -i :<span class="number">1</span>-<span class="number">1024</span></span><br></pre></td></tr></table></figure><ul><li>显示同时满足tcp且端口是22的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:22</span><br></pre></td></tr></table></figure><ul><li>显示指定用户使用的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -u root</span><br></pre></td></tr></table></figure><ul><li>显示除了某个用户之外其他用户打开的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -u ^root</span><br></pre></td></tr></table></figure><ul><li>显示所有socket文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -U</span><br></pre></td></tr></table></figure><ul><li>查看某个目录的文件信息<br>可以用于卸载磁盘时报&quot;device is busy&quot;</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /run/media/root/KylinSec</span><br></pre></td></tr></table></figure><ul><li>查看某个目录及子目录的文件信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof +D /root</span><br></pre></td></tr></table></figure><ul><li>找出打开着的但是已经被删除的文件</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof  grep deleted</span></span><br></pre></td></tr></table></figure><ul><li>列出ipv4/6的网络文件</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -i <span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之rpm</title>
      <link href="/posts/f854f9de.html"/>
      <url>/posts/f854f9de.html</url>
      
        <content type="html"><![CDATA[<h1>安装</h1><h2 id="安装软件包">安装软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh xx.rpm</span><br></pre></td></tr></table></figure><h2 id="安装忽略依赖">安装忽略依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh xxx.rpm --nodeps </span><br></pre></td></tr></table></figure><h2 id="测试安装xx软件包">测试安装xx软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh --test xxx.rpm</span><br></pre></td></tr></table></figure><h1>卸载</h1><h2 id="卸载软件包">卸载软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e xxx</span><br></pre></td></tr></table></figure><h2 id="卸载软件包忽略依赖">卸载软件包忽略依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e xxx --nodeps</span><br></pre></td></tr></table></figure><h1>查询</h1><h2 id="查询一个软件是否安装">查询一个软件是否安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q openssh</span><br></pre></td></tr></table></figure><h2 id="查询软件包是否安装">查询软件包是否安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qpi telnet-0.17-48.kb2.ky3.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="查看已经安装的软件包">查看已经安装的软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa  </span><br></pre></td></tr></table></figure><h2 id="显示xxx功能、文件、目录是哪个软件包提供的">显示xxx功能、文件、目录是哪个软件包提供的</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf  &#x27;which ssh&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf  /opt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf /etc/ntp.conf</span><br></pre></td></tr></table></figure><h2 id="显示包的更改记录">显示包的更改记录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q --changelog ntp-4.2.8p15-28.ky3.kb5.x86_64</span><br></pre></td></tr></table></figure><h2 id="查询包的依赖关系">查询包的依赖关系</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qR ntp-4.2.8p15-28.ky3.kb5.x86_64</span><br></pre></td></tr></table></figure><h2 id="显示包的信息">显示包的信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -V pkg_name</span><br></pre></td></tr></table></figure><h2 id="查看包的详细信息">查看包的详细信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi pkg_name</span><br></pre></td></tr></table></figure><h2 id="查看包提供的文档">查看包提供的文档</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qd pkg_name</span><br></pre></td></tr></table></figure><h2 id="查看软件包的配置文件">查看软件包的配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qc pkg_name</span><br></pre></td></tr></table></figure><h2 id="查看一个软件包的安装的文件">查看一个软件包的安装的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql pkg_name</span><br></pre></td></tr></table></figure><h2 id="检查所有的rpm是否遗漏配置">检查所有的rpm是否遗漏配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Va</span><br></pre></td></tr></table></figure><h2 id="数字签名校验rpm包是否被篡改">数字签名校验rpm包是否被篡改</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">rpm</span> <span class="operator">-</span><span class="built_in">K</span> <span class="variable">xxx</span><span class="operator">.</span><span class="variable">rpm</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/LiuYanYGZ/p/9435708.html">https://www.cnblogs.com/LiuYanYGZ/p/9435708.html</a></p></blockquote><h1>升级降级</h1><h2 id="升级包">升级包</h2><p>删除旧包再装新包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh pkg_name</span><br></pre></td></tr></table></figure><h2 id="升级包-2">升级包</h2><p>在旧版本的基础上安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Fvh pkg_name</span><br></pre></td></tr></table></figure><h2 id="降级包">降级包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh pkg_name --oldpackage</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之yum</title>
      <link href="/posts/8976e27a.html"/>
      <url>/posts/8976e27a.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>yum是包管理器,centos7以下都是用的yum,centos8以上都换成了dnf,由于yum的命令非常强大(学不会),这里只会简单的介绍基本用法</p><h1>前置要求</h1><blockquote><p>在使用yum命令之前需要配置yum源,yum源可以简单的理解为软件源</p></blockquote><h2 id="如何去学习这个命令的用法">如何去学习这个命令的用法</h2><p>看man手册或者使用–help(选项)查看相关资料</p><ul><li>使用man手册</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man yum</span><br></pre></td></tr></table></figure><ul><li>使用–help选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --help</span><br></pre></td></tr></table></figure><ul><li>使用yum的选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum help</span><br></pre></td></tr></table></figure><h2 id="yum的命令形式">yum的命令形式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package]</span><br></pre></td></tr></table></figure><h2 id="元数据">元数据</h2><p>玩yum之前需要先做好<code>元数据</code>,配置好repo文件之后就需要生成元数据,yum仓库的元数据由XML文件构成，包含了其他文件的校验（checksums）及所引用的包。</p><ul><li>清空yum缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure><ul><li>创建元数据缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h1>显示仓库</h1><p>用命令展示系统所配置的软件源</p><ul><li>显示所有源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist all</span><br></pre></td></tr></table></figure><ul><li>显示可用的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist enabled</span><br></pre></td></tr></table></figure><ul><li>显示禁止的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist disabled</span><br></pre></td></tr></table></figure><ul><li>显示当前激活的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist</span><br></pre></td></tr></table></figure><h1>列举软件包</h1><ul><li>显示源里面的所有的rpm包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list </span><br></pre></td></tr></table></figure><ul><li>列出本机安装的软件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed </span><br></pre></td></tr></table></figure><ul><li>列出yum源里面可以安装的包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list available</span><br></pre></td></tr></table></figure><ul><li>列出yum源里面可以更新的所有包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list updates</span><br></pre></td></tr></table></figure><h1>查询软件包</h1><p>search查询的结果是含有查询关键词的包名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search httpd</span><br></pre></td></tr></table></figure><h1>查询软件包的文件</h1><p>使用provides(或whatprovides)查询命令或者文件在哪个rpm包,很适合用于查询库文件或者单个命令所属包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum provides nginx</span><br></pre></td></tr></table></figure><h1>查看软件包组</h1><p>groups是软件包组,系统内集成了很多软件包组例如开发工具组,桌面组,可以实现一键安装某个组的所有软件</p><ul><li>列举groups软件组<br>用于显示软件包组,例如开发工具组,桌面组等</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groups list</span><br></pre></td></tr></table></figure><ul><li>查询group软件组的信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groups info &quot;Server with GUI&quot;</span><br></pre></td></tr></table></figure><h1>依赖问题</h1><p>rpm包之间的依赖是很头疼的</p><ul><li>列举bash软件包的依赖<br>会显示依赖什么文件,并且这些依赖在什么包里面,如果依赖都已经安装了,那么就可以单独安装该软件包,如果依赖缺失,就必须先安装依赖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum deplist bash</span><br></pre></td></tr></table></figure><h1>安装软件包</h1><ul><li>安装单个软件包<br>包名可以用search查询出来</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install 包名</span><br></pre></td></tr></table></figure><ul><li>安装软件组<br>例如直接安装开发工具,里面包括make,gcc,g++等</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groups install &quot;Development Tools&quot;</span><br></pre></td></tr></table></figure><h1>下载软件包</h1><p>在有些环境复杂的地方可能不能使用网络,所以需要将安装包下载导入到机器,可以使用yum的仅下载的选项或者yumdownloader命令实现,但需要解决好软件包的<code>依赖关系</code></p><ul><li>yum实现<ul><li>downloadonly是仅下载选项</li><li>downloaddir是指定下载位置</li><li>ansible是软件包的名字</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install --downloadonly --downloaddir=/root/ansible_rpms ansible -y</span><br></pre></td></tr></table></figure><ul><li>yumdownloader实现<ul><li>resolve是自动解决依赖</li><li>destdir是下载位置</li><li>ansible是软件包名</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumdownloader --resolve --destdir=/root/mypackages/ ansible</span><br></pre></td></tr></table></figure><h1>卸载软件包</h1><p>例如卸载openjdk 1.6版本,他会自动解决依赖关系,但是卸载的时候需要先看下哪些依赖被删除了</p><ul><li>remove</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove httpd</span><br></pre></td></tr></table></figure><ul><li>erase</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove httpd</span><br></pre></td></tr></table></figure><h1>查看yum操作历史记录</h1><p>查看 yum 事务信息，yum 是独占模式的进程，所以有时候查看事务信息还是有用的(有点高级没用会)</p><ul><li>查看 Yum 事务完整的历史记录<br>可以看见所有的yum操作历史</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum history </span><br></pre></td></tr></table></figure><ul><li>查看单独软件包的历史</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="built_in">history</span> info [事务<span class="built_in">id</span>或者包名]</span><br></pre></td></tr></table></figure><p>查看安装ansible的历史,可以看出:事务id,安装的包,作为依赖安装的包等</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> history <span class="literal">info</span> ansible</span><br></pre></td></tr></table></figure><ul><li>history子命令<br>history的子命令可以让我们撤销/重做/回滚事务<ul><li>undo:会撤销一个指定的事务</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum history undo 1</span><br></pre></td></tr></table></figure><ul><li>redo:重复一次指定的事务</li></ul>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> redo <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>rollback:撤销指定事务之后的所有事务</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum rollback 1</span><br></pre></td></tr></table></figure></li></ul><h1>更新</h1><ul><li>update<br>更新系统中的一个或多个软件包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h1>降级</h1><ul><li>downgrade<br>当包没有任何依赖关系时，降级是非常简单的,当使用这个命令产生了依赖关系的时候必须先降级依赖的版本</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> downgrade 包名</span><br></pre></td></tr></table></figure><h1>yum源属性配置</h1><p>可以用参数指定下载的源</p><ul><li>直接禁止仓库(直接)<ul><li>禁止仓库</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --disable epel</span><br></pre></td></tr></table></figure><ul><li>开启仓库</li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --enable  epel </span><br></pre></td></tr></table></figure></li><li>使用选项指定  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd --enablerepo=base --disablerepo=yun</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inode节点爆满处理</title>
      <link href="/posts/e5a0e4e9.html"/>
      <url>/posts/e5a0e4e9.html</url>
      
        <content type="html"><![CDATA[<h1>问题阐述</h1><p>磁盘容量没有满但是不能创建文件</p><h1>产生原因</h1><p>inode资源耗尽</p><h1>解决方法</h1><p>##查看inode节点状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -i</span><br></pre></td></tr></table></figure><p>可以看出根目录的inode占用率是100%,此时已经无法创建新的文件</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Filesystem Inodes  IUsed   IFree  IUse% Mounted on </span><br><span class="line">root       4964352 4964352  0     100%  /</span><br></pre></td></tr></table></figure><h2 id="删除无用的临时文件，释放inode">删除无用的临时文件，释放inode</h2><ul><li>find检查<br>使用find遍历将大小是0的文件列出来,为了防止误删,建议先查看文件是否需要</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp -type f -size 0</span><br></pre></td></tr></table></figure><p>如果确认某个目录下的文件不需要了可以加入exec一次删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp/log -type f -size 0 -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><ul><li>for循环<br>使用for循环查看某个目录下的文件数量,当定位到某个路径之后继续深挖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in /var/*; do echo $i; find $i | wc -l; done </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 故障处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之df</title>
      <link href="/posts/d171c710.html"/>
      <url>/posts/d171c710.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>来自于英文词组&quot;Disk Free&quot;的缩写，其功能是用于显示系统上磁盘空间的使用量情况。</p><h1>选项</h1><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-a, --<span class="built_in">all</span>             显示所有系统文件</span><br><span class="line">-B, --<span class="keyword">block</span>-<span class="built_in">size</span>=<span class="built_in">SIZE</span> 指定显示时的块大小</span><br><span class="line">    --<span class="keyword">direct</span>          show statistics for a <span class="keyword">file</span> instead of mount point</span><br><span class="line">    --total           produce a grand total</span><br><span class="line">-h, --human-readable  以容易阅读的方式显示<span class="number">1024</span></span><br><span class="line">-H, --si              以容易阅读的方式显示<span class="number">1000</span></span><br><span class="line">-i, --inodes      显示inode 信息而非块使用量</span><br><span class="line">-k      即--<span class="keyword">block</span>-<span class="built_in">size</span>=<span class="number">1</span>K,指定块大小为<span class="number">1</span>KB</span><br><span class="line">-l, --<span class="keyword">local</span>           只显示本机的文件系统</span><br><span class="line">    --no-<span class="built_in">sync</span>      取得使用量数据前不进行同步动作(默认)</span><br><span class="line">    --output[=FIELD_LIST]  <span class="keyword">use</span> the output <span class="keyword">format</span> defined by FIELD_LIST,</span><br><span class="line">                             or <span class="built_in">print</span> <span class="built_in">all</span> fields <span class="keyword">if</span> FIELD_LIST is omitted.</span><br><span class="line">-P, --portability     <span class="keyword">use</span> the POSIX output <span class="keyword">format</span></span><br><span class="line">    --<span class="built_in">sync</span>            在取得磁盘使用信息前，先执行<span class="built_in">sync</span>命令</span><br><span class="line">-t, --<span class="keyword">type</span>=<span class="keyword">TYPE</span>       只显示指定类型的文件系统</span><br><span class="line">-T, --<span class="built_in">print</span>-<span class="keyword">type</span>      输出时显示文件系统类型</span><br><span class="line">-x, --exclude-<span class="keyword">type</span>=<span class="keyword">TYPE</span>   limit listing to <span class="keyword">file</span> systems not of <span class="keyword">type</span> <span class="keyword">TYPE</span></span><br><span class="line">-v                    (ignored)</span><br><span class="line">--help              显示此帮助信息并退出</span><br><span class="line">--version      显示版本信息并退出</span><br></pre></td></tr></table></figure><h1>用法</h1><h2 id="查看与挂载点有关的信息">查看与挂载点有关的信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -Th  # h是1024换算的</span><br></pre></td></tr></table></figure><h2 id="查看与挂载点有关的信息-2">查看与挂载点有关的信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -TH  # h是1000换算的</span><br></pre></td></tr></table></figure><h2 id="显示单个挂载点的信息">显示单个挂载点的信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -Th /</span><br></pre></td></tr></table></figure><h2 id="显示ext4的文件系统">显示ext4的文件系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h -t ext4</span><br></pre></td></tr></table></figure><h2 id="查看inode节点信息">查看inode节点信息</h2><blockquote><p>如果inode节点满了将无法继续创建文件,但可能此时磁盘还没有占满,所以需要更多关注inode节点相关信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux好用命令之crontab</title>
      <link href="/posts/9191c4a8.html"/>
      <url>/posts/9191c4a8.html</url>
      
        <content type="html"><![CDATA[<h1>命令简介</h1><p>周期性定时任务</p><h1>crontab语法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   #每（分时日月周）执行</span><br><span class="line">[a-b] #在a到b的时间段执行</span><br><span class="line">*/n #每n(分时日月周)执行一次</span><br><span class="line">[a,b,c] #第(分时日月周)执行</span><br></pre></td></tr></table></figure><h1>案例</h1><p>只要收录了一些时间用法，具体的执行的内容都用A代替</p><ul><li>每一分钟执行一次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*****A</span><br></pre></td></tr></table></figure><ul><li>在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span><span class="number">6</span>-<span class="number">12</span>/<span class="number">3</span>*<span class="number">12</span>*A</span><br></pre></td></tr></table></figure><ul><li>周一到周五每天下午 5:00 执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span><span class="number">17</span>**<span class="number">1</span>-<span class="number">5</span>A</span><br></pre></td></tr></table></figure><ul><li>每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分…执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">20</span><span class="number">0</span>-<span class="number">24</span>/<span class="number">2</span>***A</span><br></pre></td></tr></table></figure><ul><li>每两个小时执行</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span><span class="emphasis">*/2*</span>**  A</span><br></pre></td></tr></table></figure><ul><li>每天7：50执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">50</span><span class="number">7</span>***A</span><br></pre></td></tr></table></figure><ul><li>每天22：50执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">50</span><span class="number">22</span>***A</span><br></pre></td></tr></table></figure><ul><li>每月1号和15号执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span><span class="number">0</span><span class="number">1</span>,<span class="number">15</span>**A</span><br></pre></td></tr></table></figure><ul><li>每小时的第一分执行</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>**** <span class="selector-tag">A</span></span><br></pre></td></tr></table></figure><ul><li>每月的1、11、21、31日是的6：30执行</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">30</span><span class="number">6</span>*/<span class="number">10</span>**A</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
