<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dddachui🚭</title>
  
  
  <link href="https://www.dddachui.top/atom.xml" rel="self"/>
  
  <link href="https://www.dddachui.top/"/>
  <updated>2023-03-13T12:24:18.896Z</updated>
  <id>https://www.dddachui.top/</id>
  
  <author>
    <name>dddachui.top</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>好用的软件</title>
    <link href="https://www.dddachui.top/posts/3df4b4e4.html"/>
    <id>https://www.dddachui.top/posts/3df4b4e4.html</id>
    <published>2023-03-13T12:22:13.000Z</published>
    <updated>2023-03-13T12:24:18.896Z</updated>
    
    <content type="html"><![CDATA[<h1>开源软件(持续更新)</h1><h2 id="RSS软件">RSS软件</h2><p><a href="https://github.com/yang991178/fluent-reader">https://github.com/yang991178/fluent-reader</a></p><h2 id="ssh工具windterm">ssh工具windterm</h2><p>运维人的工具不嫌多<br><a href="https://github.com/kingToolbox/WindTerm">https://github.com/kingToolbox/WindTerm</a></p><h2 id="代码片段管理工具massCode">代码片段管理工具massCode</h2><p><a href="https://github.com/massCodeIO/massCode">https://github.com/massCodeIO/massCode</a></p><h2 id="远程桌面rustdesk">远程桌面rustdesk</h2><p><a href="https://github.com/rustdesk/rustdesk">https://github.com/rustdesk/rustdesk</a></p><h2 id="局域网网盘alist">局域网网盘alist</h2><p>在linux发行版搭建服务器,挂载各大网盘或者本地文件,有好看的ui<br><a href="https://github.com/alist-org/alist">https://github.com/alist-org/alist</a></p><h2 id="洛雪">洛雪</h2><p>懂得都懂<br><a href="https://github.com/lyswhut/lx-music-desktop">https://github.com/lyswhut/lx-music-desktop</a></p><h2 id="linux查看markdown命令">linux查看markdown命令</h2><p><a href="https://github.com/charmbracelet/glow">https://github.com/charmbracelet/glow</a></p><h1>其他软件</h1><h2 id="卡饭输入法">卡饭输入法</h2><p><a href="https://input.kfsafe.cn/">https://input.kfsafe.cn/</a></p><h2 id="Obsidian-markdown笔记">Obsidian(markdown笔记)</h2><p>这个软件一直在更新就不放链接了<br><a href="https://obsidian.md/">https://obsidian.md/</a></p><h1>获取软件下载地址(蓝奏云)</h1><ul><li>windterm<br><a href="https://dddachui.lanzouy.com/iDzcV0a4znoh">https://dddachui.lanzouy.com/iDzcV0a4znoh</a></li><li>massCode<br><a href="https://dddachui.lanzouy.com/iwAFI0a50h0d">https://dddachui.lanzouy.com/iwAFI0a50h0d</a></li><li>rustdesk<br><a href="https://dddachui.lanzouy.com/ii2TA0a50htc">https://dddachui.lanzouy.com/ii2TA0a50htc</a></li><li>alist<br><a href="https://dddachui.lanzouy.com/iF7pT0a506kh">https://dddachui.lanzouy.com/iF7pT0a506kh</a></li><li>glow<br><a href="https://dddachui.lanzouy.com/iIe1b0eh537c">https://dddachui.lanzouy.com/iIe1b0eh537c</a></li></ul>]]></content>
    
    
    <summary type="html">记录各个平台好用的软件</summary>
    
    
    
    <category term="软件" scheme="https://www.dddachui.top/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="软件" scheme="https://www.dddachui.top/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>博客图片使用记录</title>
    <link href="https://www.dddachui.top/posts/6b240272.html"/>
    <id>https://www.dddachui.top/posts/6b240272.html</id>
    <published>2023-03-13T12:16:41.000Z</published>
    <updated>2023-03-13T12:48:19.386Z</updated>
    
    <content type="html"><![CDATA[<h1>使用记录</h1><h2 id="背景图">背景图</h2><ul><li>9</li><li>19</li><li>29</li><li>39</li></ul><h2 id="文章图">文章图</h2><ul><li>学习目标 1</li><li>好用的软件 2</li><li>crontab 3</li><li>博客图片使用记录 4</li><li>局域网ip冲突解决方法 5</li><li>linux的驱动问题 6</li><li>系统资源异常处理思路 7</li><li>用户被锁定 8</li><li>在Centos中检查RPM包的依赖性 10</li><li>git拉取总是需要密码 11</li><li>inode节点爆满处理 12</li><li>Linux好用命令之at 13</li><li>Linux好用命令之bizp2 14</li><li>Linux好用命令之dd 15</li><li>Linux好用命令之df 16</li><li>Linux好用命令之dnf 17</li><li>Linux好用命令之dos2unix 18</li><li>Linux好用命令之ethtool 20</li><li>Linux好用命令之free 21</li><li>Linux好用命令之gdb 22</li><li>Linux好用命令之git 23</li><li>Linux好用命令之gzip 24</li><li>Linux好用命令之iostat 25</li><li>Linux好用命令之lscpu 26</li><li>Linux好用命令之lsof 27</li><li>Linux好用命令之lspci 28</li><li>Linux好用命令之md5sum 30</li><li>Linux好用命令之netstat 31</li><li>Linux好用命令之nmcli 32</li><li>Linux好用命令之pidstat 33</li><li>Linux好用命令之ps 34</li><li>Linux好用命令之rpm 35</li><li>Linux好用命令之rsync 36</li><li>Linux好用命令之screen 37</li><li>Linux好用命令之strace 38</li><li>Linux好用命令之systemctl 40</li><li>Linux好用命令之tar 41</li><li>Linux好用命令之top 42</li><li>Linux好用命令之ulimit 43</li><li>Linux好用命令之xz 44</li><li>Linux好用命令之yum 45</li><li>Linux好用命令之zip 46</li></ul>]]></content>
    
    
    <summary type="html">记录图片的使用记录，防止重复</summary>
    
    
    
    <category term="杂记" scheme="https://www.dddachui.top/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="https://www.dddachui.top/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2023目标</title>
    <link href="https://www.dddachui.top/posts/7169e9ad.html"/>
    <id>https://www.dddachui.top/posts/7169e9ad.html</id>
    <published>2023-03-12T14:15:32.000Z</published>
    <updated>2023-03-13T12:23:22.056Z</updated>
    
    <content type="html"><![CDATA[<h1>学习Flag</h1><ol><li>考完驾照！</li><li>学习rpm打包方法</li><li>学习ks文件使用，包括文件编写、pxe自动安装、封装镜像</li><li>rub原理学习(修复legacy、uefi引导、基本操作)</li><li>linux双网卡使用NetworkManager服务访问资源问题解决</li><li>高并发文档精简</li></ol><h1>人生目标</h1><ol><li>找个对象</li></ol>]]></content>
    
    
    <summary type="html">加油</summary>
    
    
    
    
    <category term="Markdown" scheme="https://www.dddachui.top/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Linux好用命令之ethtool</title>
    <link href="https://www.dddachui.top/posts/c0d4357c.html"/>
    <id>https://www.dddachui.top/posts/c0d4357c.html</id>
    <published>2022-10-19T15:30:51.000Z</published>
    <updated>2023-03-13T12:49:02.544Z</updated>
    
    <content type="html"><![CDATA[<h1>命令简介</h1><p>查看网口用的</p><h1>查看网卡信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool eth0</span><br></pre></td></tr></table></figure><ul><li>网卡信息如下<br>可以看出网卡的很多信息,包括网卡速率是百兆还是千兆</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Settings for enp2s0:</span><br><span class="line">        Supported ports: [ TP    MII ]</span><br><span class="line">        Supported link modes:   10baseT/Half 10baseT/Full</span><br><span class="line">                                100baseT/Half 100baseT/Full</span><br><span class="line">                                1000baseT/Half 1000baseT/Full</span><br><span class="line">        Supported pause frame use: Symmetric Receive-only</span><br><span class="line">        Supports auto-negotiation: Yes</span><br><span class="line">        Supported FEC modes: Not reported</span><br><span class="line">        Advertised link modes:  10baseT/Half 10baseT/Full</span><br><span class="line">                                100baseT/Half 100baseT/Full</span><br><span class="line">                                1000baseT/Half 1000baseT/Full</span><br><span class="line">        Advertised pause frame use: Symmetric Receive-only</span><br><span class="line">        Advertised auto-negotiation: Yes</span><br><span class="line">        Advertised FEC modes: Not reported</span><br><span class="line">        Link partner advertised link modes:  10baseT/Half 10baseT/Full</span><br><span class="line">                                             100baseT/Half 100baseT/Full</span><br><span class="line">                                             1000baseT/Full</span><br><span class="line">        Link partner advertised pause frame use: Symmetric</span><br><span class="line">        Link partner advertised auto-negotiation: Yes</span><br><span class="line">        Link partner advertised FEC modes: Not reported</span><br><span class="line">        Speed: 1000Mb/s</span><br><span class="line">        Duplex: Full</span><br><span class="line">        Auto-negotiation: on</span><br><span class="line">        master-slave cfg: preferred slave</span><br><span class="line">        master-slave status: slave</span><br><span class="line">        Port: Twisted Pair</span><br><span class="line">        PHYAD: 0</span><br><span class="line">        Transceiver: external</span><br><span class="line">        MDI-X: Unknown</span><br><span class="line">        Supports Wake-on: pumbg</span><br><span class="line">        Wake-on: d</span><br><span class="line">        Link detected: yes</span><br></pre></td></tr></table></figure><h1>把网卡指示灯打开</h1><p>在网卡支持这种功能的前提下,使用此命令会使网卡的指示灯闪烁,但需要注意,有些系统会持续闪烁,但有些版本会闪烁几秒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -p eth0</span><br></pre></td></tr></table></figure><h1>查看错误信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -S eth0 | grep error</span><br></pre></td></tr></table></figure><p>同时，使用<code>ifconfig</code> 也可以看错误信息</p><h1>错误信息</h1><ul><li>RX errors<br>表示总的收包的错误数量，这包括 too-long-frames 错误，Ring Buffer 溢出错误，crc 校验错误，帧同步错误，fifo overruns 以及 missed pkg 等等</li><li>RX dropped<br>表示数据包已经进入了 Ring Buffer，但是由于内存不够等系统原因，导致在拷贝到内存的过程中被丢弃</li><li>RX overruns<br>表示了 fifo 的 overruns，这是由于 Ring Buffer(aka Driver Queue) 传输的 IO 大于 kernel 能够处理的 IO 导致的，而 Ring Buffer 则是指在发起 IRQ 请求之前的那块 buffer。很明显，overruns 的增大意味着数据包没到 Ring Buffer 就被网卡物理层给丢弃了(就是ring buffer满之后先有drop收到的，再overrun没收的)，而 CPU 无法即使的处理中断是造成 Ring Buffer 满的原因之一</li><li>RX frame<br>表示 misaligned 的 frames</li></ul><h1>rx_crc_errors</h1><p>在大多数情况下，增加rx_crc_errors的值意味着该问题出在网络模型的第1层，当在接口上接收到数据包时，它将经历数据完整性检查，这称为循环冗余检查。 如果数据包在该检查中失败，则将其标记为rx_crc_errors<br>1.更换电缆。<br>2.检查交换机配置。<br>3.更换网络接口卡。</p>]]></content>
    
    
    <summary type="html">查看网口用的</summary>
    
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux好用命令之dd</title>
    <link href="https://www.dddachui.top/posts/3f7fa63c.html"/>
    <id>https://www.dddachui.top/posts/3f7fa63c.html</id>
    <published>2022-10-01T02:53:08.000Z</published>
    <updated>2023-03-13T12:48:43.904Z</updated>
    
    <content type="html"><![CDATA[<h1>命令简介</h1><blockquote><p><a href="https://www.cnblogs.com/sylar5/p/6649009.html">Linux 中用 dd 命令来测试硬盘读写速度 - Cyril_Wu - 博客园 (cnblogs.com)</a></p></blockquote><h1>基本用法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time dd if=/dev/zero  of=/dev/null bs=block_size count=number_of_blocks</span><br></pre></td></tr></table></figure><h1>参数选项</h1><ul><li>选项<ul><li>if=file  ：从 file 中读而不是标准输入</li><li>of=file ：写到 file 里去而不是标准输出</li><li>bs=bytes ：一次读和写  bytes 字节</li><li>ibs=bytes ：一次读 bytes 字节。默认是512</li><li>obs=bytes ：一次写 bytes 字节。默认是512</li><li>count=blocks ： 仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数</li><li>iflag=FLAGS   ：指定读的方式FLAGS</li><li>oflag=FLAGS  ：指定写的方式FLAGS</li></ul></li><li>FLAGS如下<ul><li>direct　　　读写数据采用直接IO方式；</li><li>directory　读写失败除非是directory；</li><li>dsync　　　读写数据采用同步IO；</li><li>sync　　　　同上，但是针对是元数据</li><li>fullblock　　堆积满block(iflag only)；</li><li>nonblock　读写数据采用非阻塞IO方式</li><li>noatime　　 读写数据不更新访问时间</li></ul></li></ul><h1>磁盘写能力测试</h1><p>/dev/zero是一个伪设备，只产生空字符流，不会产生IO，IO都会集中在of文件中，所以这个命令是测试磁盘的写能力。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=test bs=8k count=10000 oflag=direct</span><br></pre></td></tr></table></figure><h1>读取能力测试</h1><p>/dev/sdb是一个物理分区，对它的读取会产生IO，/dev/null是伪设备，是黑洞，of到该设备不会产生IO，所以，这个命令的IO只发生在/dev/sdb上，也相当于测试磁盘的读能力</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=test of=/dev/null bs=8k count=10000 iflag=direct</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">弟弟命令</summary>
    
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux好用命令之rsync</title>
    <link href="https://www.dddachui.top/posts/bc5c9a0b.html"/>
    <id>https://www.dddachui.top/posts/bc5c9a0b.html</id>
    <published>2022-09-25T12:08:32.000Z</published>
    <updated>2023-03-13T12:50:42.720Z</updated>
    
    <content type="html"><![CDATA[<h1>命令简介</h1><p>同步的手段</p><h1>简单用法</h1><p>静态文件部署，一般会用到此命令，完整命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --progress -e &#x27;ssh -p 2022&#x27; --exclude=&#x27;testfile&#x27; --delete $&#123;WORKSPACE&#125;/  root@192.168.42.100:/data/</span><br></pre></td></tr></table></figure><h1>参数可用</h1><ul><li>-a：–archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD</li><li>-v：输出详细过程</li><li>-z：对正在备份的文件进行压缩处理</li><li>-r：对子目录以递归模式处理</li><li>-l：保留软连接</li><li>-p：保持文件权限</li><li>-t：保持文件时间信息</li><li>-g：保持文件属组信息</li><li>-o：保持文件属主信息</li><li>-D：保持设备文件信息</li><li>-e： –rsh=command 指定使用rsh、ssh方式进行数据同步，一般使用ssh</li><li>exclude: 排除某文件的同步，可以多个。</li><li>–delete：删除那些DST中SRC没有的文件。</li><li>–progress：显示每个文件传输的进度。知道是否有大型文件正在备份可能是有用的</li></ul><h1>几个坑</h1><ul><li><p>将dirA的所有文件同步到dirB内，并删除dirB内多余的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --delete dirA/ dirB/ </span><br></pre></td></tr></table></figure></li></ul><blockquote><p>源目录和目标目录结构一定要一致！！</p><p>不能是dirA/* dirB/ 或者dirA/ dirB/* 或者 dirA/* dirB/*，如果不遵守，那么就不会删除。</p></blockquote><ul><li><p>将dirA的所有文件同步到dirB，但是在dirB内除了fileB3.txt这个文件不删之外，其他的都删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --delete --exclude &quot;fileB3.txt&quot; dirA/ dirB/</span><br></pre></td></tr></table></figure></li><li><p>将dirA目录内的fileA1.txt和fileA2.txt不同步到dirB目录内</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude=&quot;fileA1.txt&quot; --exclude=&quot;fileA2.txt&quot; dirA/ dirB/</span><br></pre></td></tr></table></figure></li><li><p>将dirA目录内的fileA1.txt和fileA2.txt不同步到dirB目录内，并且在dirB目录内删除多余的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude=&quot;fileA1.txt&quot; --exclude=&quot;fileA2.txt&quot; --delete dirA/ dirB/</span><br></pre></td></tr></table></figure></li><li><p>将dirA目录内的fileA1.txt和fileA2.txt不同步到dirB目录内，并且在dirB目录内删除多余的文件，同时，如果dirB内有fileA2.txt和fileA1.txt这两个被排除同步的文件，仍然将其删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude=&quot;fileA1.txt&quot; --exclude=&quot;fileA2.txt&quot; --delete-excluded dirA/ dirB/</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">同步</summary>
    
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>在Centos中检查RPM包的依赖性</title>
    <link href="https://www.dddachui.top/posts/179557ff.html"/>
    <id>https://www.dddachui.top/posts/179557ff.html</id>
    <published>2022-09-25T03:00:30.000Z</published>
    <updated>2023-03-13T12:30:55.103Z</updated>
    
    <content type="html"><![CDATA[<h1>产生原因</h1><ol><li>定制本地yum源的时候漏了几个依赖包,导致软件无法安装</li><li>配置的仓库包不完整,下载的软件的时候缺少几个包</li><li>由于网络环境,无法配置外网源,只能导入rpm包,但是缺少了几个依赖</li></ol><blockquote><p>很多场景下，是不允许配置yum源的</p></blockquote><h1>一个简单的栗子</h1><ul><li>安装zabbix的时候缺少依赖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh zabbix-server-mysql-3.4.4-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error: Failed dependencies:</span><br><span class="line">libOpenIPMI.so<span class="number">.0</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libOpenIPMIposix.so<span class="number">.0</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libevent-<span class="number">2.0</span>.so<span class="number">.5</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libiksemel.so<span class="number">.3</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libnetsnmp.so<span class="number">.31</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line">libodbc.so<span class="number">.2</span>()(64bit) is needed by zabbix-server-mysql-<span class="number">3.4</span><span class="number">.4</span>-<span class="number">1.</span>el7.x86_64</span><br></pre></td></tr></table></figure><p>显然是机器导入的rpm缺少依赖包导致的,但我们只能看到文件,无法看到这个文件在什么包</p><ul><li>查询在哪个rpm包</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum</span> whatprovides libOpenIPMI.so.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>结果如下,可以看到这文件是OpenIPMI-libs提供的,我们可以直接yum安装,或者由于网络问题,可以下载了导入机器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos, versionlock</span><br><span class="line">OpenIPMI-libs-2.0.27-1.el7.i686 : The OpenIPMI runtime libraries</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Provides    : libOpenIPMI.so.0</span><br></pre></td></tr></table></figure><ul><li><p>安装</p><ul><li><p>直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y OpenIPMI-libs-2.0.27-1.el7.i686</span><br></pre></td></tr></table></figure></li><li><p>下载导入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yumdownloader</span> --destdir=.   OpenIPMI-libs-<span class="number">2</span>.<span class="number">0</span>.<span class="number">27</span>-<span class="number">1</span>.el7.i686</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>优化解决依赖手法1</h1><p>除了<code>yum whatprovides libOpenIPMI.so.0</code>这种粗暴方式,其实我们有更好的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum deplist  zabbix50-5.0.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>输出如下.可以看到什么包需要什么,由谁提供</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos, versionlock</span><br><span class="line">package: zabbix50.x86_64 5.0.21-1.el7</span><br><span class="line">  dependency: config(zabbix50) = 5.0.21-1.el7</span><br><span class="line">   provider: zabbix50.x86_64 5.0.21-1.el7</span><br><span class="line">  dependency: libc.so.6()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.11)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.14)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.15)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.17)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.2.5)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.3)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.3.4)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.4)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libc.so.6(GLIBC_2.7)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libcrypto.so.10()(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcrypto.so.10(OPENSSL_1.0.1_EC)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcrypto.so.10(OPENSSL_1.0.2)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcrypto.so.10(libcrypto.so.10)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libcurl.so.4()(64bit)</span><br><span class="line">   provider: libcurl.x86_64 7.29.0-59.el7_9.1</span><br><span class="line">  dependency: libdl.so.2()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libm.so.6()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libm.so.6(GLIBC_2.2.5)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libpcre.so.1()(64bit)</span><br><span class="line">   provider: pcre.x86_64 8.32-17.el7</span><br><span class="line">  dependency: libpthread.so.0()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libpthread.so.0(GLIBC_2.2.5)(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libresolv.so.2()(64bit)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">  dependency: libssl.so.10()(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libssl.so.10(libssl.so.10)(64bit)</span><br><span class="line">   provider: openssl-libs.x86_64 1:1.0.2k-25.el7_9</span><br><span class="line">  dependency: libz.so.1()(64bit)</span><br><span class="line">   provider: zlib.x86_64 1.2.7-20.el7_9</span><br><span class="line">  dependency: libz.so.1(ZLIB_1.2.0)(64bit)</span><br><span class="line">   provider: zlib.x86_64 1.2.7-20.el7_9</span><br><span class="line">  dependency: logrotate</span><br><span class="line">   provider: logrotate.x86_64 3.8.6-19.el7</span><br><span class="line">  dependency: rtld(GNU_HASH)</span><br><span class="line">   provider: glibc.x86_64 2.17-326.el7_9</span><br><span class="line">   provider: glibc.i686 2.17-326.el7_9</span><br></pre></td></tr></table></figure><h1>优化解决依赖手法2</h1><p>配置一台和生产测试一样的虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zabbix50-5.0.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>使用yum install会自己查询依赖，如下所示，我们可以直接得到需要的依赖关系</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">正在安装</span><br><span class="line">ansible</span><br><span class="line">为依赖而安装</span><br><span class="line"><span class="keyword">python</span>-babel</span><br><span class="line"><span class="keyword">python</span>-httplib2</span><br><span class="line"><span class="keyword">python</span>-jinja2</span><br><span class="line"><span class="keyword">python</span>-paramiko</span><br><span class="line">python2-jmespath</span><br></pre></td></tr></table></figure><p>我们再次用<code>yumdownloader</code>命令进行下载包</p><h1>优化解决依赖手法3</h1><p>我常用的方法,但<code>需要注意</code>的是,使用<code>yumdownloader</code>的时候,他会检测本机的rpm包,然后下载软件缺失的依赖包,那么就是说,如果我本机和目的rpm列表有出入,可能我本机的包更多,那么我下载的依赖可能更少,那么导入目标机器结果依赖可能还是没解决,所以我们这个手法还是需要保持俩台机器的环境一致</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumdownloader --destdir=<span class="regexp">/root/</span>Desktop/rpms --resolve ansible</span><br></pre></td></tr></table></figure><h1>小工具-rpmreaper</h1><p>本来是用作清理系统中无用以及它们所依赖的包，它有很直观的ncurses界面来展示已安装的包和它们依赖关系的树形图</p><ul><li>安装</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> rpmreaper</span><br></pre></td></tr></table></figure><ul><li>运行</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rpmreaper</span></span><br></pre></td></tr></table></figure><p>rpmrepater会向用户显示已安装包的列表</p><ol><li><p>你可以使用上/下箭头来滚动屏幕</p></li><li><p>你可以在指定包上使用&quot;r&quot;键来显示其依赖关系，循环在指定包上按下&quot;r&quot;键可以展示出余下的信息</p></li><li><p>&quot;L&quot;标志的意思是说这个包是一片“孤叶”，意思说说没有任何包依赖它</p></li><li><p>&quot;o&quot;标志是说这个包是整个依赖链的中间部分</p></li><li><p>按下&quot;b&quot;键会显示其他依赖于该包的其他包</p></li></ol><h1>小工具-yumex</h1><p>yum Extender (简称 yumex ) , 是 yum 的图形化操作界面。可以通过 yumex 方便的查看软件包，安装、卸载软件包。对于对命令行不熟的人简直就是神奇，管理软件包很方便</p><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install yumex</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumex --root</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">解决依赖问题</summary>
    
    
    
    <category term="故障处理" scheme="https://www.dddachui.top/categories/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
    
    <category term="故障处理" scheme="https://www.dddachui.top/tags/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>局域网ip冲突解决方法</title>
    <link href="https://www.dddachui.top/posts/771f3e87.html"/>
    <id>https://www.dddachui.top/posts/771f3e87.html</id>
    <published>2022-09-25T02:36:51.000Z</published>
    <updated>2023-03-13T12:27:58.001Z</updated>
    
    <content type="html"><![CDATA[<h1>问题描述</h1><p>由于在一个网段下面ip地址是唯一的,当产生2个一样的ip的时候就会出现网络故障,可以hi使用一个工具<code>arp-scan</code>来扫描它们，这个工具会在本地网络发送ARP（Address Resolution Protocol）(地址解析协议)包来收集地址。如果有多个MAC地址声称拥有相同的IP地址，那么就存在冲突</p><h1>安装软件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y arp-scan</span><br></pre></td></tr></table></figure><h1>冲突检测</h1><p>指定eth1网卡进行检测</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan  --interface=eth1 -l</span><br></pre></td></tr></table></figure><h1>输出结果</h1><p>虚拟机不是很准,实际上是可以看到<code>DUP</code>的报错</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">1</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:c0:<span class="number">00</span>:<span class="number">08</span>VMware, Inc.</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">2</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:e1:<span class="number">0</span>b:edVMware, Inc.</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">254</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:e4:eb:<span class="number">75</span>VMware, Inc.</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">42</span>.<span class="number">2</span><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:e1:<span class="number">0</span>b:edVMware, Inc. (DUP: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ip冲突</summary>
    
    
    
    <category term="故障处理" scheme="https://www.dddachui.top/categories/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
    
    <category term="故障处理" scheme="https://www.dddachui.top/tags/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux好用命令之tar</title>
    <link href="https://www.dddachui.top/posts/2208ab89.html"/>
    <id>https://www.dddachui.top/posts/2208ab89.html</id>
    <published>2022-09-23T14:48:34.000Z</published>
    <updated>2023-03-13T12:51:01.596Z</updated>
    
    <content type="html"><![CDATA[<h1>命令简介</h1><p>Unix和<a href="https://baike.baidu.com/item/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F/4336219?fromModule=lemma_inlink">类Unix系统</a>上的压缩打包工具，可以将多个文件合并为一个文件，打包后的文件后缀亦为<strong>tar</strong></p><h1>参数</h1><h2 id="功能">功能</h2><ul><li>-c 创建压缩文件</li><li>-x  解压缩,提取</li><li>-t  查看压缩包内容</li><li>-r  附加新的文件到tar文件中</li><li>-u 用已打包的文件的较新版本更新tar文件</li><li>-A 将tar文件作为一个整体追加到另一个tar文件中</li><li>-d,–compare 将文件系统里的文件和tar文件里的文件进行比较</li><li>–delete  删除tar文件里的文件</li></ul><h2 id="常用选项">常用选项</h2><ul><li>-v 啰嗦模式,展示过程</li><li>-z 通过gzip指令压缩/解压缩文件,文件后缀名自己加<code>*.tar.gz</code></li><li>-p 保留原来的文件权限与属性</li><li>–exclude= 排除</li><li>-C 仅压缩指定目录里的内容或解压缩到指定目录</li></ul><h1>打包压缩</h1><ul><li>经典打包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf test.tar.gz  shell/  a.txt   b.sh</span><br></pre></td></tr></table></figure><ul><li>压缩带属性</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvpf log31.tar.gz log2014.log log2015.log log2016.log</span><br></pre></td></tr></table></figure><ul><li>压缩排除某些文件夹</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --exclude=/opt/test/a -czvf test.tar.gz /opt/test</span><br></pre></td></tr></table></figure><h1>列举查看压缩包</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf test<span class="selector-class">.tar</span><span class="selector-class">.gz</span> </span><br></pre></td></tr></table></figure><h1>解压缩</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf test.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压部分文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf  log.tar.gz  test/a.log</span><br></pre></td></tr></table></figure><blockquote><p>这个要先用-tvf列举出具体路径,不然找不到我示例的test/a.log</p></blockquote><ul><li>解压到指定位置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf a.tar.gz -C /opt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">压缩</summary>
    
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux的驱动问题</title>
    <link href="https://www.dddachui.top/posts/8715157e.html"/>
    <id>https://www.dddachui.top/posts/8715157e.html</id>
    <published>2022-09-23T04:49:22.000Z</published>
    <updated>2023-03-13T12:28:43.999Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>安装windows系统一般都会下载<code>驱动总裁</code>或者<code>鲁大师</code>,又或者通过微软的自动更新来更新系统的驱动,但在Linux里面,驱动一般是集成在linux内核里面的,如果我们有一个pci设备没有驱动且内核不支持该怎么处理?</p><h1>查看设备驱动</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lspci -k</span> </span><br></pre></td></tr></table></figure><p>可以先浏览一遍所有的pci设备,只需要关注每个设备是否有<code>Kernel driver in use</code>等字样,如果有的话就代表该设备可以驱动</p><ul><li>举个例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">02</span>:<span class="number">01.0</span> Ethernet controller: Intel Corporation 82545EM Gigabit Ethernet <span class="title function_">Controller</span> <span class="params">(Copper)</span> (rev <span class="number">01</span>)</span><br><span class="line">DeviceName: Ethernet0</span><br><span class="line">Subsystem: VMware PRO/<span class="number">1000</span> MT Single Port Adapter</span><br><span class="line">Kernel driver in use: e1000</span><br><span class="line">Kernel modules: e1000</span><br></pre></td></tr></table></figure><p>例如我有一个网卡,他成功加载了e1000的驱动,这样就代表我们可以使用该网卡</p><h1>没有驱动的处理</h1><p>如果没有<code>Kernel driver in use</code>字样,处理手段一般是<code>确认硬件型号</code>-&gt;<code>搜寻源代码</code>-&gt;<code>编译安装</code>来解决的</p><h2 id="确定型号">确定型号</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -<span class="keyword">nn</span> | <span class="keyword">grep</span> -i eth</span><br></pre></td></tr></table></figure><p>我们通过<code>-nn</code>参数来将<code>厂商号:设备号</code>输出如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">02</span>:<span class="number">01</span>.<span class="number">0</span> Ethernet : Intel Corporation <span class="number">82545</span>EM Gigabit <span class="meta"> [8086:100f] (rev 01)</span></span><br></pre></td></tr></table></figure><p>其中,我们只需要关注<code>[8086:100f]</code>这组数据就可以了</p><h2 id="含义">含义</h2><p><code>8086</code>是厂商号,代表某家厂商,<code>100f</code>是设备号,代表该厂商的产品</p><p>一般来说,如果内核完全不认网卡的话我们只能看出产品名字写的是<code>Ethernet</code>,也有一部分系统<code>可以认出全名</code>,如果能认出全名我们直接搜索全名就可以了,但如果没有全名我们只能依赖<code>厂商号:设备号</code>来定位设备</p><h2 id="网页搜索">网页搜索</h2><p>登陆<a href="https://devicehunt.com/">devicehunt网站</a>,我们只需要将我们的<code>device id</code>,即我例子中的<code>100f</code>填入搜索框,他就会将该设备的名字查询出来,类似这种网站的还有很多,比如 <a href="http://pci-ids.ucw.cz/read/PC/8088/0107">pci-ids.ucw.cz</a></p><h2 id="查找驱动">查找驱动</h2><p>既然已经知道型号了,那么就可以搜索对应的驱动源代码,一般找的网站有如下</p><ol><li>各个产品的官网</li><li>github或者gitee</li><li>我不知道了</li></ol><p>假设我们成功的找到的某个产品的驱动源代码,我们只需要导入我们的<code>linux发行版</code>进行编译安装</p><h1>编译安装</h1><p>例如我成功在<code>INTEL</code>官网下载了<code>e1000e-3.8.7.tar.gz</code>源码包</p><ul><li>解压源码包</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf e1000e-<span class="number">3</span>.<span class="number">8</span>.<span class="number">7</span>.tar.gz</span><br></pre></td></tr></table></figure><ul><li>查看README</li></ul><p>每个产品都会有类似的<code>README</code>文档来指导你如何使用,例如有如下2种方式,第一种就是让我们用<code>rpmbuild</code>来自己生成一个<code>rpm</code>包,第二种会让我生成一个<code>ko</code>文件,然后安装到内核里面去,然后我们再去使用<code>lspci</code>查看驱动的办法来验证是否记载驱动就可以了</p><ol><li><code>rpmbuild -tb e1000e-&lt;x.x.x&gt;.tar.gz</code></li><li>手动编译<ol><li>查看具体步骤,是否要先./configure</li><li>make编译</li><li>insmod xx.ko 手动加载驱动</li><li>使用lspci -nvs 01:00.0这种来看设备的驱动是否加载</li><li>如果加载成功就make install</li></ol></li></ol><blockquote><ol><li>makera,centos这些系统有的命令</li><li>make,gcc,g++这种命令属于开发工具,如果系统没有的话需要自己安装</li></ol></blockquote>]]></content>
    
    
    <summary type="html">如何判断有没有驱动?</summary>
    
    
    
    <category term="故障处理" scheme="https://www.dddachui.top/categories/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
    
    <category term="故障处理" scheme="https://www.dddachui.top/tags/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux好用命令之strace</title>
    <link href="https://www.dddachui.top/posts/dd9530c1.html"/>
    <id>https://www.dddachui.top/posts/dd9530c1.html</id>
    <published>2022-09-22T14:35:23.000Z</published>
    <updated>2023-03-13T12:50:51.898Z</updated>
    
    <content type="html"><![CDATA[<h1>命令简介</h1><p>strace是用来诊断,调试的linux用户空间跟踪器,来监视用户空间进程和内核交互,比如系统调用,信号传递,进程状态变更</p><h1>示例</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -tt -T -v -f -e [close|openat|execve] -o log  ./ceshi.sh -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><h1>常用选项</h1><ul><li>-tt : 显示毫秒级别</li><li>-T : 显示每次系统调用所消耗的时间</li><li>-v : 对于某些相关的调用,展示完整的环境变量,文件stat结构</li><li>-f : 跟踪目标进程以及目标进程创建的子进程</li><li>-e : 控制要跟踪的时间和跟踪行为,比如指定要跟踪的系统调用名称</li><li>-o : 把strace输出单独写到文件</li><li>-s : 系统调用某个参数是字符串的四行,最多输出指定长度的内容,默认32字节</li><li>-p : 指定要跟踪的进程pid 多个pid写多个-p</li></ul>]]></content>
    
    
    <summary type="html">诊断,调试linux用户空间跟踪器</summary>
    
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>系统资源异常处理思路</title>
    <link href="https://www.dddachui.top/posts/e853bb7.html"/>
    <id>https://www.dddachui.top/posts/e853bb7.html</id>
    <published>2022-09-22T06:07:16.000Z</published>
    <updated>2023-03-13T12:29:25.558Z</updated>
    
    <content type="html"><![CDATA[<h1>常见资源问题</h1><ol><li>系统操作卡顿</li><li>cpu,内存资源占用过高</li><li>进程占用资源高</li><li>系统异常重启或宕机</li><li>开机时间长</li></ol><h1>资源异常处理思路</h1><h2 id="日志分析">日志分析</h2><ul><li>dmesg</li><li>/var/log/*</li><li>串口调试</li><li>~/.xsession-errors</li></ul><h2 id="卡顿分析">卡顿分析</h2><ul><li>本地卡顿还是远程卡顿</li></ul><h2 id="异常进程">异常进程</h2><ul><li>strace进程跟踪</li><li>pstack进程跟踪</li><li>jstack进程跟踪(针对java)</li></ul><h2 id="更换用户测试">更换用户测试</h2><ul><li>切换用户没有问题则考虑~/.conf  ~/.cache 环境变量</li></ul><h2 id="是否和显卡有关系">是否和显卡有关系</h2><ul><li>是否有硬件加速</li><li>更换硬件</li><li>xdriinfo或Xorg.0.log日志分析</li></ul><h2 id="内核或驱动">内核或驱动</h2><ul><li>升级驱动(<a href="http://kernel.org">kernel.org</a>)</li><li>升级内核</li></ul><h2 id="core文件">core文件</h2><ul><li>tmp目录下是否有core,或者第三方程序下是否有</li><li>gdb调试</li></ul><h2 id="是否与桌面图形相关">是否与桌面图形相关</h2><ul><li>top看图形进程占用</li><li>关闭图形是否临时解决</li><li>lightdm/gdm服务状态</li></ul><h1>linux性能分析工具</h1><h2 id="cpu">cpu</h2><ul><li>top :  显示系统和进程cpu,内存关系</li><li>uptime :  系统平均负载</li><li>vmstat :  报告和采样内存,io,cpu信息</li><li>procinfo :  cpu和中断信息</li><li>mpstat :  分析cpu</li><li>sar :  分析cpu</li><li>oprofile :  分析系统,进程的消耗</li><li>perf :  分析cpu调用路径和消耗</li><li>time :  进程cpu使用信息</li><li>strace :  系统调用信息</li><li>lstrace :  库函数调用信息和耗时</li><li>ps :  对特定进程分析</li><li>pidstat :  分析进程对cpu的占用</li></ul><h2 id="内存">内存</h2><ul><li>vmstat :  分析内存,io,cpu</li><li>free :  展示系统和进程cpu,内存,使用情况</li><li>slabtop :  内核缓存分配和使用情况</li><li>sar -r :  内存信息</li><li>/proc/memoryinfo :  内存信息</li><li>ps  :  进程和内存关系</li><li>/proc/<pid>/mem :  进程内存信息</li><li>memprof :  图形化内存分析</li><li>kcachegnnd :  图形化内存分析</li><li>/proc/iomem :  物理地址分配信息</li><li>pmap :  进程内存映射信息</li></ul><h2 id="磁盘">磁盘</h2><ul><li>iostat :  统计设备和分区磁盘IO信息</li><li>iotop :  列出进程磁盘IO信息</li><li>sar -d :  报告磁盘IO相关信息</li><li>blktrace :  跟踪磁盘IO时间</li><li>lsof :  列出进程打开文件,目录信息</li><li>pidstat -d  :  进程磁盘io统计信息</li><li>dd :  测速</li><li>dstat :  全能的系统信息统计工具</li><li>fio :  测速</li><li>mount :  挂载</li><li>badblocks :  检查磁盘损坏的区块</li></ul><h2 id="网络">网络</h2><ul><li>nmcli :  网络配置工具</li><li>ifconfig :  网络接口和统计</li><li>iperf :  流量检测</li><li>tcpdump :  抓包</li><li>wireshark :  图形化抓包</li><li>ss :  套接字分析</li><li>netstat :  统计网络协议和接口信息</li><li>ethtool :  统计以太网设备信息</li><li>ping :  万能的ping检测</li><li>tracerout :  跟踪路由</li><li>route :  显示路由</li></ul><h1>进程分析</h1><h2 id="进程的相关知识">进程的相关知识</h2><h2 id="进程含义">进程含义</h2><ul><li><p>运行中的程序副本(指令加数据)</p></li><li><p>理想状态下是70%CPU时间用户模式+30%CPU时间内核模式.</p></li><li><p>进程需要内存来存放自己的指令和代码，需要cpu来运行指令并完成对数据的加工，此然也需要内存把自己所输出的数据及处理的结果给保存下来等等。事实上我们运行中的进程数量是远远多余cpu核心数量的</p></li><li><p>假如只有1个cpu,他要么在执行用户代码,要么执行内核代码,不能同时执行2个</p></li><li><p>内核为了追踪每个进程,必须实现每一个进程可随时调入和调出,准备很多数据结构来保存这些数据,这个过程即为<code>任务列表</code>,每个进程都有一个task,每一个task在内核中都有一个专门的数据格式来存放相关信息,包括进程id,进程的线程,在调度上进程和线程没有区别</p></li><li><p>io过程,进程运行的过程中,需要请求的数据如果不在内存里面,就会请求内核吧数据从磁盘载入内存,从而供程序访问,io就被分成了2段,第一段是内核将磁盘数据加载到内核内存,然后再从内核内存复制到进程内存</p></li></ul><h2 id="常用命令">常用命令</h2><ul><li>大致看进程使用全部内存,包括共享内存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | awk &#x27;&#123;total +=$6&#125;END&#123;print total&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>大致看进程易用内存,比aux精确</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep Pss /proc/[1-9]*/smaps | awk &#x27;&#123;total+=$2&#125;END&#123;print total&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>cpu占用最高的10个进程,以pid排序</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k3nr | head -n 10</span><br></pre></td></tr></table></figure><ul><li>内存占用最高的10个进程,以pid排序</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k4nr | head -n 10</span><br></pre></td></tr></table></figure><ul><li>树形看进程,但不能看内核进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -axjf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree</span><br></pre></td></tr></table></figure><ul><li>查看进程下的所有线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -efL | grep &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>查看进程下有哪些线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -T -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>top/htop<ul><li>top -Hp [pid]</li><li>top 然后按P或M</li><li>top 然后按F</li></ul></li><li>vmstat n m</li><li>mpstat nm</li><li>sar工具</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -u -h -f /var/log/saxxx</span><br></pre></td></tr></table></figure><ul><li>指定命令固定在某个cpu上</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -c 3 top</span><br></pre></td></tr></table></figure><ul><li>显示进程是否固定在某个cpu上</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">taskset -c -p &lt;pid&gt;</span><br><span class="line">ps -o pid,psr,comm -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><h1>java进程占用问题思路</h1><ul><li>找出占用最高的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top 按M</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k3nr | awk &#x27;&#123;print $3 &quot;\t&quot; $11&#125;&#x27; | head -n 10</span><br></pre></td></tr></table></figure><ul><li>找出进程占用最高的线程ID</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top  -Hp &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>找出cpu占用最高的线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -mp 2688 -o &quot;THREAD,tid,time&quot;</span><br></pre></td></tr></table></figure><ul><li>十进制线程号转换成十六进制线程号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%x\n&quot; &lt;tid&gt;</span><br></pre></td></tr></table></figure><ul><li>jstack找出问题代码</li></ul><p>tid(16进制西那才ID小写英文)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstack -l &lt;pid&gt;</span><br><span class="line">jstack -f &lt;pid&gt;</span><br><span class="line">jstack -l &lt;pid&gt; | grep tid -A 30</span><br></pre></td></tr></table></figure><blockquote><p>如果是java代码问题,应该找研发</p><p>如果是java虚拟机或者系统问题,应该继续查</p></blockquote><h1>其他进程占用cpu问题思路</h1><h2 id="top大法">top大法</h2><h3 id="用户态">用户态</h3><p>%us+%sy &gt; 70 ,用户态是否有可疑进程</p><h3 id="中断">中断</h3><ul><li>硬中断 hi</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -d cat <span class="regexp">/proc/i</span>nterrupts</span><br></pre></td></tr></table></figure><ul><li>软中断 si</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">watch</span> -n <span class="number">1</span> <span class="string">&quot;cat /proc/softirqs&quot;</span></span><br></pre></td></tr></table></figure><h3 id="灵异进程">灵异进程</h3><p>cpu占用很高但找不到</p><ul><li>关注<code>running</code>进程,是否有什么在不停的重启</li><li>关注<code>D</code>状态进程,不可中断的睡眠状态,该状态的进程无法kill,更不能自行退出,只能重启或恢复他依赖的资源来解决</li></ul><h2 id="uptime或w">uptime或w</h2><p>load average 越高,说明任务队列越长,处于等待的任务越多</p><h2 id="vmstat">vmstat</h2><ul><li>cs  上下文切换次数陡增或者和正常差别很大</li><li>in  中断次数较多</li><li>r  就绪队列长度一直高于最大cpu个数,考虑cpu竞争</li><li>wa  op等待cpu时间,值越大,磁盘大量做随机访问造成的,磁盘性能有瓶颈</li></ul><h2 id="pidstat">pidstat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -p &lt;pid&gt; -wt 1 10</span><br></pre></td></tr></table></figure><ul><li>Cswch/s 每秒主动任务上下文切换数量</li><li>Nvcswch/s 每秒被动任务上下文切换数量,值越大活吗进程被强制调度,就是争抢cpu,cpu时间片不足</li></ul><h2 id="sar">sar</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -q #查看近段时间cpu负载</span><br></pre></td></tr></table></figure><h2 id="判断是否是系统进程">判断是否是系统进程</h2><ul><li>U系</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S</span><br></pre></td></tr></table></figure><ul><li>R系</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf</span><br></pre></td></tr></table></figure><h2 id="显卡相关">显卡相关</h2><p>涉及到显卡硬件加速相关,有些应用可能需要用到,但可能走的是cpu软实现,并没有用到硬件</p><h2 id="是否程序不断自启动">是否程序不断自启动</h2><p>有些程序利用定时任务不断拉起服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rni &quot;进程&quot; /etc</span><br></pre></td></tr></table></figure><h2 id="对比其他机器">对比其他机器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -c top -d 1 -n 5</span><br></pre></td></tr></table></figure><h1>内存分析</h1><p>linux内存管理子系统架构<code>用户空间</code>,<code>内核空间</code>,<code>机器硬件</code></p><h2 id="查看配置">查看配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure><p>关注如下</p><ol><li>MemTotal 物理大小</li><li>MemFree 空闲</li><li>MemAvailabe 可用</li><li>Buffers 给文件做缓冲的</li><li>Cached 高速缓冲控制器</li><li>SwapCacaed</li><li>Active 活跃使用的bufferf或cache</li><li>Inactive 不经常用的大小</li><li>Slab</li><li>Sreclaimable  可回收slab</li><li>Sunreclaim 不可回收slab</li></ol><h2 id="检查现有的">检查现有的</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><p>应用可用内存~free+buffers+cached</p><p>Mem:avaiable~/proc/meminfo的MenAvailable</p><h1>smem</h1><ul><li>VSS</li></ul><p>虚拟耗用内存,包含共享库使用的内存</p><ul><li>RSS</li></ul><p>实际使用内存,包含共享库占用的,用top可以查到,最常用的内存指标,是进程占用的物理内存大小,Rss包含进程间共享的内存,所以累加起来会超出系统的内存消耗</p><ul><li>PSS</li></ul><p>所有使用某共享库的程序均分该共享库占用的内存时,每个进程占用的内存,所有进程的PSS之和就是系统的内存使用量,更精确,是将共享内存平均分摊到各个进程中的</p><ul><li>USS</li></ul><p>进程独自占用的物理内存,是PSS中自己的部分,只计算进程独自占用的</p><h2 id="常用命令-2">常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure><ul><li>实时显示内核slab缓冲区信息</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">slabtop</span></span><br></pre></td></tr></table></figure><ul><li>是否有内存限制或预留内存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cmdline</span><br></pre></td></tr></table></figure><ul><li>查看进程总内存是否正常</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | awk &#x27;&#123;total+=$6&#125;END&#123;print total/1024&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>日志分析超出内存或alloc的问题</li></ul><ol><li>dmesg</li><li>kernel.log</li><li>syslog</li></ol><ul><li>近段时间内存分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -r -h -f /var/log/sa/saxx</span><br></pre></td></tr></table></figure><ul><li>串口调试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启,引导加入console=ttyS0,115200n8</span></span><br></pre></td></tr></table></figure><h2 id="对比测试">对比测试</h2><ol><li>和centos对比</li><li>重新部署程序或和正常机器对比</li><li>换个用户排除环境变量问题</li><li>异常和正常的机器硬件,系统,bios,主板,硬盘,cpu,内存,包,是否一致</li><li>内存泄露问题,meminfo取多份对比,看看是在内核还是用户进程</li></ol><h2 id="核内内存问题">核内内存问题</h2><ol><li>MemFree和MemAvailable,定位内存消耗的方向是内核还是用户</li><li>slabtop实时观察哪个slab一直增高</li><li>对比看slab增长情况</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo  | grep -Ei &quot;slab|reclaim&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>定位具体的slab问题</li></ol><p>取多份slabinfo对比,带着/sys/kernel/slab分析</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>slabinfo</span><br></pre></td></tr></table></figure><p>如果dentry高,判断下是否进程对文件频繁读写,可以用strace分析</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -fp &lt;pid&gt; -e trace=<span class="keyword">open</span>,<span class="keyword">stat</span>,<span class="keyword">close</span>,<span class="keyword">unlink</span></span><br></pre></td></tr></table></figure><ol start="5"><li>内核问题一般是驱动问题<ol><li>lsmod对比</li><li>卸载驱动</li><li>驱动分析</li></ol></li><li>找到驱动地址</li></ol><p>可以看到函数对应的地址,通过地址找到驱动,也可以通过驱动找到地址</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/i</span>omem</span><br></pre></td></tr></table></figure><h2 id="核外内存问题">核外内存问题</h2><ol><li><p>top按M查看占用最大的</p></li><li><p>ps大法</p></li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ps</span> -aux | awk <span class="string">&#x27;&#123;total+=<span class="variable">$6</span>&#125;END&#123;print total/1024&#125;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux --<span class="built_in">sort</span> -rss | <span class="built_in">head</span></span><br></pre></td></tr></table></figure><ol start="3"><li>ps_mem</li><li>dstat</li></ol><p>动态展示进程内存占用</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat <span class="comment">--top-mem</span></span><br></pre></td></tr></table></figure><ol start="5"><li>进程内存分析</li></ol><ul><li>查看smaps</li></ul><p>smaps展示了一个进程的内存消耗</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/&lt;pid&gt;/smaps</span><br></pre></td></tr></table></figure><ul><li>内存泄露</li></ul><p>VIRT/VSZ或者writeable/private,如果在重复操作中一直问题,那么应该是内存泄露</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pmap -d &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li>strace调试</li></ul><h2 id="pid是否超过限度">pid是否超过限度</h2><p><code>fork:cannot allocate memory</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | wc -l</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat  /proc/sys/kernel/pid_max</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysc &amp;&amp; echo3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><p>linux下频繁存取文件之后,物理内存会被消耗完,程序结束之后不会立即被正常释放的</p><h1>磁盘问题</h1><ul><li>磁盘整体使用情况</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -i</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/fstab</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid</span><br></pre></td></tr></table></figure><ul><li>是否开启读写缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cache</span><br></pre></td></tr></table></figure><ul><li>查看队列模式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/block/&lt;磁盘名&gt;/queue/scheduler </span><br></pre></td></tr></table></figure><ul><li>设置队列模式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &lt;队列模式&gt; &gt;&gt;  /sys/block/&lt;磁盘名&gt;/queue/scheduler </span><br><span class="line">echo  mq-deadline &gt;&gt;  /sys/block/&lt;磁盘名&gt;/queue/scheduler </span><br></pre></td></tr></table></figure><p>grub加入scsi_mod.use_blk_mq=0 elevator=deadline 修改算法</p><ul><li>查看磁盘调度算法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i scheduler</span><br></pre></td></tr></table></figure><ul><li>查看io</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x -N -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat -d</span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat -d <span class="comment">--top-io</span></span><br></pre></td></tr></table></figure><ul><li>io性能测试</li></ul><ol><li>blktrace</li><li>fio</li><li>dd</li></ol><ul><li>检测磁盘健康</li></ul><ol><li>badblocks</li><li>e2fsck</li><li>fsck</li><li>xfs_repair</li></ol><ul><li>判断磁盘类型</li></ul><p>1=HDD</p><p>0=SSD</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/sys/</span>block<span class="regexp">/&lt;磁盘名&gt;/</span>queue/rotational  </span><br></pre></td></tr></table></figure><ul><li>是否开启缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cache | grep -i read #读缓存</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cache | grep -i write #读缓存</span><br></pre></td></tr></table></figure><h2 id="磁盘分析工具">磁盘分析工具</h2><h3 id="dd">dd</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试写速率,请求直接变成io指令发到磁盘</span></span><br><span class="line">time dd if=/dev/zero of=test bs=4k count=100000 oflag=direct status=progress</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试写速率,规避cache</span></span><br><span class="line">time dd if=test  of=/dev/null bs=4k count=100000 oflag=direct status=progress</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试读速率,规避cache</span></span><br><span class="line">time dd if=/dev/xxx  of=/dev/null bs=4k count=100000 oflag=direct status=progress</span><br></pre></td></tr></table></figure><h3 id="blktrace">blktrace</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.采集信息,根据cpu个数生成文件个数,名字是&#123;device&#125;.blktrace.&#123;cpu&#125;</span></span><br><span class="line">blktrace -d /dev/sdX  [-o /tmp/sda ]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.合并信息,执行btt就要先把blktrace生成的文件合并</span></span><br><span class="line">blkparse -i sda -d sda.blkparse.bin</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.统计信息,将合并的信息分解程很多歌名字相关的文件信息</span></span><br><span class="line">btt -i sda.blkparse.bin -o sda.btt</span><br></pre></td></tr></table></figure><h2 id="磁盘检查修复工具">磁盘检查修复工具</h2><h3 id="badblocks">badblocks</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.扫描</span></span><br><span class="line">badblocks -s -v /dev/xxx</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.如果找到了坏道,可以进行写入扫描进行修复,写入扫描遇到坏道的时候自动重映射,扫描会覆盖原有数据,要备份的,写入扫描速度很低,所以应该扫描只读扫描时候发现错误的地方</span></span><br><span class="line">badblocks -w -s -v /dev/xxx [END] [START]</span><br></pre></td></tr></table></figure><h3 id="fstrim">fstrim</h3><p>回收已经挂载的文件系统未使用的块</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fstrim -av</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">逐步学习系统异常的排查方法</summary>
    
    
    
    <category term="故障处理" scheme="https://www.dddachui.top/categories/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
    
    <category term="故障处理" scheme="https://www.dddachui.top/tags/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux好用命令之pidstat</title>
    <link href="https://www.dddachui.top/posts/33b1a077.html"/>
    <id>https://www.dddachui.top/posts/33b1a077.html</id>
    <published>2022-09-21T05:51:57.000Z</published>
    <updated>2023-03-13T12:49:55.054Z</updated>
    
    <content type="html"><![CDATA[<h1>命令简介</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;命令简介&lt;/h1&gt;
</summary>
      
    
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux好用命令之iostat</title>
    <link href="https://www.dddachui.top/posts/84a73f90.html"/>
    <id>https://www.dddachui.top/posts/84a73f90.html</id>
    <published>2022-09-21T05:48:17.000Z</published>
    <updated>2023-03-13T12:49:25.047Z</updated>
    
    <content type="html"><![CDATA[<h1>命令简介</h1><p>分析io性能</p><h1>概述</h1><p>在衡量磁盘性能时的基本指标：<code>利用率</code>、<code>饱和度</code>、<code>IOPS</code>、<code>吞吐量</code>和<code>响应时间</code></p><ol><li>利用率(Utilization):磁盘处理I/O的时间百分比,过度使用<code>(如超过 80%)</code>通常意味着磁盘I/O存在性能瓶颈</li><li>饱和度(Saturation):指磁盘处理I/O的繁忙程度,过度饱和意味着磁盘存在严重的性能瓶颈,当饱和度为100%时,磁盘无法接受新的I/O请求</li><li>IOPS(Input/Output Per Second):指每秒I/O请求的数量</li><li>吞吐量(Throughput):每秒I/O请求的大小</li><li>响应时间(Response time):指发送I/O请求和接收响应之间的间隔时间</li></ol><blockquote><p>一般面对IO问题,我们先考虑<code>是否产生了IO问题</code>,在安装系统之后一般都是要对磁盘进行一个测试的,常用的工具有<code>dd</code>,<code>fio</code>等,目的是要检验出磁盘的<code>随机读</code>、<code>顺序读</code>、<code>随机写</code>、<code>顺序写</code><br>等性能(通常是 512B ~ 1MB 之间),以判断是否能够满足应用的需求</p></blockquote><h1>命令参数</h1><p><strong>-c：</strong> 显示CPU使用情况<br><strong>-d：</strong> 显示磁盘使用情况<br><strong>-N：</strong> 显示磁盘阵列(LVM) 信息<br><strong>-n：</strong> 显示NFS 使用情况<br><strong>-k：</strong> 以 KB 为单位显示<br><strong>-m：</strong> 以 M 为单位显示<br><strong>-t：</strong> 报告每秒向终端读取和写入的字符数和CPU的信息<br><strong>-V：</strong> 显示版本信息<br><strong>-x：</strong> 显示详细信息<br><strong>-p：</strong>[磁盘] 显示磁盘和分区的情况</p><h1>多种用法简介</h1><ul><li>间隔1秒，总共显示5次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat 1 5</span><br></pre></td></tr></table></figure><ul><li>每隔2秒,显示一次设备统计信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d 2</span><br></pre></td></tr></table></figure><ul><li>每隔2秒,显示一次设备统计信息.总共输出3次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d 2 3</span><br></pre></td></tr></table></figure><ul><li>每隔2秒显示一次sda, sdb两个设备的扩展统计信息,共输出3次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x sda sdb 2 3</span><br></pre></td></tr></table></figure><ul><li>每隔2秒显示一次sda及上面所有分区的统计信息,共输出3次</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -p sda 2 3</span><br></pre></td></tr></table></figure><ul><li>以M为单位显示所有信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -m</span><br></pre></td></tr></table></figure><ul><li>报告每秒向终端读取和写入的字符数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -t</span><br></pre></td></tr></table></figure><ul><li>显示指定硬盘信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d sda</span><br></pre></td></tr></table></figure><ul><li>查看TPS和吞吐量信息</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">iostat</span> -d -k <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>查看设备使用率和响应时间</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">iostat</span> -d -k <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h1>简单使用方法</h1><p>直接使用,显示所有设备负载情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat</span><br></pre></td></tr></table></figure><p>下面是输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.30    0.00    0.07    0.01    0.00   99.62</span><br><span class="line"></span><br><span class="line">Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd</span><br><span class="line">dm-0              3.40        67.65         6.81         0.00     492797      49628          0</span><br><span class="line">dm-1              0.01         0.30         0.00         0.00       2216          0          0</span><br><span class="line">sda               1.89        84.39         6.52         0.00     614737      47473          0</span><br><span class="line">sdb               0.02         0.35         0.00         0.00       2569          4          0</span><br></pre></td></tr></table></figure><ul><li>含义解释</li></ul><ol><li>%user：CPU在<code>用户模式</code>下的时间百分比</li><li>%nice：CPU在带NICE值的用户模式下的时间百分比</li><li>%system：CPU在系统模式下的时间百分比</li><li>%iowait：CPU等待输入输出完成时间的百分比</li><li>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比</li><li>%idle：CPU<code>空闲时间</code>百分比</li><li>device:磁盘名称</li><li>tps：每秒钟发送到的I/O请求数</li><li>Blk_read/s：每秒读取的block数</li><li>Blk_wrtn/s：每秒写入的block数</li><li>Blk_read：读入的block总数</li><li>Blk_wrtn：写入的block总数</li></ol><blockquote><p>%iowait的值过高，表示硬盘存在I/O瓶颈<br>%idle值高，表示CPU较空闲<br>%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量<br>%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。</p></blockquote><h1>整体磁盘I/O观察(重点)</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x -N -p</span><br></pre></td></tr></table></figure><p>iostat 是最常用的磁盘 I/O 性能观察工具。它提供了各种常用性能指标，例如每个磁盘的利用率、IOPS 和吞吐量<br>下面是<code>iostat</code>的输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">scd0              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">dm-0              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">dm-1              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br></pre></td></tr></table></figure><p>每一列都对应了之前说的<code>基本指标</code></p><ul><li><code>%util</code> 是我们前面提到的磁盘I/O使用情况,</li><li><code>r/s</code> 和 <code>w/s</code> 是 IOPS</li><li><code>rkB/s</code> 和 <code>wkB/s</code> 是吞吐量</li><li><code>r_await</code> 和 <code>w_await</code> 是响应时间</li></ul><blockquote><p>关于磁盘饱和度,可以利用<code>平均请求队列长度</code>或<code>完成读写请求的等待时间</code>与<code>基准测试（例如通过 fio）的结果</code>进行比较</p><p>从iostat无法得出磁盘的饱和度,饱和度反应的是磁盘处理io的繁忙程度,过高的饱意味着磁盘有严重的io问题,饱和度100%时候无法接受新的io请求</p></blockquote><h1>查看设备使用率,响应时间</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x 1 1</span><br></pre></td></tr></table></figure><p>以下是输出结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Device</span>            r/s     rkB/s   rrqm/s  %rrqm r_await rareq-sz     w/s     wkB/s   wrqm/s  %wrqm w_await wareq-sz     d/s     dkB/s   drqm/s  %drqm d_await dareq-sz     f/s f_await  aqu-sz  %util</span><br><span class="line"><span class="attribute">dm</span>-<span class="number">0</span>             <span class="number">1</span>.<span class="number">70</span>     <span class="number">67</span>.<span class="number">07</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">2</span>.<span class="number">90</span>    <span class="number">39</span>.<span class="number">45</span>    <span class="number">1</span>.<span class="number">68</span>      <span class="number">6</span>.<span class="number">80</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">38</span>     <span class="number">4</span>.<span class="number">04</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">01</span>   <span class="number">0</span>.<span class="number">11</span></span><br><span class="line"><span class="attribute">dm</span>-<span class="number">1</span>             <span class="number">0</span>.<span class="number">01</span>      <span class="number">0</span>.<span class="number">30</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">2</span>.<span class="number">32</span>    <span class="number">22</span>.<span class="number">85</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span></span><br><span class="line"><span class="attribute">sda</span>              <span class="number">1</span>.<span class="number">10</span>     <span class="number">83</span>.<span class="number">67</span>     <span class="number">0</span>.<span class="number">82</span>  <span class="number">42</span>.<span class="number">71</span>    <span class="number">2</span>.<span class="number">38</span>    <span class="number">76</span>.<span class="number">10</span>    <span class="number">0</span>.<span class="number">78</span>      <span class="number">6</span>.<span class="number">50</span>     <span class="number">0</span>.<span class="number">91</span>  <span class="number">53</span>.<span class="number">78</span>    <span class="number">0</span>.<span class="number">66</span>     <span class="number">8</span>.<span class="number">34</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">15</span>    <span class="number">1</span>.<span class="number">66</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">11</span></span><br><span class="line"><span class="attribute">sdb</span>              <span class="number">0</span>.<span class="number">02</span>      <span class="number">0</span>.<span class="number">35</span>     <span class="number">0</span>.<span class="number">02</span>  <span class="number">43</span>.<span class="number">12</span>   <span class="number">15</span>.<span class="number">22</span>    <span class="number">16</span>.<span class="number">79</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">8</span>.<span class="number">75</span>     <span class="number">1</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>      <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">8</span>.<span class="number">75</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">0</span>.<span class="number">03</span></span><br></pre></td></tr></table></figure><ol><li><strong>rrqm/s:</strong>  每秒进行 merge 的读操作数目。即 rmerge/s</li><li><strong>wrqm/s:</strong>  每秒进行 merge 的写操作数目。即 wmerge/s</li><li><strong>r/s:</strong>  每秒完成的读 I/O 设备次数。即 rio/s</li><li><strong>w/s:</strong>  每秒完成的写 I/O 设备次数。即 wio/s</li><li><strong>rkB/s:</strong>  每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</li><li><strong>wkB/s:</strong>  每秒写K字节数。是 wsect/s 的一半。</li><li><strong>avgrq-sz:</strong>  平均每次设备I/O操作的数据大小 (扇区)。</li><li><strong>avgqu-sz:</strong>  平均I/O队列长度。</li><li><strong>rsec/s:</strong>  每秒读扇区数。即 rsect/s</li><li><strong>wsec/s:</strong>  每秒写扇区数。即 wsect/s</li><li>**r_await:**每个读操作平均所需的时间</li><li>不仅包括硬盘设备读操作的时间，还包括了在kernel队列中等待的时间。</li><li>**w_await:**每个写操作平均所需的时间</li><li>不仅包括硬盘设备写操作的时间，还包括了在kernel队列中等待的时间。</li><li><strong>await:</strong> 平均每次设备I/O操作的等待时间 (毫秒)。</li><li><strong>svctm:</strong> 平均每次设备I/O操作的服务时间 (毫秒)。</li><li><strong>%util:</strong>  一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</li></ol><blockquote><p>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。</p><p>如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间</p><p>如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化</p><p>如果avgqu-sz比较大，也表示有当量io在等待。</p></blockquote>]]></content>
    
    
    <summary type="html">监测 Linux 的磁盘 I/O 性能</summary>
    
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>文件描述符和进程数调优</title>
    <link href="https://www.dddachui.top/posts/b379b34f.html"/>
    <id>https://www.dddachui.top/posts/b379b34f.html</id>
    <published>2022-09-18T06:14:25.000Z</published>
    <updated>2023-03-13T12:28:59.475Z</updated>
    
    <content type="html"><![CDATA[<h1>问题描述</h1><ul><li><p>文件描述符</p><p><code>Too many open files</code>是Linux系统中常见的错误,从字面意思上看就是说程序打开的文件数过多,其实files不单是文件的意思,也包括打开的通讯链接(比如socket),正在监听的端口等等,也可以叫做句柄(handle),这个错误通常也可以叫做<code>句柄数超出系统限制</code></p></li><li><p>用户打开进程数</p><p><code>no more progres</code>或者是<code>Resource temporarily unavailable</code>,是没有更多的进程可用,产生的原因可能有</p><ol><li>用户的nproc达到限制，无法创建新的进程</li><li>系统没有可分配的的pid，即进程号已经达到内核参数kernel.pid_max的限制</li><li>系统可用内存低，新的进程无法申请到内存导致不能启动</li></ol><p>nproc是操作系统级别对每个用户创建的进程数的限制,在Linux下运行多线程时,每个线程的实现其实是一个轻量级的进程,对应的术语是:light weight process(LWP)</p></li></ul><h1>产生的原因</h1><p>Linux操作系统中利用<code>ulimit</code>限制shell启动进程占用的资源,ulimit支持对用户的<code>打开进程数</code>、<code>进程打开文件句柄数</code>、<code>进程打开文件的大小</code>、进程coredump文件`大小等资源进行限制，从而防止某个用户进程过度占用系统资源，避免影响整个操作系统和其他应用的正常运行。但是使用ulimit进行限制后，当用户资源超限制时会出现各种各样的报错</p><h1>文件描述符达到上限</h1><h2 id="修改上限file-max">修改上限file-max</h2><p>这是<code>系统级</code>参数,file-max是查看所有进程的打开文件数量的系统范围限制,即系统可打开的最大数量,但日志里面报&quot;file-max reached&quot;的时候才去修改</p><ul><li>查看file-max数值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max  </span><br></pre></td></tr></table></figure><p>file-max的值也也和下面有近似</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r MemTotal /proc/meminfo | awk &#x27;&#123;printf(&quot;%d&quot;,$2/10)&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="修改方法">修改方法</h3><ul><li>写入sysctl.conf</li></ul><p>重启生效,建议先用临时设定确定一个值之后写入配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;fs.file-max = 6553560&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><p>重启恢复默认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo  6553560 &gt; /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w &quot;fs.file-max=6553560&quot;</span><br></pre></td></tr></table></figure><h2 id="修改nr-open">修改nr_open</h2><p>这是<code>进程级</code>的参数,查看单个进程可以打开的最大文件数</p><ul><li>查看</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/nr_open   #输出1048576即是1024*1024,正好是100万</span><br></pre></td></tr></table></figure><h3 id="修改方法-2">修改方法</h3><ul><li>写入sysctl.conf</li></ul><p>重启生效,建议先用临时设定确定一个值之后写入配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;fs.nr_open=100000000&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><p>,重启恢复默认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo  100000000 &gt; /proc/sys/fs/nr_open</span><br></pre></td></tr></table></figure><ul><li>临时生效</li></ul><p>重启恢复默认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w &quot;fs.nr_open=100000000&quot;</span><br></pre></td></tr></table></figure><h2 id="查看file-nr">查看file-nr</h2><p>他其实就是一个统计,输出<code>当前打开的文件数</code>,<code>空闲文件句柄数量</code>,<code>文件句柄的最大数量(file-max)</code>三列值,这是一个只读文件,是拿来看资源的,不用修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-nr   #输出55040195620</span><br></pre></td></tr></table></figure><h2 id="修改limits-conf">修改limits.conf</h2><p>既可以用<code>ulimit命令</code>来修改,也可以<code>写进系统的配置文件</code></p><blockquote><p>注意</p><ol><li><p>nofile是打开最大文件数, 对应limits.conf的nofile参数,重启生效</p></li><li><p>soft要小于hard</p></li><li><p>nofile的值需要小于等于nr_open的值</p></li></ol></blockquote><ul><li>修改成如下</li></ul><p>将所有用户的对<code>文件描述符</code>的限制都改成6553500</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 6553500</span><br><span class="line">* hard nofile 6553500</span><br></pre></td></tr></table></figure><h2 id="分析系统">分析系统</h2><p>其实<code>调优</code>只是释放资源的一种手段,更重要的是找出原因,可能是业务某个时间段业务量激增,也可能是应用触发了某个bug</p><ul><li>统计各命令打开句柄数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure><ul><li>统计各进程打开句柄数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &#x27;&#123;print $2&#125;&#x27; | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure><ul><li>统计各用户打开句柄数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &#x27;&#123;print $3&#125;&#x27; | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure><h2 id="复现方法">复现方法</h2><p>将我们的资源临时改成<code>6</code>,此时类似<code>top</code>或者<code>lsof</code>等命令就已经不能用了,因为他们产生的句柄会很多,而我们只限制只能打开<code>6</code></p><ul><li>临时修改nofile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 6</span><br></pre></td></tr></table></figure><ul><li>随便输入某些命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><ul><li>触发报错</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span>: failed <span class="attribute">openproc</span>: Too many open files</span><br></pre></td></tr></table></figure><h1>用户最大进程数量达到上限</h1><p>在rhel6和7上面,这个参数默认对root没有限制,他是从内核继承的,对于其他用户来说就4096,是根据下面的文件设定的</p><ul><li>CentOS6中limits.d下面是90-nproc.conf</li><li>CentOS7中limits.d下面是20-nproc.conf</li></ul><h2 id="如何查看">如何查看</h2><ul><li>查看所有用户创建的进程数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps h -Led -o user | sort | uniq -c | sort -n</span><br></pre></td></tr></table></figure><ul><li>指定某个用户查看创建的进程数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o nlwp,pid,lwp,args -u root | sort -n</span><br></pre></td></tr></table></figure><h2 id="修改xx-nproc-conf文件">修改xx-nproc.conf文件</h2><p>将第一行的nproc的值放大,我一般是改成4096,如果还不够继续放大</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*          soft    nproc     1024</span><br><span class="line">root       soft    nproc     unlimite</span><br></pre></td></tr></table></figure><h2 id="如何生效">如何生效</h2><p>有2种方法如下,任选其中之一</p><ul><li>本地注销桌面或者退出终端重新登陆</li><li>重启最好</li></ul><h2 id="验证结果">验证结果</h2><h3 id="对于bash用户">对于bash用户</h3><ul><li>查看方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><p>修改的是<code>nproc</code>参数,对应<code>max user processes</code>字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">real-time non-blocking time  (microseconds, -R) unlimited</span><br><span class="line">core file size              (blocks, -c) unlimited</span><br><span class="line">data seg size               (kbytes, -d) unlimited</span><br><span class="line">scheduling priority                 (-e) 0</span><br><span class="line">file size                   (blocks, -f) unlimited</span><br><span class="line">pending signals                     (-i) 61604</span><br><span class="line">max locked memory           (kbytes, -l) 64</span><br><span class="line">max memory size             (kbytes, -m) unlimited</span><br><span class="line">open files                          (-n) 65535</span><br><span class="line">pipe size                (512 bytes, -p) 8</span><br><span class="line">POSIX message queues         (bytes, -q) 819200</span><br><span class="line">real-time priority                  (-r) 0</span><br><span class="line">stack size                  (kbytes, -s) 8192</span><br><span class="line">cpu time                   (seconds, -t) unlimited</span><br><span class="line">max user processes                  (-u) 61604</span><br><span class="line">virtual memory              (kbytes, -v) unlimited</span><br><span class="line">file locks                          (-x) unlimited</span><br></pre></td></tr></table></figure><h3 id="对于tcsh用户">对于tcsh用户</h3><ul><li>查看方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><p>修改的是<code>nproc</code>参数,对应<code>maxproc</code>字段</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cputime</span>      unlimited</span><br><span class="line"><span class="attribute">filesize</span>     unlimited</span><br><span class="line"><span class="attribute">datasize</span>     unlimited</span><br><span class="line"><span class="attribute">stacksize</span>    <span class="number">8192</span> kbytes</span><br><span class="line"><span class="attribute">coredumpsize</span> unlimited</span><br><span class="line"><span class="attribute">memoryuse</span>    unlimited</span><br><span class="line"><span class="attribute">vmemoryuse</span>   unlimited</span><br><span class="line"><span class="attribute">descriptors</span>  <span class="number">65535</span> </span><br><span class="line"><span class="attribute">memorylocked</span> <span class="number">64</span> kbytes</span><br><span class="line"><span class="attribute">maxproc</span>      <span class="number">61604</span> </span><br><span class="line"><span class="attribute">maxlocks</span>     unlimited</span><br><span class="line"><span class="attribute">maxsignal</span>    <span class="number">61604</span> </span><br><span class="line"><span class="attribute">maxmessage</span>   <span class="number">819200</span> </span><br><span class="line"><span class="attribute">maxnice</span>      <span class="number">0</span> </span><br><span class="line"><span class="attribute">maxrtprio</span>    <span class="number">0</span> </span><br><span class="line"><span class="attribute">maxrttime</span>    unlimited</span><br></pre></td></tr></table></figure><h2 id="复现方法-2">复现方法</h2><ul><li>将普通用户的nproc临时修改</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ulimit</span> -u  <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>简单写个test.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        pid=fork();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count= %d\n&quot;</span>,count);&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="keyword">test</span>.c -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><ul><li>执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure><ul><li>报错</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: fork: retry: 资源暂时不可用</span><br></pre></td></tr></table></figure><h1>想法</h1><ul><li><p>[x] <code>limits.conf和xx-nproc.conf都支持修改</code>nproc<code>,为什么就改xx-nproc.conf? </code>因为/etc/security/limits.d/里面的文件里面的配置会覆盖/etc/security/limits.conf的配置</p></li><li><p>[x] <code>顺序</code>?soft&lt;hard&lt;nr_open&lt;file-max</p></li><li><p>[ ] <code>文件描述符的上限在哪?</code></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for  V in `seq  100000  10000000` ; do ulimit -n $V ; [[ $? != 0 ]] &amp;&amp; break;done</span><br></pre></td></tr></table></figure><ul><li><p>[x] <code>lsof是否可以用来排查这俩个报错?</code>lsof可以看打开的文件数量,用ps看进程数量</p></li><li><p>[x] <code>file-max的上限在哪里呢?</code>只要你的内存足够大，file-max的值可以非常大(大概这么说)</p></li><li><p>[x] <code>nproc的最大是在哪里?</code></p></li></ul><p>这个数字在centos8(不包括8)是和配置显示一致的,在8之后由内核决定,通过下面的命令,可以计算出我们可以配置的最大的nproc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(($(cat /proc/sys/kernel/threads-max)/2))</span><br></pre></td></tr></table></figure><ul><li>[x] 之前一直拿root做实验,其实得用普通用户来验证所有的效果,就比如nproc,root和普通用户看到是不一样的,明显默认root就会多一点,而普通用户是根据配置来的</li></ul><h1>推荐阅读</h1><ol><li><a href="https://xie.infoq.cn/article/30eeb766ecfac245cc96c45c6">https://xie.infoq.cn/article/30eeb766ecfac245cc96c45c6</a></li><li><a href="https://www.cnblogs.com/Chary/p/15842219.html">https://www.cnblogs.com/Chary/p/15842219.html</a></li><li><a href="https://blog.csdn.net/cnbird2008/article/details/8666620">https://blog.csdn.net/cnbird2008/article/details/8666620</a></li><li><a href="https://elixir.bootlin.com/linux/latest/source">linux内核代码</a></li><li><a href="https://elixir.bootlin.com/linux/v5.10.143/source/kernel/fork.c#L2523">kernel/forc.c,内核定义的nproc最大值,810行左右</a></li></ol>]]></content>
    
    
    <summary type="html">too many open files 和 no more progres 解决方法</summary>
    
    
    
    <category term="故障处理" scheme="https://www.dddachui.top/categories/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
    
    <category term="故障处理" scheme="https://www.dddachui.top/tags/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>git拉取总是需要密码</title>
    <link href="https://www.dddachui.top/posts/e07e5f84.html"/>
    <id>https://www.dddachui.top/posts/e07e5f84.html</id>
    <published>2022-09-07T05:19:24.000Z</published>
    <updated>2023-03-13T12:30:45.002Z</updated>
    
    <content type="html"><![CDATA[<h1>解决办法</h1><ul><li>先在本地git仓库下执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><ul><li>然后拉取</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><ul><li>此时他会提示输入密码,完成验证之后就可以了</li></ul>]]></content>
    
    
    <summary type="html">免密上传</summary>
    
    
    
    <category term="故障处理" scheme="https://www.dddachui.top/categories/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
    
    <category term="故障处理" scheme="https://www.dddachui.top/tags/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux好用命令之nmcli</title>
    <link href="https://www.dddachui.top/posts/6ad86d1e.html"/>
    <id>https://www.dddachui.top/posts/6ad86d1e.html</id>
    <published>2022-09-04T04:06:22.000Z</published>
    <updated>2023-03-13T12:49:50.733Z</updated>
    
    <content type="html"><![CDATA[<h1>NetworkManager</h1><ol><li>NetworkManager服务是管理和监控网络设置的守护进程,Centos7之前的版本都是通过network.service管理网络配置</li><li>到了Centos7就同时支持network.service和NetworkManager.service</li><li>在RHEL 8/Centos 8上已废弃network.service（默认不安装）,只能通过NetworkManager进行网络配置。</li><li>NetworkManager主要管理2个对象 <code>Connection</code>（网卡连接配置） 和 <code>Device</code>（网卡设备）,他们之间是多对一的关系,但是同一时刻只能有一个Connection对于Device才生效</li></ol><h1>启动方法</h1><p>启动+开机自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now NetworkManager</span><br></pre></td></tr></table></figure><h1>三种方法配置网络</h1><ol><li>通过nmcli connection add命令配置,会自动生成ifcfg文件</li><li>手动配置ifcfg文件,通过nmcli connection reload来加载生效</li><li>手动配置ifcfg文件,通过传统network.service来加载生效</li></ol><h1>nmcli基操</h1><p>NetworkManager在系统中的管理工具为nmcli,这个命令<code>嘎嘎好用</code></p><h2 id="查看所有连接">查看所有连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show </span><br></pre></td></tr></table></figure><h2 id="查看所有激活的连接">查看所有激活的连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show --active</span><br></pre></td></tr></table></figure><h2 id="查看指定的网口的连接">查看指定的网口的连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show eth0</span><br></pre></td></tr></table></figure><h2 id="关闭连接">关闭连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection down eth0</span><br></pre></td></tr></table></figure><h2 id="启用连接">启用连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up eth0</span><br></pre></td></tr></table></figure><h1>nmcli配置网络实例-dhcp</h1><h2 id="新增连接">新增连接</h2><ul><li>创建一个连接名<code>dachui</code>,使用ens33设备</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui type Ethernet ifname ens33</span><br></pre></td></tr></table></figure><h2 id="展示创建后的效果">展示创建后的效果</h2><p>(实在不想配图)<br>可以看出只有一个行<code>NAME</code>是ens33是激活的(因为激活的连接在终端显示绿色,或者用–active可以看出来)</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME    UUID                                  TYPE      DEVICE </span><br><span class="line">ens33   c96bc909-188e-ec64-3a96-6a90982b08ad  ethernet  ens33  </span><br><span class="line">dachui  4b27c0d3-17d5-434b-90d1-5ac57a0f6147  ethernet  --     </span><br><span class="line">ens34   94aea789-efb3-ef4c-81b0-e8b18ecc9797  ethernet  -- </span><br></pre></td></tr></table></figure><h2 id="查看dachui的配置">查看<code>dachui</code>的配置</h2><p>如果不加<code>grep</code>,他会显示很多信息,但我们只需要关注ipv4的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show dachui | grep ipv4</span><br></pre></td></tr></table></figure><h2 id="配置展示">配置展示</h2><p>可以看出第一行<code>ipv4.method</code>的是<code>auto</code>,他代表<code>dachui</code>这个连接是用<code>dhcp</code>的方式获取ip的</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ipv4.method:                            auto</span><br><span class="line">ipv4.dns:                               --</span><br><span class="line">ipv4.dns-search:                        --</span><br><span class="line">ipv4.dns-options:                       &quot;&quot;</span><br><span class="line">ipv4.dns-priority:                      0</span><br><span class="line">ipv4.addresses:                         --</span><br><span class="line">ipv4.gateway:                           --</span><br><span class="line">ipv4.routes:                            --</span><br><span class="line">ipv4.route-metric:                      -1</span><br><span class="line">ipv4.route-table:                       0 (unspec)</span><br><span class="line">ipv4.routing-rules:                     --</span><br><span class="line">ipv4.ignore-auto-routes:                否</span><br><span class="line">ipv4.ignore-auto-dns:                   否</span><br><span class="line">ipv4.dhcp-client-id:                    --</span><br><span class="line">ipv4.dhcp-timeout:                      0 (default)</span><br><span class="line">ipv4.dhcp-send-hostname:                是</span><br><span class="line">ipv4.dhcp-hostname:                     --</span><br><span class="line">ipv4.dhcp-fqdn:                         --</span><br><span class="line">ipv4.never-default:                     否</span><br><span class="line">ipv4.may-fail:                          是</span><br><span class="line">ipv4.dad-timeout:                       -1 (default)</span><br></pre></td></tr></table></figure><h2 id="激活dhcp">激活dhcp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con show ens33 | grep IP4</span><br></pre></td></tr></table></figure><ul><li>激活的结果<br>可以看出这边ipv4的地址已经自动获取了</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP4.ADDRESS[1]:                         192.168.42.135/24</span><br><span class="line">IP4.GATEWAY:                            192.168.42.2</span><br><span class="line">IP4.ROUTE[1]:                           dst = 0.0.0.0/0, nh = 192.168.42.2, mt = 102</span><br><span class="line">IP4.ROUTE[2]:                           dst = 192.168.42.0/24, nh = 0.0.0.0, mt = 102</span><br><span class="line">IP4.DNS[1]:                             192.168.42.2</span><br><span class="line">IP4.DOMAIN[1]:                          localdomain</span><br></pre></td></tr></table></figure><h1>nmcli配置网络实例-static</h1><p>刚才是展示的新增一个连接,使用默认的<code>dhcp</code>方式配置网络,但实际项目中需要使用静态ip的方式,配置静态的手段有很多,可以对现在有<code>连接</code>进行系iu改,也可以再创建一个<code>连接</code>并且同时指定他的ip地址</p><h2 id="一次性创建">一次性创建</h2><p>乍一看命令<code>嘎嘎</code>长,其实很简单</p><ul><li><code>嘎嘎</code>长的命令,其实可以更长</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui-static type ethernet ifname ens33 ipv4.method manual ipv4.address 192.168.42.5/24 ipv4.gateway 192.168.42.2</span><br></pre></td></tr></table></figure><blockquote><p>我拆开两部分分析</p></blockquote><ol><li>创建连接,指定模式<br>这边就是创建了<code>dahcui-static</code>的连接,使用<code>type</code>指定此连接为<code>ethernet</code>(以太网),并且设备是<code>ens33</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add con-name dachui-static type ethernet ifname ens33</span><br></pre></td></tr></table></figure><ol start="2"><li>配置网络要素<br>一个ip地址至少需要指定一个<code>ip</code>和<code>子网掩码</code>才可以生效,网关也是需要配置的,还有指定是手动</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ipv4</span>.method manual ipv4.address <span class="number">192.168.42.5</span>/<span class="number">24</span> ipv4.gateway <span class="number">192.168.42.2</span></span><br></pre></td></tr></table></figure><ul><li>激活连接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static | grep IP4</span><br></pre></td></tr></table></figure><blockquote><p>输出为下面的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP4.ADDRESS[1]:                         192.168.42.5/24</span><br><span class="line">IP4.GATEWAY:                            192.168.42.2</span><br><span class="line">IP4.ROUTE[1]:                           dst = 0.0.0.0/0, nh = 192.168.42.2, mt = 102</span><br><span class="line">IP4.ROUTE[2]:                           dst = 192.168.42.0/24, nh = 0.0.0.0, mt = 102</span><br><span class="line">IP4.DNS[1]:                             192.168.42.2</span><br><span class="line">IP4.DOMAIN[1]:                          localdomain</span><br></pre></td></tr></table></figure><h2 id="编辑连接">编辑连接</h2><p>如果之前是创建好了多个连接,但是需要修改,可以通过modify的方法</p><ul><li>提示一点<br>如果要修改,请看好原先的<code>连接</code>是<code>自动获取</code>还是<code>手动获取</code>,如果是自动,需要改模式</li></ul><blockquote><p>可以一并加入修改的,我只是拆开提示一下,遇到过一次改了半天没生效,一看连接方式是dhcp</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static ipv4.method manual </span><br></pre></td></tr></table></figure><ul><li>修改ip<br>也可以修改其他的,在输入<code>dachui-static</code>之后按<code>tap</code>会列举出所有的<code>配置项</code>,然后根据语法修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static ipv4.address 192.168.42.200/24</span><br></pre></td></tr></table></figure><ul><li>重启网卡<br>修改之后需要激活一下才能生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up dachui-static</span><br></pre></td></tr></table></figure><blockquote><p>这样一个基本的nmlci创建连接就结束了</p></blockquote><h1>其他基操</h1><h2 id="增加路由">增加路由</h2><p>内网环境下,机器可能有多个网段,那么加路由肯定是必须的,比如我这需要访问<code>10.10.10.0/24</code>的机器,那么通过如下方法进行配置</p><ul><li>加路由</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static +ipv4.routes &quot;10.10.10.0/24 192.168.42.2&quot;</span><br></pre></td></tr></table></figure><ul><li>激活看信息</li></ul><ol><li>配置信息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP4.ROUTE[5]:                           dst = 10.10.10.0/24, nh = 192.168.42.2, mt = 102</span><br></pre></td></tr></table></figure><ol start="2"><li>路由信息</li></ol><ul><li>route展示</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><ul><li>输出结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.42.2    0.0.0.0         UG    102    0        0 ens33</span><br><span class="line">10.10.10.0      192.168.42.2    255.255.255.0   UG    102    0        0 ens33</span><br></pre></td></tr></table></figure><h2 id="删除路由">删除路由</h2><p>学会增加,也要学会删除</p><ul><li><code>乍一看</code>是不是一样的?其实将<code>+</code>改成<code>-</code>,然后<code>重新激活</code>就可以了</li></ul><blockquote><p>所以修改的逻辑很简单的,<code>+</code>就增加,<code>-</code>就是删除,<code>什么都不加</code>就是修改</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static -ipv4.routes &quot;10.10.10.0/24 192.168.42.2&quot;</span><br></pre></td></tr></table></figure><h2 id="增加ip">增加ip</h2><p>有时候需要在一个连接上加多个ip地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static +ipv4.addresses 2.2.2.2/16</span><br></pre></td></tr></table></figure><h2 id="删除连接">删除连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection delete dachui-static</span><br></pre></td></tr></table></figure><h2 id="网卡开机自启动">网卡开机自启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify dachui-static autoconnect yes</span><br></pre></td></tr></table></figure><h1>nmtui</h1><p>其实nmcli的玩法有很多,但其实还有一个工具<code>nmtui</code>,他是<code>NetworkManager-tui</code>的一个工具,通过字符图形化配置网络</p>]]></content>
    
    
    <summary type="html">配置网络工具</summary>
    
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux好用命令之top</title>
    <link href="https://www.dddachui.top/posts/5285e72b.html"/>
    <id>https://www.dddachui.top/posts/5285e72b.html</id>
    <published>2022-09-03T15:11:37.000Z</published>
    <updated>2023-03-13T12:51:07.435Z</updated>
    
    <content type="html"><![CDATA[<h1>命令简介</h1><p>top命令的功能是用于实时显示系统运行状态，包含处理器、内存、服务、进程等重要资源信息</p><h1>语法格式</h1><p>top [参数]</p><h1>用法</h1><h2 id="基本用法">基本用法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><h2 id="指定刷新时间">指定刷新时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -d 1</span><br></pre></td></tr></table></figure><h2 id="显示进程的命令行参数">显示进程的命令行参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -c</span><br></pre></td></tr></table></figure><h2 id="监视指定进程">监视指定进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 5201 -p 54231</span><br></pre></td></tr></table></figure><h2 id="显示指定用户">显示指定用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -u root</span><br></pre></td></tr></table></figure><blockquote><p>我的top输出</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 23:15:06 up 21 min,  3 users,  load average: 1.19, 0.72, 0.32</span><br><span class="line">Tasks: 191 total,   3 running, 144 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  1.5 us,  3.0 sy,  0.0 ni, 95.0 <span class="built_in">id</span>,  0.0 wa,  0.5 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  4009048 total,  2791500 free,   493780 used,   723768 buff/cache</span><br><span class="line">KiB Swap:   839676 total,   839676 free,        0 used.  3218592 avail Mem </span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                        </span><br><span class="line">8671 root      20   0  511852 105736  43568 S   4.0  2.6   0:04.58 X                                                                                              </span><br><span class="line">9872 root      20   0  702884  46780  35292 S   2.0  1.2   0:00.81 mate-terminal                                                                                        </span><br></pre></td></tr></table></figure><h1>top的交互功能</h1><ul><li>在top基本视图中，敲击c键，可以显示进程的路径</li><li>在top基本视图中，敲击k键，可以在不退出top命令的情况下杀死某个正在运行的进程</li><li>在top基本视图中，敲击1键，可监控每个逻辑CPU的状况</li><li>在top基本视图中，敲击上下键，可以增减显示的进程数目</li></ul><h1>top输出解释</h1><h2 id="第一行-基本信息">第一行-基本信息</h2><h3 id="系统当前时间">系统当前时间</h3><p>top - 23:15:06</p><h3 id="系统运行时间">系统运行时间</h3><p>up 21 min</p><h3 id="当前登录用户数量">当前登录用户数量</h3><p>3 users</p><h3 id="负载均衡情况">负载均衡情况</h3><p>load average: 1.19, 0.72, 0.32<br>三个数分别是1分钟、5分钟、15分钟的负载情况</p><blockquote><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以<code>逻辑CPU</code>的数量，结果高于5的时候就表明系统在超负荷运转了</p></blockquote><h2 id="第二行-进程">第二行-进程</h2><h3 id="总进程">总进程</h3><p>Tasks: 191 total</p><h3 id="当前运行进程数量">当前运行进程数量</h3><p>3 running</p><h3 id="休眠进程数量">休眠进程数量</h3><p>144 sleeping</p><h3 id="停止进程数量">停止进程数量</h3><p>0 stopped,</p><h3 id="僵尸进程数量">僵尸进程数量</h3><p>0 zombie</p><blockquote><p>在unix/linux中，正常情况下,子进程是通过父进程创建的,子进程在创建新的进程,子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束.当一个进程完成它的工作终止之后,它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态</p></blockquote><ul><li>孤儿进程<br>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li><li>僵尸进程<br>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</li></ul><h2 id="第三行-cpu状态">第三行-cpu状态</h2><h3 id="us">us</h3><p>用户空间占用CPU的百分比</p><h3 id="sy">sy</h3><p>内核空间占用CPU的百分比</p><h3 id="ni">ni</h3><p>改变过优先级的进程占用CPU的百分比</p><h3 id="id">id</h3><p>空闲CPU百分比</p><h3 id="wa">wa</h3><p>IO等待占用CPU的百分比</p><h3 id="hi">hi</h3><p>硬中断占用CPU的百分比</p><h3 id="si">si</h3><p>软中断占用CPU的百分比</p><h3 id="st">st</h3><p>当Linux系统是在虚拟机中运行时，等待CPU资源的时间占比</p><blockquote><p>简单说，Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p></blockquote><ul><li>Kernel space<br>用户空间可以执行任意命令，调用系统的一切资源；</li><li>User space<br>内核空间只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令</li></ul><h2 id="第四行-内存状态">第四行-内存状态</h2><h3 id="total">total</h3><p>总内存量4009048</p><h3 id="free">free</h3><p>空闲内存2791500</p><h3 id="used">used</h3><p>已用内存493780</p><h3 id="buff-cache">buff/cache</h3><p>缓存内存723768</p><blockquote><p>KiB Mem：Kib表示描述单位，MEM表示内存</p></blockquote><h2 id="第五行-swap状态">第五行-swap状态</h2><h3 id="total-2">total</h3><p>总内存量839676</p><h3 id="free-2">free</h3><p>空闲内存839676</p><h3 id="used-2">used</h3><p>已用内存0</p><h3 id="avail-Mem">avail Mem</h3><p>可用内存3218592</p><ul><li>free 是真正尚未被使用的物理内存数量。</li><li>available 是应用程序认为可用内存数量，available = free + buffer + cache (注：只是大概的计算方法)</li></ul><h2 id="第六行-进程监控">第六行-进程监控</h2><ul><li>PID — 进程id</li><li>USER — 进程所有者</li><li>PR — 进程优先级</li><li>NI — nice值。负值表示高优先级，正值表示低优先级</li><li>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li><li>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li><li>SHR — 共享内存大小，单位kb</li><li>S — 进程状态。D=不可中断的睡眠状态；R=运行；S=睡眠；T=跟踪/停止；Z=僵尸进程</li><li>%CPU — 上次更新到现在的CPU时间占用百分比</li><li>%MEM — 进程使用的物理内存百分比</li><li>TIME+ — 进程使用的CPU时间总计，单位1/100秒</li><li>COMMAND — 进程名称（命令名/命令行）</li></ul>]]></content>
    
    
    <summary type="html">终端任务管理器</summary>
    
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux好用命令之systemctl</title>
    <link href="https://www.dddachui.top/posts/5154c07a.html"/>
    <id>https://www.dddachui.top/posts/5154c07a.html</id>
    <published>2022-08-05T08:53:55.000Z</published>
    <updated>2023-03-13T12:50:56.964Z</updated>
    
    <content type="html"><![CDATA[<h1>概念</h1><ul><li>systemd<br>systemd是与SysV和LSB初始化脚本兼容的系统和服务管理器,开启systemd服务,可以基于守护进程按需启动策略<br>systemd服务支持快照和系统状态恢复,维护挂载和自动挂载点,服务之间的从属关系也有逻辑控制</li><li>systemd unit<br>system服务的开启和监督系统是基于unit的,unit就是一个与配置文件对应的名称和类型组成,unit的类型如下</li></ul><ol><li>service unit 系统服务</li><li>Target unit 一组systemd units</li><li>Automount unit 文件系统挂载点</li><li>Device unit  内核识别的设备文件</li><li>Mount unit   文件系统挂载点</li><li>Path unit    一个文件系统中的文件或目录</li><li>Scope unit  外部创建的进程</li><li>Snapshot unit   systemd manager  的保存状态</li></ol><ul><li>systemd的特性</li></ul><ol><li>更快的启动速度</li><li>按需启动能力</li><li>采用cgroup特性跟踪和管理进程的生命周期</li><li>采用挂载点和自动挂载的管理</li><li>实现事务依赖性关系管理</li><li>与SysV初始化脚本兼容</li><li>对系统进程快照和恢复</li></ol><h1>管理服务</h1><p>用systemctl命令管理进行 运行 启动 重启 显示 自启动 关闭自启动 等</p><h1>基操</h1><h2 id="显示运行的服务">显示运行的服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type service</span><br></pre></td></tr></table></figure><h2 id="显示所有的服务">显示所有的服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type service --all</span><br></pre></td></tr></table></figure><h2 id="查看服务状态">查看服务状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status httpd</span><br></pre></td></tr></table></figure><ul><li>显示指标<br>loaded: 说明服务是否被加载,同时显示对应的绝对路径是否启用<br>active: 是否运行<br>main pid: 进程pid<br>cgroup: 相关控制组的其他信息</li></ul><h2 id="管理服务的基操">管理服务的基操</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start sshd</span><br><span class="line">systemctl stop  sshd</span><br><span class="line">systemctl restart sshd</span><br><span class="line">systemctl enable sshd</span><br><span class="line">systemctl disable sshd</span><br></pre></td></tr></table></figure><h2 id="操作系统电源">操作系统电源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl poweroff  #关闭系统,下电</span><br><span class="line">systemctl halt      #关闭系统,不下电</span><br><span class="line">systemctl reboot    #重启</span><br><span class="line">systemctl suspend   #待机</span><br><span class="line">systemctl hibernate  #休眠</span><br><span class="line">systemctl hybrid-sleep #待机+休眠</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">服务管理</summary>
    
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux好用命令之dnf</title>
    <link href="https://www.dddachui.top/posts/a36cc04b.html"/>
    <id>https://www.dddachui.top/posts/a36cc04b.html</id>
    <published>2022-08-05T05:34:05.000Z</published>
    <updated>2023-03-13T12:48:53.249Z</updated>
    
    <content type="html"><![CDATA[<h1>命令简介</h1><p>DNF:Dandified YUM,是基于RPM的Linux发行版的软件包管理器,它用于在 Fedora / RHEL / CentOS操作系统中安装,更新和删除软件包,目前 DNF 命令和yum命令相互兼容,软件包仓库依旧使用 YUM 仓库。</p><h1>注意</h1><p>dnf和yum的基础命令都是兼容的,但是dnf默认安装了很多插件,后会出一个插件的学习记录</p><h1>配置dnf</h1><ul><li>dnf主要配置文件<br>/etc/dnf/dnf.conf<br>在rockylinux和centos9stream系统中/etc/yum.conf是指向dnf.conf的软链接,内容如下</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">installonly_limit</span>=<span class="number">3</span></span><br><span class="line"><span class="attr">clean_requirements_on_remove</span>=<span class="literal">True</span></span><br><span class="line"><span class="attr">best</span>=<span class="literal">True</span></span><br><span class="line"><span class="attr">skip_if_unavailable</span>=<span class="literal">False</span></span><br></pre></td></tr></table></figure><p>参数说明</p><ol><li>cachedir:缓存目录,存储rpm包和数据库文件(默认没写,在其他路径)</li><li>best: 升级包的时候总是尝试安装最高版本,如果最高不能装就停止并显示原因</li><li>installonly_limit: 同时安装&quot;installonlypkgs&quot; 指令列出包的数量,默认3,不建议降低</li><li>clean_requirements_on_remove:删除dnf remove期间不在使用的依赖项,即是dnf连带安装的依赖,只能通过此参数为true来删除</li></ol><h1>设置仓库</h1><h2 id="修改dnf源文件">修改dnf源文件</h2><p>还是修改/etc/yum.repos.d下面的repo文件,配置和yum一样</p><h2 id="创建本地源仓库">创建本地源仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install createrepo</span><br></pre></td></tr></table></figure><ul><li>将软件包放在该目录下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createrepo --database /mnt/test </span><br></pre></td></tr></table></figure><h2 id="命令添加源">命令添加源</h2><p>会在/etc/yum.repo.d下生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --add-repo repo_url</span><br></pre></td></tr></table></figure><h1>查看源</h1><ul><li>查看本机配置的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf repolist</span><br></pre></td></tr></table></figure><ul><li>查看具体的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf repolist base</span><br></pre></td></tr></table></figure><h1>启停源</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --set-enable repo_name</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --set-disable repo_name</span><br></pre></td></tr></table></figure><h1>基操</h1><p>基本没yum没有区别</p><ul><li>查</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf search ssh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf provides ssh</span><br></pre></td></tr></table></figure><ul><li>列举安装的包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf list all</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf list openssh</span><br></pre></td></tr></table></figure><ul><li>查看包的信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf info openssh</span><br></pre></td></tr></table></figure><h1>光下载不安装</h1><p>这是一个dnf插件实现的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf download package_name</span><br></pre></td></tr></table></figure><h1>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install httpd</span><br></pre></td></tr></table></figure><h1>卸载软件包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf remove httpd</span><br></pre></td></tr></table></figure><h1>列出详细的组信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf  groups info &quot;开发工具&quot;</span><br></pre></td></tr></table></figure><h1>安装卸载软件包组</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf groups install 软件包组/id</span><br><span class="line">dnf groups remove 软件包组/id</span><br></pre></td></tr></table></figure><h1>检查更新</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf check-update</span><br></pre></td></tr></table></figure><h1>升级软件包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf update</span><br></pre></td></tr></table></figure><h1>升级单独的</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf update 包名</span><br></pre></td></tr></table></figure><h1>升级组</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf group update group_name</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">dnf包管理工具</summary>
    
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="linux命令" scheme="https://www.dddachui.top/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
